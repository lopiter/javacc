options {
  IGNORE_CASE = true;
  DEBUG_LOOKAHEAD = true;
  LOOKAHEAD = 8;
  STATIC = false;
  UNICODE_INPUT = true;
  JAVA_UNICODE_ESCAPE = false;
  ERROR_REPORTING = false;
  OUTPUT_DIRECTORY = "../src/com/realizesoft/parser/dom/oracle/internal";  
}

PARSER_BEGIN(OracleParser)

package com.realizesoft.parser.dom.oracle.internal;

public class OracleParser
{}

PARSER_END(OracleParser)

<SQL_STATE> TOKEN :
{
 <ESQL_EQ : "=" >
}

/*JAVACC_TOKEN_START*/


<SQL_STATE> SKIP :
{
 < ( " " | "\t" | "\r" | "\n" | ":" | ";")+ >
}

<SQL_STATE> TOKEN :
{
  < SQL_AS : "AS" >
| < SQL_BY : "BY" >
| < SQL_DO : "DO" >
| < SQL_IS : "IS" >
| < SQL_IN : "IN" >
| < SQL_OR : "OR" >
| < SQL_ON : "ON" >
| < SQL_ALL : "ALL" >
| < SQL_AND : "AND" >
| < SQL_ANY : "ANY" >
| < SQL_KEY : "KEY" >
| < SQL_NOT : "NOT" >
| < SQL_A_SET : "A SET" >
| < SQL_SET : "SET" >
| < SQL_ASC : "ASC" >
| < SQL_TOP : "TOP" >
| < SQL_END : "END" >
| < SQL_DESC : "DESC" >
| < SQL_INTO : "INTO" >
| < SQL_NULL : "NULL" >
| < SQL_LIKE : "LIKE" >
| < SQL_DROP : "DROP" >
| < SQL_JOIN : "JOIN" >
| < SQL_LEFT : "LEFT" >
| < SQL_FROM : "FROM" >
| < SQL_OPEN : "OPEN" >
| < SQL_CASE : "CASE" >
| < SQL_WHEN : "WHEN" >
| < SQL_THEN : "THEN" >
| < SQL_ELSE : "ELSE" >
| < SQL_SOME : "SOME" >
| < SQL_FULL : "FULL" >
| < SQL_WITH : "WITH" >
| < SQL_TABLE : "TABLE" >
| < SQL_WHERE : "WHERE" >
| < SQL_USING : "USING" >
| < SQL_UNION : "UNION" >
| < SQL_GROUP : "GROUP" >
| < SQL_BEGIN : "BEGIN" >
| < SQL_INDEX : "INDEX" >
| < SQL_INNER : "INNER" >
| < SQL_LIMIT : "LIMIT" >
| < SQL_OUTER : "OUTER" >
| < SQL_ORDER : "ORDER" >
| < SQL_RIGHT : "RIGHT" >
| < SQL_DELETE : "DELETE" >
| < SQL_CREATE : "CREATE" >
| < SQL_SELECT : "SELECT" >
| < SQL_OFFSET : "OFFSET" >
| < SQL_EXISTS : "EXISTS" >
| < SQL_HAVING : "HAVING" >
| < SQL_INSERT : "INSERT" >
| < SQL_UPDATE : "UPDATE" >
| < SQL_VALUES : "VALUES" >
| < SQL_ESCAPE : "ESCAPE" >
| < SQL_PRIMARY : "PRIMARY" >
| < SQL_NATURAL : "NATURAL" >
| < SQL_REPLACE : "REPLACE" >
| < SQL_BETWEEN : "BETWEEN" >
| < SQL_TRUNCATE : "TRUNCATE" >
| < SQL_DISTINCT : "DISTINCT" >
| < SQL_INTERSECT : "INTERSECT" >
| < SQL_ORA_DECODE : "DECODE" >
| < SQL_ORA_NVL : "NVL" >
| < SQL_ORA_NVL2 : "NVL2" >
| < SQL_ORA_SUBSTR : "SUBSTR" >
| < SQL_ORA_SUBSTRB : "SUBSTRB" >
| < SQL_ORA_SUM : "SUM" >
| < SQL_ORA_CONCAT : "CONCAT" >
| < SQL_ORA_INICAP : "INICAP" >
| < SQL_ORA_LOWER : "LOWER" >
| < SQL_ORA_UPPER : "UPPER" >
| < SQL_ORA_LENGTH : "LENGTH" >
| < SQL_ORA_LENGTHB : "LENGTHB" >
| < SQL_ORA_INSTR : "INSTR" >
| < SQL_ORA_LPAD : "LPAD" >
| < SQL_ORA_RPAD : "RPAD" >
| < SQL_ORA_LTRIM : "LTRIM" >
| < SQL_ORA_RTRIM : "RTRIM" >
| < SQL_ORA_TRIM : "TRIM" >
| < SQL_ORA_ROUND : "ROUND" >
| < SQL_ORA_TRUNC : "TRUNC" >
| < SQL_ORA_MOD : "MOD" >
| < SQL_ORA_CEIL : "CEIL" >
| < SQL_ORA_FLOOR : "FLOOR" >
| < SQL_ORA_TO_CHAR : "TO_CHAR" >
| < SQL_ORA_TO_NUMBER : "TO_NUMBER" >
| < SQL_ORA_TO_DATE : "TO_DATE" >
| < SQL_ORA_OVER : "OVER" >
| < SQL_ORA_RANK : "RANK" >
| < SQL_ORA_ABS : "ABS" >
| < SQL_ORA_ACOS : "ACOS" >
| < SQL_ORA_ATAN : "ATAN" >
| < SQL_ORA_ATAN2 : "ATAN2" >
| < SQL_ORA_BITAND : "BITAND" >
| < SQL_ORA_COS : "COS" >
| < SQL_ORA_COSH : "COSH" >
| < SQL_ORA_EXP : "EXP" >
| < SQL_ORA_LN : "LN" >
| < SQL_ORA_LOG : "LOG" >
| < SQL_ORA_NANVL : "NANVL" >
| < SQL_ORA_POWER : "POWER" >
| < SQL_ORA_REMAINDER : "REMAINDER" >
| < SQL_ORA_SIGN : "SIGN" >
| < SQL_ORA_SIN : "SIN" >
| < SQL_ORA_SINH : "SINH" >
| < SQL_ORA_SQRT : "SQRT" >
| < SQL_ORA_TAN : "TAN" >
| < SQL_ORA_TANH : "TANH" >
| < SQL_ORA_WIDTH_BUCKET : "WIDTH_BUCKET" >
| < SQL_ORA_CHR : "CHR" >
| < SQL_ORA_INITCAP : "INITCAP" >
| < SQL_ORA_NLS_INITCAP : "NLS_INITCAP" >
| < SQL_ORA_NLS_LOWER : "NLS_LOWER" >
| < SQL_ORA_NLSSORT : "NLSSORT" >
| < SQL_ORA_NLS_UPPER : "NLS_UPPER" >
| < SQL_ORA_REGEXP_REPLACE : "REGEXP_REPLACE" >
| < SQL_ORA_REGEXP_SUBSTR : "REGEXP_SUBSTR" >
| < SQL_ORA_SOUNDEX : "SOUNDEX" >
| < SQL_ORA_TRANSLATE : "TRANSLATE" >
| < SQL_ORA_TREAT : "TREAT" >
| < SQL_ORA_ASCII : "ASCII" >
| < SQL_ORA_REGEXP_INSTR : "REGEXP_INSTR" >
| < SQL_ORA_ADD_MONTHS : "ADD_MONTHS" >
| < SQL_ORA_CURRENT_DATE : "CURRENT_DATE" >
| < SQL_ORA_CURRENT_TIMESTAMP : "CURRENT_TIMESTAMP" >
| < SQL_ORA_DBTIMEZONE : "DBTIMEZONE" >
| < SQL_ORA_EXTRACT : "EXTRACT" >
| < SQL_ORA_FROM_TZ : "FROM_TZ" >
| < SQL_ORA_LAST_DAY : "LAST_DAY" >
| < SQL_ORA_LOCALTIMESTAMP : "LOCALTIMESTAMP" >
| < SQL_ORA_MONTHS_BETWEEN : "MONTHS_BETWEEN" >
| < SQL_ORA_NEW_TIME : "NEW_TIME" >
| < SQL_ORA_NEXT_DAY : "NEXT_DAY" >
| < SQL_ORA_NUMTODSINTERVAL : "NUMTODSINTERVAL" >
| < SQL_ORA_NUMTOYMINTERVAL : "NUMTOYMINTERVAL" >
| < SQL_ORA_SESSIONTIMEZONE : "SESSIONTIMEZONE" >
| < SQL_ORA_SYS_EXTRACT_UTC : "SYS_EXTRACT_UTC" >
| < SQL_ORA_SYSDATE : "SYSDATE" >
| < SQL_ORA_SYSTIMESTAMP : "SYSTIMESTAMP" >
| < SQL_ORA_TO_TIMESTAMP : "TO_TIMESTAMP" >
| < SQL_ORA_TO_TIMESTAMP_TZ : "TO_TIMESTAMP_TZ" >
| < SQL_ORA_TO_DSINTERVAL : "TO_DSINTERVAL" >
| < SQL_ORA_TO_YMINTERVAL : "TO_YMINTERVAL" >
| < SQL_ORA_TZ_OFFSET : "TZ_OFFSET" >
| < SQL_ORA_ASCIISTR : "ASCIISTR" >
| < SQL_ORA_BIN_TO_NUM : "BIN_TO_NUM" >
| < SQL_ORA_CAST : "CAST" >
| < SQL_ORA_CHARTOROWID : "CHARTOROWID" >
| < SQL_ORA_COMPOSE : "COMPOSE" >
| < SQL_ORA_CONVERT : "CONVERT" >
| < SQL_ORA_DECOMPOSE : "DECOMPOSE" >
| < SQL_ORA_HEXTORAW : "HEXTORAW" >
| < SQL_ORA_RAWTOHEX : "RAWTOHEX" >
| < SQL_ORA_RAWTONHEX : "RAWTONHEX" >
| < SQL_ORA_ROWIDTOCHAR : "ROWIDTOCHAR" >
| < SQL_ORA_ROWIDTONCHAR : "ROWIDTONCHAR" >
| < SQL_ORA_SCN_TO_TIMESTAMP : "SCN_TO_TIMESTAMP" >
| < SQL_ORA_TIMESTAMP_TO_SCN : "TIMESTAMP_TO_SCN" >
| < SQL_ORA_TO_BINARY_DOUBLE : "TO_BINARY_DOUBLE" >
| < SQL_ORA_TO_BINARY_FLOAT : "TO_BINARY_FLOAT" >
| < SQL_ORA_TO_CLOB : "TO_CLOB" >
| < SQL_ORA_TO_LOB : "TO_LOB" >
| < SQL_ORA_TO_MULTI_BYTE : "TO_MULTI_BYTE" >
| < SQL_ORA_TO_NCHAR : "TO_NCHAR" >
| < SQL_ORA_TO_NCLOB : "TO_NCLOB" >
| < SQL_ORA_TO_SINGLE_BYTE : "TO_SINGLE_BYTE" >
| < SQL_ORA_UNISTR : "UNISTR" >
| < SQL_ORA_CARDINALITY : "CARDINALITY" >
| < SQL_ORA_COLLECT : "COLLECT" >
| < SQL_ORA_POWERMULTISET : "POWERMULTISET" >
| < SQL_ORA_POWERMULTISET_BY_CARDINALITY : "POWERMULTISET_BY_CARDINALITY" >
| < SQL_ORA_BFILENAME : "BFILENAME" >
| < SQL_ORA_COALESCE : "COALESCE" >
| < SQL_ORA_CV : "CV" >
| < SQL_ORA_DEPTH : "DEPTH" >
| < SQL_ORA_DUMP : "DUMP" >
| < SQL_ORA_EMPTY_BLOB : "EMPTY_BLOB " >
| < SQL_ORA_EMPTY_CLOB : "EMPTY_CLOB" >
| < SQL_ORA_EXISTSNODE : "EXISTSNODE" >
| < SQL_ORA_EXTRACTVALUE : "EXTRACTVALUE" >
| < SQL_ORA_GREATEST : "GREATEST" >
| < SQL_ORA_LEAST : "LEAST" >
| < SQL_ORA_LNNVL : "LNNVL" >
| < SQL_ORA_NLS_CHARSET_DECL_LEN : "NLS_CHARSET_DECL_LEN" >
| < SQL_ORA_NLS_CHARSET_ID : "NLS_CHARSET_ID" >
| < SQL_ORA_NLS_CHARSET_NAME : "NLS_CHARSET_NAME" >
| < SQL_ORA_NULLIF : "NULLIF" >
| < SQL_ORA_ORA_HASH : "ORA_HASH" >
| < SQL_ORA_PATH : "PATH" >
| < SQL_ORA_PRESENTNNV : "PRESENTNNV" >
| < SQL_ORA_PRESENTV : "PRESENTV" >
| < SQL_ORA_PREVIOUS : "PREVIOUS" >
| < SQL_ORA_SYS_CONNECT_BY_PATH : "SYS_CONNECT_BY_PATH" >
| < SQL_ORA_SYS_CONTEXT : "SYS_CONTEXT" >
| < SQL_ORA_SYS_DBURIGEN : "SYS_DBURIGEN" >
| < SQL_ORA_SYS_GUID : "SYS_GUID" >
| < SQL_ORA_SYS_TYPEID : "SYS_TYPEID" >
| < SQL_ORA_SYS_XMLAGG : "SYS_XMLAGG" >
| < SQL_ORA_SYS_XMLGEN : "SYS_XMLGEN" >
| < SQL_ORA_UID : "UID" >
| < SQL_ORA_UPDATEXML : "UPDATEXML" >
| < SQL_ORA_USER : "USER" >
| < SQL_ORA_USERENV : "USERENV" >
| < SQL_ORA_VSIZE : "VSIZE" >
| < SQL_ORA_XMLAGG : "XMLAGG" >
| < SQL_ORA_XMLCOLATTVAL : "XMLCOLATTVAL" >
| < SQL_ORA_XMLCONCAT : "XMLCONCAT" >
| < SQL_ORA_XMLFOREST : "XMLFOREST" >
| < SQL_ORA_XMLSEQUENCE : "XMLSEQUENCE" >
| < SQL_ORA_XMLTRANSFORM : "XMLTRANSFORM" >
| < SQL_ORA_AVG : "AVG" >
| < SQL_ORA_CORR : "CORR" >
| < SQL_ORA_COUNT : "COUNT" >
| < SQL_ORA_COVAR_POP : "COVAR_POP" >
| < SQL_ORA_COVAR_SAMP : "COVAR_SAMP" >
| < SQL_ORA_CUME_DIST : "CUME_DIST" >
| < SQL_ORA_DENSE_RANK : "DENSE_RANK" >
| < SQL_ORA_FIRST : "FIRST" >
| < SQL_ORA_GROUP_ID : "GROUP_ID" >
| < SQL_ORA_GROUPING : "GROUPING" >
| < SQL_ORA_GROUPING_ID : "GROUPING_ID" >
| < SQL_ORA_LAST : "LAST" >
| < SQL_ORA_MAX : "MAX" >
| < SQL_ORA_MEDIAN : "MEDIAN" >
| < SQL_ORA_MIN : "MIN" >
| < SQL_ORA_PERCENTILE_CONT : "PERCENTILE_CONT" >
| < SQL_ORA_PERCENTILE_DISC : "PERCENTILE_DISC" >
| < SQL_ORA_PERCENT_RANK : "PERCENT_RANK" >
| < SQL_ORA_STATS_BINOMIAL_TEST : "STATS_BINOMIAL_TEST" >
| < SQL_ORA_STATS_CROSSTAB : "STATS_CROSSTAB" >
| < SQL_ORA_STATS_F_TEST : "STATS_F_TEST" >
| < SQL_ORA_STATS_KS_TEST : "STATS_KS_TEST" >
| < SQL_ORA_STATS_MODE : "STATS_MODE" >
| < SQL_ORA_STATS_MW_TEST : "STATS_MW_TEST" >
| < SQL_ORA_STATS_ONE_WAY_ANOVA : "STATS_ONE_WAY_ANOVA" >
| < SQL_ORA_STATS_WSR_TEST : "STATS_WSR_TEST" >
| < SQL_ORA_STDDEV : "STDDEV" >
| < SQL_ORA_STDDEV_POP : "STDDEV_POP" >
| < SQL_ORA_STDDEV_SAMP : "STDDEV_SAMP" >
| < SQL_ORA_VAR_POP : "VAR_POP" >
| < SQL_ORA_VAR_SAMP : "VAR_SAMP" >
| < SQL_ORA_VARIANCE : "VARIANCE" >
| < SQL_ORA_NTILE : "NTILE" >
| < SQL_ORA_RATIO_TO_REPORT : "RATIO_TO_REPORT" >
| < SQL_ORA_DEREF : "DEREF" >
| < SQL_ORA_MAKE_REF : "MAKE_REF" >
| < SQL_ORA_REF : "REF" >
| < SQL_ORA_REFTOHEX : "REFTOHEX" >
| < SQL_ORA_VALUE : "VALUE" >
| < SQL_ORA_ITERATION_NUMBER : "ITERATION_NUMBER" >
| < SQL_ASTERISKCHAR: "*" >
| < SQL_LPARENCHAR: "(" >
| < SQL_RPARENCHAR: ")" >
| < SQL_QUESTIONCHAR: "?" >
| < SQL_MORETHANCHAR: ">" >
| < SQL_LESSTHANCHAR: "<" >
| < SQL_MORETHANOREQUAL: ">=" >
| < SQL_LESSTHANOREQUAL: "<=" >
| < SQL_UNEQUALCHAR: "<>" >
| < SQL_NOTEQUALCHAR: "!=" >
| < SQL_CONCATCHAR: "||" >
| < SQL_ORCHAR: "|" >
| < SQL_NOTEQUALCHAR_WITH_XOR: "^=" >
| < SQL_XORCHAR: "^" >
| < SQL_ANDCHAR: "&" >
| < SQL_PLUSCHAR: "+" >
| < SQL_SLASHCHAR: "/" >
| < SQL_MINUSCHAR: "-" >
| < SQL_LBRACKET : "{" >
| < SQL_RBRACKET : "}" >
| < SQL_D_CHAR : "{d" >
| < SQL_T_CHAR : "{t" >
| < SQL_TS_CHAR : "{ts" >
| < SQL_FN_CHAR : "{fn" >
| < APOSTROPHE: "'" >
| < RIGHT_: "]" >
| < LEFT_: "[" >
| < CHAR : "CHAR" >
| < BYTE : "BYTE" >
| < VARCHAR2 : "VARCHAR2" >
| < NCHAR : "NCHAR" >
| < NVARCHAR2 : "NVARCHAR2" >
| < NUMBER : "NUMBER" >
| < FLOAT : "FLOAT" >
| < BINARY_FLOAT : "BINARY_FLOAT" >
| < BINARY_DOUBLE : "BINARY_DOUBLE" >
| < LONG : "LONG" >
| < RAW : "RAW" >
| < DATE : "DATE" >
| < TIMESTAMP : "TIMESTAMP" >
| < LOCAL : "LOCAL" >
| < TIME : "TIME" >
| < ZONE : "ZONE" >
| < INTERVAL : "INTERVAL" >
| < YEAR : "YEAR" >
| < TO : "TO" >
| < MONTH : "MONTH" >
| < DAY : "DAY" >
| < SECOND : "SECOND" >
| < BLOB : "BLOB" >
| < CLOB : "CLOB" >
| < NCLOB : "NCLOB" >
| < BFILE : "BFILE" >
| < ROWID : "ROWID" >
| < UROWID : "UROWID" >
| < CHARACTER : "CHARACTER" >
| < VARYING : "VARYING" >
| < VARCHAR : "VARCHAR" >
| < NATIONAL : "NATIONAL" >
| < NUMERIC : "NUMERIC" >
| < DECIMAL : "DECIMAL" >
| < DEC : "DEC" >
| < INTEGER : "INTEGER" >
| < INT : "INT" >
| < SMALLINT : "SMALLINT" >
| < DOUBLE : "DOUBLE" >
| < PRECISION : "PRECISION" >
| < REAL : "REAL" >
| < SYS_AnyData : "SYS.AnyData" >
| < SYS_AnyType : "SYS.AnyType" >
| < SYS_AnyDataSet : "SYS.AnyDataSet" >
| < XMLType : "XMLType" >
| < URIType : "URIType" >
| < SDO_Geometry : "SDO_Geometry" >
| < SDO_Topo_Geometry : "SDO_Topo_Geometry" >
| < SDO_GeoRaster : "SDO_GeoRaster" >
| < ORDAudio : "ORDAudio" >
| < ORDImage : "ORDImage" >
| < ORDVideo : "ORDVideo" >
| < ORDDoc : "ORDDoc" >
| < ORDDicom : "ORDDicom" >
| < SI_StillImage : "SI_StillImage" >
| < SI_AverageColor : "SI_AverageColor" >
| < SI_PositionalColor : "SI_PositionalColor" >
| < SI_ColorHistogram : "SI_ColorHistogram" >
| < SI_Texture : "SI_Texture" >
| < SI_FeatureList : "SI_FeatureList" >
| < SI_Color : "SI_Color" >
| < N : "N" >
| < Q : "Q" >
| < HOUR : "HOUR" >
| < MINUTE : "MINUTE" >
| < ALL_ROWS : "ALL_ROWS" >
| < APPEND : "APPEND" >
| < APPEND_VALUES : "APPEND_VALUES" >
| < CACHE : "CACHE" >
| < CHANGE_DUPKEY_ERROR_INDEX : "CHANGE_DUPKEY_ERROR_INDEX" >
| < CLUSTER : "CLUSTER" >
| < CLUSTERING : "CLUSTERING" >
| < CURSOR_SHARING_EXACT : "CURSOR_SHARING_EXACT" >
| < DRIVING_SITE : "DRIVING_SITE" >
| < DYNAMIC_SAMPLING : "DYNAMIC_SAMPLING" >
| < FACT : "FACT" >
| < FIRST_ROWS : "FIRST_ROWS" >
| < GATHER_OPTIMIZER_STATISTICS : "GATHER_OPTIMIZER_STATISTICS" >
| < HASH : "HASH" >
| < IGNORE_ROW_ON_DUPKEY_INDEX : "IGNORE_ROW_ON_DUPKEY_INDEX" >
| < INDEX_ASC : "INDEX_ASC" >
| < INDEX_COMBINE : "INDEX_COMBINE" >
| < INDEX_DESC : "INDEX_DESC" >
| < INDEX_FFS : "INDEX_FFS" >
| < INDEX_JOIN : "INDEX_JOIN" >
| < INDEX_SS : "INDEX_SS" >
| < INDEX_SS_ASC : "INDEX_SS_ASC" >
| < INDEX_SS_DESC : "INDEX_SS_DESC" >
| < INMEMORY : "INMEMORY" >
| < INMEMORY_PRUNING : "INMEMORY_PRUNING" >
| < LEADING : "LEADING" >
| < MERGE : "MERGE" >
| < MODEL_MIN_ANALYSIS : "MODEL_MIN_ANALYSIS" >
| < MONITOR : "MONITOR" >
| < NATIVE_FULL_OUTER_JOIN : "NATIVE_FULL_OUTER_JOIN" >
| < NOAPPEND : "NOAPPEND" >
| < NOCACHE : "NOCACHE" >
| < NO_CLUSTERING : "NO_CLUSTERING" >
| < NO_EXPAND : "NO_EXPAND" >
| < NO_FACT : "NO_FACT" >
| < NO_GATHER_OPTIMIZER_STATISTICS : "NO_GATHER_OPTIMIZER_STATISTICS" >
| < NO_INDEX : "NO_INDEX" >
| < NO_INDEX_FFS : "NO_INDEX_FFS" >
| < NO_INDEX_SS : "NO_INDEX_SS" >
| < NO_INMEMORY : "NO_INMEMORY" >
| < NO_INMEMORY_PRUNING : "NO_INMEMORY_PRUNING" >
| < NO_MERGE : "NO_MERGE" >
| < NO_MONITOR : "NO_MONITOR" >
| < NO_NATIVE_FULL_OUTER_JOIN : "NO_NATIVE_FULL_OUTER_JOIN" >
| < NO_PARALLEL : "NO_PARALLEL" >
| < NO_PARALLEL_INDEX : "NO_PARALLEL_INDEX" >
| < NO_PQ_CONCURRENT_UNION : "NO_PQ_CONCURRENT_UNION" >
| < NO_PQ_SKEW : "NO_PQ_SKEW" >
| < NO_PUSH_PRED : "NO_PUSH_PRED" >
| < NO_PUSH_SUBQ : "NO_PUSH_SUBQ" >
| < NO_PX_JOIN_FILTER : "NO_PX_JOIN_FILTER" >
| < NO_QUERY_TRANSFORMATION : "NO_QUERY_TRANSFORMATION" >
| < NO_RESULT_CACHE : "NO_RESULT_CACHE" >
| < NO_REWRITE : "NO_REWRITE" >
| < NO_STAR_TRANSFORMATION : "NO_STAR_TRANSFORMATION" >
| < NO_STATEMENT_QUEUING : "NO_STATEMENT_QUEUING" >
| < NO_UNNEST : "NO_UNNEST" >
| < NO_USE_CUBE : "NO_USE_CUBE" >
| < NO_USE_HASH : "NO_USE_HASH" >
| < NO_USE_MERGE : "NO_USE_MERGE" >
| < NO_USE_NL : "NO_USE_NL" >
| < NO_XMLINDEX_REWRITE : "NO_XMLINDEX_REWRITE" >
| < NO_XML_QUERY_REWRITE : "NO_XML_QUERY_REWRITE" > 
| < NO_ZONEMAP : "NO_ZONEMAP" >
| < SCAN : "SCAN" >
| < PARTITION : "PARTITION" >
| < OPT_PARAM : "OPT_PARAM" >
| < ORDERED : "ORDERED" >
| < PARALLEL : "PARALLEL" >
| < SQL_DEFAULT : "SQL_DEFAULT" >
| < AUTO : "AUTO" >
| < MANUAL : "MANUAL" >
| < PARALLEL_INDEX : "PARALLEL_INDEX" >
| < PQ_CONCURRENT_UNION : "PQ_CONCURRENT_UNION" >
| < PQ_DISTRIBUTE : "PQ_DISTRIBUTE" >
| < PQ_FILTER : "PQ_FILTER" >
| < SERIAL : "SERIAL" >
| < NONE : "NONE" >
| < RANDOM : "RANDOM" >
| < PQ_SKEW : "PQ_SKEW" >
| < PUSH_PRED : "PUSH_PRED" >
| < PUSH_SUBQ : "PUSH_SUBQ" >
| < PX_JOIN_FILTER : "PX_JOIN_FILTER" >
| < QB_NAME : "QB_NAME" >
| < RESULT_CACHE : "RESULT_CACHE" >
| < RETRY_ON_ROW_CHANGE : "RETRY_ON_ROW_CHANGE" >
| < REWRITE : "REWRITE" >
| < STAR_TRANSFORMATION : "STAR_TRANSFORMATION" >
| < STATEMENT_QUEUING : "STATEMENT_QUEUING" >
| < UNNEST : "UNNEST" >
| < USE_CONCAT : "USE_CONCAT" >
| < USE_CUBE : "USE_CUBE" >
| < USE_HASH : "USE_HASH" >
| < USE_MERGE : "USE_MERGE" >
| < USE_NL : "USE_NL" >
| < USE_NL_WITH_INDEX : "USE_NL_WITH_INDEX" >
| < FOR : "FOR" >
| < SUBPARTITION : "SUBPARTITION" >
| < MULTISET : "MULTISET" >
| < EXCEPT : "EXCEPT" >
| < ROWNUM : "ROWNUM" >
| < CURRVAL : "CURRVAL" >
| < NEXTVAL : "NEXTVAL" >
| < PRIOR : "PRIOR" >
| < CURSOR : "CURSOR" >
| < AT : "AT" >
| < INDICATOR : "INDICATOR" >
| < NEW : "NEW" >
| < NAN : "NAN" >
| < INFINITE : "INFINITE" >
| < PRESENT : "PRESENT" >

| < EMPTY : "EMPTY" >
| < MEMBER : "MEMBER" >
| < OF : "OF" >
| < SUBMULTISET : "SUBMULTISET" >
| < LIKEC : "LIKEC" >
| < LIKE2 : "LIKE2" >
| < LIKE4 : "LIKE4" >
| < REGEXP_LIKE : "REGEXP_LIKE" >
| < EQUALS_PATH : "EQUALS_PATH" >
| < UNDER_PATH : "UNDER_PATH" >
| < JSON : "JSON" >
| < STRICT : "STRICT" >
| < LAX : "LAX" >
| < WITHOUT : "WITHOUT" >
| < UNIQUE : "UNIQUE" >
| < KEYS : "KEYS" >
| < JSON_EXISTS : "JSON_EXISTS" >
| < ERROR : "ERROR" >
| < TRUE : "TRUE" >
| < FALSE : "FALSE" >
| < JSON_TEXTCONTAINS : "JSON_TEXTCONTAINS" >
| < TYPE : "TYPE" >
| < ONLY : "ONLY" >
| < SIBLINGS : "SIBLINGS" >
| < NULLS : "NULLS" >
| < ROWS : "ROWS" >
| < RANGE : "RANGE" >
| < UNBOUNDED : "UNBOUNDED" >
| < PRECEDING : "PRECEDING" >
| < CURRENT : "CURRENT" >
| < ROW : "ROW" >
| < FOLLOWING : "FOLLOWING" >
| < APPENDCHILDXML : "APPENDCHILDXML" >
| < APPROX_COUNT_DISTINCT : "APPROX_COUNT_DISTINCT" >
| < ASIN : "ASIN" >
| < NCHAR_CS : "NCHAR_CS" >
| < CLUSTER_DETAILS : "CLUSTER_DETAILS" >
| < CLUSTER_DISTANCE : "CLUSTER_DISTANCE" >
| < CLUSTER_ID : "CLUSTER_ID" >
| < CLUSTER_PROBABILITY : "CLUSTER_PROBABILITY" >
| < CLUSTER_SET : "CLUSTER_SET" >
| < CON_DBID_TO_ID : "CON_DBID_TO_ID" >
| < CON_GUID_TO_ID : "CON_GUID_TO_ID" >
| < CON_NAME_TO_ID : "CON_NAME_TO_ID" >
| < CON_UID_TO_ID : "CON_UID_TO_ID" >
| < CORR_K : "CORR_K" >
| < CORR_S : "CORR_S" >
| < COEFFICIENT : "COEFFICIENT" >
| < ONE_SIDED_SIG : "ONE_SIDED_SIG" >
| < ONE_SIDED_SIG_POS : "ONE_SIDED_SIG_POS" >
| < ONE_SIDED_SIG_NEG : "ONE_SIDED_SIG_NEG" >
| < TWO_SIDED_SIG : "TWO_SIDED_SIG" >
| < CUBE_TABLE : "CUBE_TABLE" >
| < HIERARCHY : "HIERARCHY" >
| < HRR : "HRR" >
| < WITHIN : "WITHIN" >
| < DATAOBJ_TO_PARTITION : "DATAOBJ_TO_PARTITION" >
| < CANONICAL : "CANONICAL" >
| < COMPATIBILITY : "COMPATIBILITY" >
| < DELETEXML : "DELETEXML" >
| < EMPTY_BLOB : "EMPTY_BLOB" >
| < TIMEZONE_HOUR : "TIMEZONE_HOUR" >
| < TIMEZONE_MINUTE : "TIMEZONE_MINUTE" >
| < TIMEZONE_REGION : "TIMEZONE_REGION" >
| < TIMEZONE_ABBR : "TIMEZONE_ABBR" >
| < FEATURE_DETAILS : "FEATURE_DETAILS" >
| < FEATURE_ID : "FEATURE_ID" >
| < FEATURE_SET : "FEATURE_SET" >
| < FEATURE_VALUE : "FEATURE_VALUE" >
| < KEEP : "KEEP" >
| < FIRST_VALUE : "FIRST_VALUE" >
| < RESPECT : "RESPECT" >
| < IGNORE : "IGNORE" >
| < INSERTCHILDXML : "INSERTCHILDXML" >
| < INSERTCHILDXMLAFTER : "INSERTCHILDXMLAFTER" >
| < INSERTCHILDXMLBEFORE : "INSERTCHILDXMLBEFORE" >
| < INSERTXMLAFTER : "INSERTXMLAFTER" >
| < INSERTXMLBEFORE : "INSERTXMLBEFORE" >
| < INSTRB : "INSTRB" >
| < INSTRC : "INSTRC" >
| < INSTR2 : "INSTR2" >
| < INSTR4 : "INSTR4" >
| < JSON_QUERY : "JSON_QUERY" >
| < RETURNING : "RETURNING" >
| < PRETTY : "PRETTY" >
| < ARRAY : "ARRAY" >
| < WRAPPER : "WRAPPER" >
| < UNCONDITIONAL : "UNCONDITIONAL" >
| < CONDITIONAL : "CONDITIONAL" >
| < JSON_TABLE : "JSON_TABLE" >
| < RIFHT_ : "RIFHT_" >
| < COLUMNS : "COLUMNS" >
| < FORMAT : "FORMAT" >
| < NESTED : "NESTED" >
| < ORDINALITY : "ORDINALITY" >
| < JSON_VALUE : "JSON_VALUE" >
| < LAG : "LAG" >
| < LAST_VALUE : "LAST_VALUE" >
| < LEAD : "LEAD" >
| < LENGTHC : "LENGTHC" >
| < LENGTH2 : "LENGTH2" >
| < LENGTH4 : "LENGTH4" >
| < LISTAGG : "LISTAGG" >
| < NCHR : "NCHR" >
| < NTH_VALUE : "NTH_VALUE" >
| < ORA_DST_AFFECTED : "ORA_DST_AFFECTED" >
| < ORA_DST_CONVERT : "ORA_DST_CONVERT" >
| < ORA_DST_ERROR : "ORA_DST_ERROR" >
| < ORA_INVOKING_USER : "ORA_INVOKING_USER" >
| < ORA_INVOKING_USERID : "ORA_INVOKING_USERID" >
| < PREDICTION : "PREDICTION" >
| < COST : "COST" >
| < MODEL : "MODEL" >
| < PREDICTION_BOUNDS : "PREDICTION_BOUNDS" >
| < PREDICTION_COST : "PREDICTION_COST" >
| < PREDICTION_DETAILS : "PREDICTION_DETAILS" >
| < PREDICTION_PROBABILITY : "PREDICTION_PROBABILITY" >
| < PREDICTION_SET : "PREDICTION_SET" >
| < REGEXP_COUNT : "REGEXP_COUNT" >
| < REGR_SLOPE : "REGR_SLOPE" >
| < REGR_INTERCEPT : "REGR_INTERCEPT" >
| < REGR_COUNT : "REGR_COUNT" >
| < REGR_R2 : "REGR_R2" >
| < REGR_AVGX : "REGR_AVGX" >
| < REGR_AVGY : "REGR_AVGY" >
| < REGR_SXX : "REGR_SXX" >
| < REGR_SYY : "REGR_SYY" >
| < REGR_SXY : "REGR_SXY" >
| < ROW_NUMBER : "ROW_NUMBER" >
| < STANDARD_HASH : "STANDARD_HASH" >
| < TWO_SIDED_PROB : "TWO_SIDED_PROB" >
| < EXACT_PROB : "EXACT_PROB" >
| < ONE_SIDED_PROB_OR_MORE : "ONE_SIDED_PROB_OR_MORE" >
| < ONE_SIDED_PROB_OR_LESS : "ONE_SIDED_PROB_OR_LESS" >
| < CHISQ_OBS : "CHISQ_OBS" >
| < CHISQ_SIG : "CHISQ_SIG" >
| < CHISQ_DF : "CHISQ_DF" >
| < PHI_COEFFICIENT : "PHI_COEFFICIENT" >
| < CRAMERS_V : "CRAMERS_V" >
| < CONT_COEFFICIENT : "CONT_COEFFICIENT" >
| < COHENS_K : "COHENS_K" >
| < STATISTIC : "STATISTIC" >
| < DF_NUM : "DF_NUM" >
| < DF_DEN : "DF_DEN" >
| < SIG : "SIG" >
| < U_STATISTIC : "U_STATISTIC" >
| < SUM_SQUARES_BETWEEN : "SUM_SQUARES_BETWEEN" >
| < SUM_SQUARES_WITHIN : "SUM_SQUARES_WITHIN" >
| < DF_BETWEEN : "DF_BETWEEN" >
| < DF_WITHIN : "DF_WITHIN" >
| < MEAN_SQUARES_BETWEEN : "MEAN_SQUARES_BETWEEN" >
| < MEAN_SQUARES_WITHIN : "MEAN_SQUARES_WITHIN" >
| < F_RATIO : "F_RATIO" >
| < STATS_T_TEST_ONE : "STATS_T_TEST_ONE" >
| < STATS_T_TEST_PAIRED : "STATS_T_TEST_PAIRED" >
| < STATS_T_TEST_INDEP : "STATS_T_TEST_INDEP" >
| < STATS_T_TEST_INDEPU : "STATS_T_TEST_INDEPU" >
| < DF : "DF" >
| < SUBSTRC : "SUBSTRC" >
| < SUBSTR2 : "SUBSTR2" >
| < SUBSTR4 : "SUBSTR4" >
| < SYS_OP_ZONE_ID : "SYS_OP_ZONE_ID" >
| < TO_BLOB : "TO_BLOB" >
| < P : "P" >
| < D : "D" >
| < T : "T" >
| < H : "H" >
| < M : "M" >
| < S : "S" >
| < Y : "Y" >
| < CHAR_CS : "CHAR_CS" >
| < TRAILING : "TRAILING" >
| < BOTH : "BOTH" >
| < DBTMEZONE : "DBTMEZONE" >
| < XMLCAST : "XMLCAST" >
| < XMLCDATA : "XMLCDATA" >
| < EVALNAME : "EVALNAME" >
| < XMLCOMMENT : "XMLCOMMENT" >
| < XMLDIFF : "XMLDIFF" >
| < XMLELEMENT : "XMLELEMENT" >
| < ENTITYESCAPING : "ENTITYESCAPING" >
| < NOENTITYESCAPING : "NOENTITYESCAPING" >
| < NAME : "NAME" >
| < XMLATTRIBUTES : "XMLATTRIBUTES" >
| < SCHEMACHECK : "SCHEMACHECK" >
| < NOSCHEMACHECK : "NOSCHEMACHECK" >
| < XMLEXISTS : "XMLEXISTS" >
| < PASSING : "PASSING" >
| < XMLISVALID : "XMLISVALID" >
| < XMLPARSE : "XMLPARSE" >
| < DOCUMENT : "DOCUMENT" >
| < CONTENT : "CONTENT" >
| < WELLFORMED : "WELLFORMED" >
| < XMLPATCH : "XMLPATCH" >
| < XMLPI : "XMLPI" >
| < XMLQUERY : "XMLQUERY" >
| < XMLROOT : "XMLROOT" >
| < VERSION : "VERSION" >
| < NO : "NO" >
| < STANDALONE : "STANDALONE" >
| < YES : "YES" >
| < XMLSERIALIZE : "XMLSERIALIZE" >
| < ENCODING : "ENCODING" >
| < INDENT : "INDENT" >
| < SIZE : "SIZE" >
| < HIDE : "HIDE" >
| < SHOW : "SHOW" >
| < DEFAULTS : "DEFAULTS" >
| < XMLTABLE : "XMLTABLE" >
| < XMLNAMESPACES : "XMLNAMESPACES" >
| < SEQUENCE : "SEQUENCE" >
| < XMLTYPE : "XMLTYPE" >
| < ALLOCATE : "ALLOCATE" >
| < EXTENT : "EXTENT" >
| < DATAFILE : "DATAFILE" >
| < INSTANCE : "INSTANCE" >
| < CONSTRAINT : "CONSTRAINT" >
| < CHECK : "CHECK" >
| < FOREIGN : "FOREIGN" >
| < SCOPE : "SCOPE" >
| < REFERENCES : "REFERENCES" >
| < CASCADE : "CASCADE" >
| < DEFERRABLE : "DEFERRABLE" >
| < INITIALLY : "INITIALLY" >
| < IMMEDIATE : "IMMEDIATE" >
| < DEFERRED : "DEFERRED" >
| < RELY : "RELY" >
| < NORELY : "NORELY" >
| < ENABLE : "ENABLE" >
| < DISABLE : "DISABLE" >
| < VALIDATE : "VALIDATE" >
| < NOVALIDATE : "NOVALIDATE" >
| < INDEXTYPE : "INDEXTYPE" >
| < ONLINE : "ONLINE" >
| < TABLESPACE : "TABLESPACE" >
| < SORT : "SORT" >
| < NOSORT : "NOSORT" >
| < REVERSE : "REVERSE" >
| < VISIBLE : "VISIBLE" >
| < INVISIBLE : "INVISIBLE" >
| < EXCEPTIONS : "EXCEPTIONS" >
| < DEALLOCATE : "DEALLOCATE" >
| < UNUSED : "UNUSED" >
| < REUSE : "REUSE" >
| < BLOCKSIZE : "BLOCKSIZE" >
| < AUTOEXTEND : "AUTOEXTEND" >
| < OFF : "OFF" >
| < NEXT : "NEXT" >
| < MAXSIZE : "MAXSIZE" >
| < UNLIMITED : "UNLIMITED" >
| < LOGGING : "LOGGING" >
| < NOLOGGING : "NOLOGGING" >
| < FILESYSTEM_LIKE_LOGGING : "FILESYSTEM_LIKE_LOGGING" >
| < NOPARALLEL : "NOPARALLEL" >
| < PCTFREE : "PCTFREE" >
| < PCTUSED : "PCTUSED" >
| < INITRANS : "INITRANS" >
| < K : "K" >
| < G : "G" >
| < E : "E" >
| < STORAGE : "STORAGE" >
| < INITIAL : "INITIAL" >
| < MINEXTENTS : "MINEXTENTS" >
| < MAXEXTENTS : "MAXEXTENTS" >
| < PCTINCREASE : "PCTINCREASE" >
| < FREELISTS : "FREELISTS" >
| < FREELIST : "FREELIST" >
| < GROUPS : "GROUPS" >
| < OPTIMAL : "OPTIMAL" >
| < BUFFER_POOL : "BUFFER_POOL" >
| < RECYCLE : "RECYCLE" >
| < FLASH_CACHE : "FLASH_CACHE" >
| < ENCRYPT : "ENCRYPT" >
| < MINUS : "MINUS" >
| < CONNECT : "CONNECT" >
| < NOCYCLE : "NOCYCLE" >
| < START : "START" >
| < ADMINISTER : "ADMINISTER" >
| < MANAGEMENT : "MANAGEMENT" >
| < KEYSTORE : "KEYSTORE" >
| < AUTO_ : "AUTO_" >
| < LOGIN : "LOGIN" >
| < IDENTIFIED : "IDENTIFIED" >
| < CONTAINER : "CONTAINER" >
| < CLOSE : "CLOSE" >
| < BACKUP : "BACKUP" >
| < ALTER : "ALTER" >
| < PASSWORD : "PASSWORD" >
| < EXISTING : "EXISTING" >
| < ENCRYPTION : "ENCRYPTION" >
| < TAG : "TAG" >
| < USE : "USE" >
| < EXPORT : "EXPORT" >
| < SECRET : "SECRET" >
| < IDENTIFIER : "IDENTIFIER" >
| < IMPORT : "IMPORT" >
| < MIGRATE : "MIGRATE" >
| < ADD : "ADD" >
| < CLIENT : "CLIENT" >
| < AUDIT : "AUDIT" >
| < POLICY : "POLICY" >
| < CONDITION : "CONDITION" >
| < EVALUATE : "EVALUATE" >
| < PER : "PER" >
| < STATEMENT : "STATEMENT" >
| < SESSION : "SESSION" >
| < PRIVILEGES : "PRIVILEGES" >
| < ACTIONS : "ACTIONS" >
| < DIRECTORY : "DIRECTORY" >
| < MINING : "MINING" >
| < COMPONENT : "COMPONENT" >
| < DATAPUMP : "DATAPUMP" >
| < DIRECT_LOAD : "DIRECT_LOAD" >
| < OLS : "OLS" >
| < XS : "XS" >
| < DV : "DV" >
| < ROLES : "ROLES" >
| < MODIFY : "MODIFY" >
| < DATABASE : "DATABASE" >
| < MOUNT : "MOUNT" >
| < STANDBY : "STANDBY" >
| < CLONE : "CLONE" >
| < READ : "READ" >
| < WRITE : "WRITE" >
| < RESETLOGS : "RESETLOGS" >
| < NORESETLOGS : "NORESETLOGS" >
| < UPGRADE : "UPGRADE" >
| < DOWNGRADE : "DOWNGRADE" >
| < RECOVER : "RECOVER" >
| < AUTOMATIC : "AUTOMATIC" >
| < LOGFILE : "LOGFILE" >
| < TEST : "TEST" >
| < ALLOW : "ALLOW" >
| < CORRUPTION : "CORRUPTION" >
| < CONTINUE : "CONTINUE" >
| < CANCEL : "CANCEL" >
| < UNTIL : "UNTIL" >
| < CHANGE : "CHANGE" >
| < CONSISTENT : "CONSISTENT" >
| < CONTROLFILE : "CONTROLFILE" >
| < SNAPSHOT : "SNAPSHOT" >
| < MANAGED : "MANAGED" >
| < ARCHIVED : "ARCHIVED" >
| < DISCONNECT : "DISCONNECT" >
| < NODELAY : "NODELAY" >
| < FINISH : "FINISH" >
| < LOGICAL : "LOGICAL" >
| < IDENTITY : "IDENTITY" >
| < RENAME : "RENAME" >
| < FILE : "FILE" >
| < OFFLINE : "OFFLINE" >
| < RESIZE : "RESIZE" >
| < TEMPFILE : "TEMPFILE" >
| < INCLUDING : "INCLUDING" >
| < DATAFILES : "DATAFILES" >
| < MOVE : "MOVE" >
| < ARCHIVELOG : "ARCHIVELOG" >
| < NOARCHIVELOG : "NOARCHIVELOG" >
| < FORCE : "FORCE" >
| < CLEAR : "CLEAR" >
| < UNARCHIVED : "UNARCHIVED" >
| < UNRECOVERABLE : "UNRECOVERABLE" >
| < THREAD : "THREAD" >
| < SWITCH : "SWITCH" >
| < LOGFILES : "LOGFILES" >
| < SUPPLEMENTAL : "SUPPLEMENTAL" >
| < DATA : "DATA" >
| < PROCEDURAL : "PROCEDURAL" >
| < REPLICATION : "REPLICATION" >
| < PHYSICAL : "PHYSICAL" >
| < FAR : "FAR" >
| < SYNC : "SYNC" >
| < TRACE : "TRACE" >
| < ACTIVATE : "ACTIVATE" >
| < APPLY : "APPLY" >
| < MAXIMIZE : "MAXIMIZE" >
| < PROTECTION : "PROTECTION" >
| < AVAILABILITY : "AVAILABILITY" >
| < PERFORMANCE : "PERFORMANCE" >
| < REGISTER : "REGISTER" >
| < SWITCHOVER : "SWITCHOVER" >
| < VERIFY : "VERIFY" >
| < FAILOVER : "FAILOVER" >
| < PREPARE : "PREPARE" >
| < COMMIT : "COMMIT" >
| < SHUTDOWN : "SHUTDOWN" >
| < WAIT : "WAIT" >
| < NOWAIT : "NOWAIT" >
| < SQL_SKIP : "SQL_SKIP" >
| < FAILED : "FAILED" >
| < TRANSACTION : "TRANSACTION" >
| < STOP : "STOP" >
| < ABORT : "ABORT" >
| < EDITION : "EDITION" >
| < BIGFILE : "BIGFILE" >
| < SMALLFILE : "SMALLFILE" >
| < TEMPORARY : "TEMPORARY" >
| < GLOBAL_NAME : "GLOBAL_NAME" >
| < BLOCK : "BLOCK" >
| < TRACKING : "TRACKING" >
| < CACHING : "CACHING" >
| < TIME_ZONE : "TIME_ZONE" >
| < FLASHBACK : "FLASHBACK" >
| < GUARD : "GUARD" >
| < LINK : "LINK" >
| < AUTHENTICATED : "AUTHENTICATED" >
| < DIMENSION : "DIMENSION" >
| < LEVEL : "LEVEL" >
| < RESTRICT : "RESTRICT" >
| < ATTRIBUTE : "ATTRIBUTE" >
| < COLUMN : "COLUMN" >
| < COMPILE : "COMPILE" >
| < CHILD : "CHILD" >
| < DETERMINES : "DETERMINES" >
| < DISKGROUP : "DISKGROUP" >
| < QUORUM : "QUORUM" >
| < REGULAR : "REGULAR" >
| < FAILGROUP : "FAILGROUP" >
| < DISK : "DISK" >
| < NOFORCE : "NOFORCE" >
| < DISKS : "DISKS" >
| < AFTER : "AFTER" >
| < UNDROP : "UNDROP" >
| < REBALANCE : "REBALANCE" >
| < REPAIR : "REPAIR" >
| < NOREPAIR : "NOREPAIR" >
| < TEMPLATE : "TEMPLATE" >
| < MIRROR : "MIRROR" >
| < HIGH : "HIGH" >
| < UNPROTECTED : "UNPROTECTED" >
| < FINE : "FINE" >
| < COARSE : "COARSE" >
| < HOT : "HOT" >
| < COLD : "COLD" >
| < MIRRORHOT : "MIRRORHOT" >
| < MIRRORCOLD : "MIRRORCOLD" >
| < ALIAS : "ALIAS" >
| < VOLUME : "VOLUME" >
| < STRIPE_WIDTH : "STRIPE_WIDTH" >
| < STRIPE_COLUMNS : "STRIPE_COLUMNS" >
| < MOUNTPATH : "MOUNTPATH" >
| < USAGE : "USAGE" >
| < USERGROUP : "USERGROUP" >
| < PERMISSION : "PERMISSION" >
| < OWNER : "OWNER" >
| < OTHER : "OTHER" >
| < OWNERSHIP : "OWNERSHIP" >
| < SCRUB : "SCRUB" >
| < LOW : "LOW" >
| < RESTRICTED : "RESTRICTED" >
| < NORMAL : "NORMAL" >
| < DISMOUNT : "DISMOUNT" >
| < ARCHIVE : "ARCHIVE" >
| < REMOVE : "REMOVE" >
| < RETENTION : "RETENTION" >
| < PURGE : "PURGE" >
| < BEFORE : "BEFORE" >
| < SCN : "SCN" >
| < OPTIMIZE : "OPTIMIZE" >
| < QUOTA : "QUOTA" >
| < FUNCTION : "FUNCTION" >
| < EDITIONABLE : "EDITIONABLE" >
| < NONEDITIONABLE : "NONEDITIONABLE" >
| < PARAMETERS : "PARAMETERS" >
| < UNUSABLE : "UNUSABLE" >
| < CLEANUP : "CLEANUP" >
| < MONITORING : "MONITORING" >
| < NOMONITORING : "NOMONITORING" >
| < SHRINK : "SHRINK" >
| < SPACE : "SPACE" >
| < COMPACT : "COMPACT" >
| < INDEXING : "INDEXING" >
| < PARTIAL : "PARTIAL" >
| < REBUILD : "REBUILD" >
| < NOREVERSE : "NOREVERSE" >
| < COMPRESS : "COMPRESS" >
| < NOCOMPRESS : "NOCOMPRESS" >
| < ADVANCED : "ADVANCED" >
| < ATTRIBUTES : "ATTRIBUTES" >
| < SPLIT : "SPLIT" >
| < USABLE : "USABLE" >
| < DML : "DML" >
| < SYSTEM : "SYSTEM" >
| < TABLES : "TABLES" >
| < JAVA : "JAVA" >
| < SOURCE : "SOURCE" >
| < CLASS : "CLASS" >
| < RESOLVER : "RESOLVER" >
| < RESOLVE : "RESOLVE" >
| < AUTHID : "AUTHID" >
| < CURRENT_USER : "CURRENT_USER" >
| < DEFINER : "DEFINER" >
| < LIBRARY : "LIBRARY" >
| < MATERIALIZED : "MATERIALIZED" >
| < VIEW : "VIEW" >
| < CONSIDER : "CONSIDER" >
| < FRESH : "FRESH" >
| < DECRYPT : "DECRYPT" >
| < STORE : "STORE" >
| < BASIC : "BASIC" >
| < QUERY : "QUERY" >
| < LOCKING : "LOCKING" >
| < MEMCOMPRESS : "MEMCOMPRESS" >
| < CAPACITY : "CAPACITY" >
| < PRIORITY : "PRIORITY" >
| < MEDIUM : "MEDIUM" >
| < CRITICAL : "CRITICAL" >
| < DISTRIBUTE : "DISTRIBUTE" >
| < DUPLICATE : "DUPLICATE" >
| < LOB : "LOB" >
| < SECUREFILE : "SECUREFILE" >
| < BASICFILE : "BASICFILE" >
| < CHUNK : "CHUNK" >
| < PCTVERSION : "PCTVERSION" >
| < FREEPOOLS : "FREEPOOLS" >
| < READS : "READS" >
| < PCTTHRESHOLD : "PCTTHRESHOLD" >
| < OVERFLOW : "OVERFLOW" >
| < REFRESH : "REFRESH" >
| < FAST : "FAST" >
| < COMPLETE : "COMPLETE" >
| < DEMAND : "DEMAND" >
| < MASTER : "MASTER" >
| < ROLLBACK : "ROLLBACK" >
| < SEGMENT : "SEGMENT" >
| < ENFORCED : "ENFORCED" >
| < TRUSTED : "TRUSTED" >
| < CONSTRAINTS : "CONSTRAINTS" >
| < BEGINNING : "BEGINNING" >
| < OBJECT : "OBJECT" >
| < ID : "ID" >
| < EXCLUDING : "EXCLUDING" >
| < SYNCHRONOUS : "SYNCHRONOUS" >
| < ASYNCHRONOUS : "ASYNCHRONOUS" >
| < REPEAT : "REPEAT" >
| < ZONEMAP : "ZONEMAP" >
| < PRUNING : "PRUNING" >
| < LOAD : "LOAD" >
| < MOVEMENT : "MOVEMENT" >
| < OPERATOR : "OPERATOR" >
| < BINDING : "BINDING" >
| < RETURN : "RETURN" >
| < ANCILLARY : "ANCILLARY" >
| < CONTEXT : "CONTEXT" >
| < COMPUTE : "COMPUTE" >
| < OUTLINE : "OUTLINE" >
| < PUBLIC : "PUBLIC" >
| < PRIVATE : "PRIVATE" >
| < CATEGORY : "CATEGORY" >
| < PACKAGE : "PACKAGE" >
| < PLUGGABLE : "PLUGGABLE" >
| < UNPLUG : "UNPLUG" >
| < MAX_SHARED_TEMP_SIZE : "MAX_SHARED_TEMP_SIZE" >
| < RECOVERY : "RECOVERY" >
| < INSTANCES : "INSTANCES" >
| < RELOCATE : "RELOCATE" >
| < NORELOCATE : "NORELOCATE" >
| < SAVE : "SAVE" >
| < DISCARD : "DISCARD" >
| < STATE : "STATE" >
| < PROCEDURE : "PROCEDURE" >
| < PROFILE : "PROFILE" >
| < SESSIONS_PER_USER : "SESSIONS_PER_USER" >
| < CPU_PER_SESSION : "CPU_PER_SESSION" >
| < CPU_PER_CALL : "CPU_PER_CALL" >
| < CONNECT_TIME : "CONNECT_TIME" >
| < IDLE_TIME : "IDLE_TIME" >
| < LOGICAL_READS_PER_SESSION : "LOGICAL_READS_PER_SESSION" >
| < LOGICAL_READS_PER_CALL : "LOGICAL_READS_PER_CALL" >
| < COMPOSITE_LIMIT : "COMPOSITE_LIMIT" >
| < PRIVATE_SGA : "PRIVATE_SGA" >
| < FAILED_LOGIN_ATTEMPTS : "FAILED_LOGIN_ATTEMPTS" >
| < PASSWORD_LIFE_TIME : "PASSWORD_LIFE_TIME" >
| < PASSWORD_REUSE_TIME : "PASSWORD_REUSE_TIME" >
| < PASSWORD_REUSE_MAX : "PASSWORD_REUSE_MAX" >
| < PASSWORD_LOCK_TIME : "PASSWORD_LOCK_TIME" >
| < PASSWORD_GRACE_TIME : "PASSWORD_GRACE_TIME" >
| < PASSWORD_VERIFY_FUNCTION : "PASSWORD_VERIFY_FUNCTION" >
| < RESOURCE : "RESOURCE" >
| < ROLE : "ROLE" >
| < EXTERNALLY : "EXTERNALLY" >
| < GLOBALLY : "GLOBALLY" >
| < INCREMENT : "INCREMENT" >
| < MAXVALUE : "MAXVALUE" >
| < NOMAXVALUE : "NOMAXVALUE" >
| < MINVALUE : "MINVALUE" >
| < NOMINVALUE : "NOMINVALUE" >
| < CYCLE : "CYCLE" >
| < NOORDER : "NOORDER" >
| < NOKEEP : "NOKEEP" >
| < GLOBAL : "GLOBAL" >
| < ADVISE : "ADVISE" >
| < NOTHING : "NOTHING" >
| < DDL : "DDL" >
| < RESUMABLE : "RESUMABLE" >
| < TIMEOUT : "TIMEOUT" >
| < ARCHIVAL : "ARCHIVAL" >
| < VISIBILITY : "VISIBILITY" >
| < ACTIVE : "ACTIVE" >
| < SYNONYM : "SYNONYM" >
| < FLUSH : "FLUSH" >
| < SHARED_POOL : "SHARED_POOL" >
| < BUFFER_CACHE : "BUFFER_CACHE" >
| < REDO : "REDO" >
| < CONFIRM : "CONFIRM" >
| < SUSPEND : "SUSPEND" >
| < RESUME : "RESUME" >
| < RESET : "RESET" >
| < NOSWITCH : "NOSWITCH" >
| < CHECKPOINT : "CHECKPOINT" >
| < DISTRIBUTED : "DISTRIBUTED" >
| < POST_TRANSACTION : "POST_TRANSACTION" >
| < KILL : "KILL" >
| < NOREPLAY : "NOREPLAY" >
| < QUIESCE : "QUIESCE" >
| < UNQUIESCE : "UNQUIESCE" >
| < ROLLING : "ROLLING" >
| < MIGRATION : "MIGRATION" >
| < PATCH : "PATCH" >
| < WALLET : "WALLET" >
| < USE_STORED_OUTLINES : "USE_STORED_OUTLINES" >
| < GLOBAL_TOPIC_ENABLED : "GLOBAL_TOPIC_ENABLED" >
| < COMMENT : "COMMENT" >
| < MEMORY : "MEMORY" >
| < SPFILE : "SPFILE" >
| < SID : "SID" >
| < LOCK : "LOCK" >
| < TRIGGERS : "TRIGGERS" >
| < MODE : "MODE" >
| < REKEY : "REKEY" >
| < ILM : "ILM" >
| < DELETE_ALL : "DELETE_ALL" >
| < ENABLE_ALL : "ENABLE_ALL" >
| < DISABLE_ALL : "DISABLE_ALL" >
| < DAYS : "DAYS" >
| < MONTHS : "MONTHS" >
| < YEARS : "YEARS" >
| < ACCESS : "ACCESS" >
| < MODIFICATION : "MODIFICATION" >
| < CREATION : "CREATION" >
| < TIER : "TIER" >
| < ALWAYS : "ALWAYS" >
| < MINIMIZE : "MINIMIZE" >
| < NOMINIMIZE : "NOMINIMIZE" >
| < RECORDS_PER_BLOCK : "RECORDS_PER_BLOCK" >
| < MAPPING : "MAPPING" >
| < NOMAPPING : "NOMAPPING" >
| < LINEAR : "LINEAR" >
| < INTERLEAVED : "INTERLEAVED" >
| < GENERATED : "GENERATED" >
| < VIRTUAL : "VIRTUAL" >
| < SALT : "SALT" >
| < SUBSTITUTABLE : "SUBSTITUTABLE" >
| < LEVELS : "LEVELS" >
| < INVALIDATE : "INVALIDATE" >
| < PERIOD : "PERIOD" >
| < LOCATOR : "LOCATOR" >
| < ELEMENT : "ELEMENT" >
| < COLUMN_VALUE : "COLUMN_VALUE" >
| < ORGANIZATION : "ORGANIZATION" >
| < HEAP : "HEAP" >
| < EXTERNAL : "EXTERNAL" >
| < VARRAY : "VARRAY" >
| < DEDUPLICATE : "DEDUPLICATE" >
| < KEEP_DUPLICATES : "KEEP_DUPLICATES" >
| < RELATIONAL : "RELATIONAL" >
| < BINARY : "BINARY" >
| < XML : "XML" >
| < VARRAYS : "VARRAYS" >
| < LOBS : "LOBS" >
| < XMLSCHEMA : "XMLSCHEMA" >
| < DISALLOW : "DISALLOW" >
| < NONSCHEMA : "NONSCHEMA" >
| < ANYSCHEMA : "ANYSCHEMA" >
| < REJECT : "REJECT" >
| < PROJECT : "PROJECT" >
| < REFERENCED : "REFERENCED" >
| < LOCATION : "LOCATION" >
| < INDEXES : "INDEXES" >
| < DEPENDENT : "DEPENDENT" >
| < PARTITIONS : "PARTITIONS" >
| < SUBPARTITIONS : "SUBPARTITIONS" >
| < column : "column" >
| < EXCHANGE : "EXCHANGE" >
| < VALIDATION : "VALIDATION" >
| < LESS : "LESS" >
| < THAN : "THAN" >
| < OPAQUE : "OPAQUE" >
| < UNPACKED : "UNPACKED" >
| < MINIMUM : "MINIMUM" >
| < PERMANENT : "PERMANENT" >
| < GUARANTEE : "GUARANTEE" >
| < NOGUARANTEE : "NOGUARANTEE" >
| < TRIGGER : "TRIGGER" >
| < EXPIRE : "EXPIRE" >
| < ACCOUNT : "ACCOUNT" >
| < UNLOCK : "UNLOCK" >
| < EDITIONS : "EDITIONS" >
| < GRANT : "GRANT" >
| < THROUGH : "THROUGH" >
| < ENTERPRISE : "ENTERPRISE" >
| < USERS : "USERS" >
| < REVOKE : "REVOKE" >
| < AUTHENTICATION : "AUTHENTICATION" >
| < REQUIRED : "REQUIRED" >
| < CONTAINER_DATA : "CONTAINER_DATA" >
| < ANALYZE : "ANALYZE" >
| < LIST : "LIST" >
| < CHAINED : "CHAINED" >
| < STATISTICS : "STATISTICS" >
| < DANGLING : "DANGLING" >
| < STRUCTURE : "STRUCTURE" >
| < ASSOCIATE : "ASSOCIATE" >
| < FUNCTIONS : "FUNCTIONS" >
| < PACKAGES : "PACKAGES" >
| < TYPES : "TYPES" >
| < INDEXTYPES : "INDEXTYPES" >
| < SELECTIVITY : "SELECTIVITY" >
| < NETWORK : "NETWORK" >
| < DIRECT_PATH : "DIRECT_PATH" >
| < WHENEVER : "WHENEVER" >
| < SUCCESSFUL : "SUCCESSFUL" >
| < STATEMENTS : "STATEMENTS" >
| < SQL : "SQL" >
| < TRANSLATION : "TRANSLATION" >
| < NAMESPACE : "NAMESPACE" >
| < CALL : "CALL" >
| < WORK : "WORK" >
| < BATCH : "BATCH" >
| < CORRUPT_XID : "CORRUPT_XID" >
| < CORRUPT_XID_ALL : "CORRUPT_XID_ALL" >
| < SINGLE : "SINGLE" >
| < HASHKEYS : "HASHKEYS" >
| < NOROWDEPENDENCIES : "NOROWDEPENDENCIES" >
| < ROWDEPENDENCIES : "ROWDEPENDENCIES" >
| < INITIALIZED : "INITIALIZED" >
| < ACCESSED : "ACCESSED" >
| < MAXLOGFILES : "MAXLOGFILES" >
| < MAXLOGMEMBERS : "MAXLOGMEMBERS" >
| < MAXLOGHISTORY : "MAXLOGHISTORY" >
| < MAXDATAFILES : "MAXDATAFILES" >
| < MAXINSTANCES : "MAXINSTANCES" >
| < SYS : "SYS" >
| < USER_DATA : "USER_DATA" >
| < SYSAUX : "SYSAUX" >
| < AUTOALLOCATE : "AUTOALLOCATE" >
| < UNIFORM : "UNIFORM" >
| < UNDO : "UNDO" >
| < SEED : "SEED" >
| < FILE_NAME_CONVERT : "FILE_NAME_CONVERT" >
| < SHARED : "SHARED" >
| < REDUNDANCY : "REDUNDANCY" >
| < BITMAP : "BITMAP" >
| < XDB : "XDB" >
| < XMLINDEX : "XMLINDEX" >
| < NAMED : "NAMED" >
| < SCHEMA : "SCHEMA" >
| < PREBUILT : "PREBUILT" >
| < REDUCED : "REDUCED" >
| < NEVER : "NEVER" >
| < BUILD : "BUILD" >
| < SCALE : "SCALE" >
| < BODY : "BODY" >
| < PFILE : "PFILE" >
| < ADMIN : "ADMIN" >
| < PATH_PREFIX : "PATH_PREFIX" >
| < USER_TABLESPACES : "USER_TABLESPACES" >
| < STANDBYS : "STANDBYS" >
| < CREATE_FILE_DEST : "CREATE_FILE_DEST" >
| < NON$CDB : "NON$CDB" >
| < COPY : "COPY" >
| < NOCOPY : "NOCOPY" >
| < SOURCE_FILE_NAME_CONVERT : "SOURCE_FILE_NAME_CONVERT" >
| < RESTORE : "RESTORE" >
| < POINT : "POINT" >
| < PRESERVE : "PRESERVE" >
| < AUTHORIZATION : "AUTHORIZATION" >
| < OIDINDEX : "OIDINDEX" >
| < REFERENCE : "REFERENCE" >
| < EDITIONING : "EDITIONING" >
| < BEQUEATH : "BEQUEATH" >
| < UNDER : "UNDER" >
| < OPTION : "OPTION" >
| < ERRORS : "ERRORS" >
| < DISASSOCIATE : "DISASSOCIATE" >
| < CONTENTS : "CONTENTS" >
| < EXPLAIN : "EXPLAIN" >
| < PLAN : "PLAN" >
| < STATEMENT_ID : "STATEMENT_ID" >
| < DELEGATE : "DELEGATE" >
| < MATCHED : "MATCHED" >
| < NOAUDIT : "NOAUDIT" >
| < RECYCLEBIN : "RECYCLEBIN" >
| < DBA_RECYCLEBIN : "DBA_RECYCLEBIN" >
| < SAVEPOINT : "SAVEPOINT" >
| < SEARCH : "SEARCH" >
| < BREADTH : "BREADTH" >
| < VERSIONS : "VERSIONS" >
| < LATERAL : "LATERAL" >
| < PIVOT : "PIVOT" >
| < UNPIVOT : "UNPIVOT" >
| < INCLUDE : "INCLUDE" >
| < EXCLUDE : "EXCLUDE" >
| < SAMPLE : "SAMPLE" >
| < CONTAINERS : "CONTAINERS" >
| < CROSS : "CROSS" >
| < ROLLUP : "ROLLUP" >
| < CUBE : "CUBE" >
| < SETS : "SETS" >
| < NAV : "NAV" >
| < UPDATED : "UPDATED" >
| < MAIN : "MAIN" >
| < MEASURES : "MEASURES" >
| < RULES : "RULES" >
| < UPSERT : "UPSERT" >
| < SEQUENTIAL : "SEQUENTIAL" >
| < ITERATE : "ITERATE" >
| < DECREMENT : "DECREMENT" >
| < FETCH : "FETCH" >
| < PERCENT : "PERCENT" >
| < TIES : "TIES" >
| < LOCKED : "LOCKED" >
| < MATCH_RECOGNIZE : "MATCH_RECOGNIZE" >
| < PATTERN : "PATTERN" >
| < DEFINE : "DEFINE" >
| < ONE : "ONE" >
| < MATCH : "MATCH" >
| < PAST : "PAST" >
| < PERMUTE : "PERMUTE" >
| < SUBSET : "SUBSET" >
| < CLASSIFIER : "CLASSIFIER" >
| < MATCH_NUMBER : "MATCH_NUMBER" >
| < RUNNING : "RUNNING" >
| < FINAL : "FINAL" >
| < PREV : "PREV" >
| < ISOLATION : "ISOLATION" >
| < SERIALIZABLE : "SERIALIZABLE" >
| < COMMITTED : "COMMITTED" >
}


<SQL_STATE> TOKEN : 
{
  < SQL_DOUBLE :
    (
      (< SQL_INTEGER >)? <SQL_PERIOD_CHAR> < SQL_INTEGER >
      (
        [ "e", "E" ] ([ "-", "+" ])? < SQL_INTEGER >
      )?
    | (< SQL_INTEGER >)+ (<SQL_PERIOD_CHAR>)? [ "e", "E" ] ([ "-", "+" ])? (< SQL_INTEGER >)+
    ) >
| < SQL_INTEGER : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}

<SQL_STATE> SPECIAL_TOKEN :
{
  < MULTI_LINE_COMMENT :
    "/*" (~[ "*" ])* "*"
    (
      "*"
    |
      (
        ~[ "*", "/" ] (~[ "*" ])* "*"
      )
    )*
    "/" >
| < LINE_COMMENT : "--" (~[ "\r", "\n" ])* >    
}

<SQL_STATE> TOKEN :
{
  < SQL_IDENTIFIER :
    (< LETTER >)+
    (
      < DIGIT >
    | < LETTER >
    | < SPECIAL_CHARS >
    )* >
| < SQL_CHAR_LITERAL :
    "'" (~[ "'" ])* "'"
    (
      "'" (~[ "'" ])* "'"
    )* >
| < SQL_QUOTED_IDENTIFIER :
    "\"" (~[ "\n", "\r", "\"" ])* "\"" >
| < #LETTER : [ "a"-"z", "A"-"Z", "_","\uac00"-"\ud7ff"] >
| < #SPECIAL_CHARS :
    "_"
  | "$"
  | "->"
 >
}

<SQL_STATE> TOKEN :
{
  < SQL_COMMA_CHAR : "," >
  | < SQL_PERIOD_CHAR : "." >
}





void datatypes() : 
{}
{

( Oracle_built_in_datatypes()
| ansi_supported_datatypes()
| user_defined_types()
| oracle_supplied_types()
)
}
void Oracle_built_in_datatypes() : 
{}
{

( character_datatypes()
| number_datatypes()
| long_and_raw_datatypes()
| datetime_datatypes()
| large_object_datatypes()
| rowid_datatypes()
)
}

void size() :
{
}
{
  < SQL_INTEGER >
}

void character_datatypes() : 
{}
{

( < CHAR > [ (size() [ < BYTE > | < CHAR > ]) ]
| < VARCHAR2 > (size() [ < BYTE > | < CHAR > ])
| < NCHAR > [ (size()) ]
| < NVARCHAR2 > (size())
)
}

void precision() :
{
}
{
  "precision"
}

void number_datatypes() : 
{}
{

( < NUMBER > [ (precision() [< SQL_COMMA_CHAR > scale() ]) ]
| < FLOAT > [ (precision()) ]
| < BINARY_FLOAT >
| < BINARY_DOUBLE >
)
}
void long_and_raw_datatypes() : 
{}
{
( < LONG> [ < RAW> ] | < RAW > <SQL_LPARENCHAR> size() <SQL_RPARENCHAR> )
}

void fractional_seconds_precision() :
{
}
{
  "fractional_seconds_precision"
}

void year_precision() :
{
}
{
  "year_precision"
}

void day_precision() :
{
}
{
  "day_precision"
}

void datetime_datatypes() : 
{}
{

( < DATE >
| < TIMESTAMP > [ <SQL_LPARENCHAR> fractional_seconds_precision() <SQL_RPARENCHAR> ]
     [ < SQL_WITH > [ < LOCAL > ] < TIME> < ZONE>]
| < INTERVAL>
(
 < YEAR>[ <SQL_LPARENCHAR> year_precision() <SQL_RPARENCHAR> ] < TO> < MONTH>
| < DAY>[ <SQL_LPARENCHAR> day_precision() <SQL_RPARENCHAR> ] < TO> < SECOND>[ <SQL_LPARENCHAR>fractional_seconds_precision() <SQL_RPARENCHAR> ] 
)
  
)
}
void large_object_datatypes() : 
{}
{

( < BLOB > | < CLOB > | < NCLOB > | < BFILE > )
}
void rowid_datatypes() : 
{}
{

( < ROWID > | < UROWID > [ (size()) ] )
}


void scale() :
{}
{
	"scale"
}

void ansi_supported_datatypes() : 
{}
{

( < CHARACTER > [< VARYING >] (size())
| ( < CHAR > | < NCHAR > ) < VARYING > (size())
| < VARCHAR > (size())
| < NATIONAL > ( < CHARACTER > | < CHAR > )
     [< VARYING >] (size())
| ( < NUMERIC > | < DECIMAL > | < DEC > )
     [ (precision() [< SQL_COMMA_CHAR > scale() ]) ]
| ( < INTEGER > | < INT > | < SMALLINT > )
| < FLOAT > [ (size()) ]
| < DOUBLE> < PRECISION>| < REAL >
)
}
void oracle_supplied_types() : 
{}
{

( any_types()
| xml_types()
| spatial_types()
| media_types()
)
}
void any_types() : 
{}
{
/*TODO
( < SYS_AnyData > | < SYS_AnyType > | < SYS_AnyDataSet > )
*/
"any_types"
}
void xml_types() : 
{}
{

( < XMLType > | < URIType > )
}
void spatial_types() : 
{}
{

( < SDO_Geometry > | < SDO_Topo_Geometry > |< SDO_GeoRaster > )
}
void media_types() : 
{}
{

( < ORDAudio >
| < ORDImage >
| < ORDVideo >
| < ORDDoc >
| < ORDDicom >
| still_image_object_types()
)
}
void still_image_object_types() : 
{}
{

( < SI_StillImage >
| < SI_AverageColor >
| < SI_PositionalColor >
| < SI_ColorHistogram >
| < SI_Texture >
| < SI_FeatureList >
| < SI_Color >
)
}


void string() : 
{}
{
[ < N > ]
( < SQL_CHAR_LITERAL >
| ( < Q > ) < APOSTROPHE > < SQL_CHAR_LITERAL > < APOSTROPHE >
)
}
void integer() : 
{}
{
[ <SQL_PLUSCHAR> | <SQL_MINUSCHAR> ] ( digit() )+
}
void number() : 
{}
{

[ <SQL_PLUSCHAR> |<SQL_MINUSCHAR> ]
(  <SQL_INTEGER> [ < SQL_PERIOD_CHAR > ] [ <SQL_INTEGER> ] 
| < SQL_PERIOD_CHAR > <SQL_INTEGER>
)
[ [ <SQL_IDENTIFIER > /*e */] [ <SQL_PLUSCHAR> | <SQL_MINUSCHAR> ]  <SQL_INTEGER> ] [ <SQL_IDENTIFIER > /*f or d*/ ]
}
void interval_year_to_month() : 
{}
{

< INTERVAL > < APOSTROPHE >integer() [<SQL_MINUSCHAR> integer() ]< APOSTROPHE >
( < YEAR > | < MONTH > ) [ <SQL_LPARENCHAR> precision() <SQL_RPARENCHAR> ] [ < TO > ( < YEAR > | < MONTH > ) ]
}



void interval_day_to_second() : 
{}
{

< INTERVAL > < APOSTROPHE >( integer() [time_expr() ] | time_expr() )< APOSTROPHE >
( ( < DAY > | < HOUR > | < MINUTE > ) [ (leading_precision()) ]
| < SECOND > [ (leading_precision() [< SQL_COMMA_CHAR > fractional_seconds_precision() ]) ]
)
[ < TO > ( < DAY > | < HOUR > | < MINUTE > | < SECOND > [ (fractional_seconds_precision()) ] ) ]
}
void hint() : 
{}
{

( "/*+" hint() [ string() ] ( hint() [ string() ] )* "*/"
| "--+" hint() [ string() ] ( hint() [ string() ] )*
)
}



void tablespec() : 
{}
{

[ view()< SQL_PERIOD_CHAR >( view()< SQL_PERIOD_CHAR > )* ]table()
}



void indexspec() : 
{}
{

( index()
| ( [ table()< SQL_PERIOD_CHAR > ]column() ( [ table()< SQL_PERIOD_CHAR > ]column() )*)
)
}
void all_rows_hint() : 
{}
{

"/*+" < ALL_ROWS > "*/"
}
void append_hint() : 
{}
{

"/*+" < APPEND > "*/"
}
void append_values_hint() : 
{}
{

"/*+" < APPEND_VALUES > "*/"
}
void cache_hint() : 
{}
{

"/*+" < CACHE > <SQL_LPARENCHAR> [ "@" queryblock() ] tablespec() <SQL_RPARENCHAR> "*/"
}
void change_dupkey_error_index() : 
{}
{

"/*+" < CHANGE_DUPKEY_ERROR_INDEX >
   
  <SQL_LPARENCHAR> table()
  ( < SQL_COMMA_CHAR > index()
    |  <SQL_LPARENCHAR> column() ( < SQL_COMMA_CHAR > column() )* <SQL_RPARENCHAR>
  )
  <SQL_RPARENCHAR> "*/"
}
void cluster_hint() : 
{}
{

"/*+" < CLUSTER > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void clustering_hint() : 
{}
{

"/*+" < CLUSTERING > "*/"
}
void cursor_sharing_exact_hint() : 
{}
{

"/*+" < CURSOR_SHARING_EXACT > "*/"
}
void driving_site_hint() : 
{}
{

"/*+" < DRIVING_SITE > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void dynamic_sampling_hint() : 
{}
{

"/*+" < DYNAMIC_SAMPLING > ( [ "@" queryblock() ] [ tablespec() ] integer() ) "*/"
}
void fact_hint() : 
{}
{

"/*+" < FACT > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void first_rows_hint() : 
{}
{

"/*+" < FIRST_ROWS > (integer()) "*/"
}
void full_hint() : 
{}
{

"/*+" < SQL_FULL > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void gather_opt_stats_hint() : 
{}
{

"/*+" < GATHER_OPTIMIZER_STATISTICS > "*/"
}
void hash_hint() : 
{}
{

"/*+" < HASH > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void ignore_row_on_dupkey_index() : 
{}
{

"/*+" < IGNORE_ROW_ON_DUPKEY_INDEX >
  <SQL_LPARENCHAR> table()
    ( < SQL_COMMA_CHAR > index()
    | <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column())* <SQL_RPARENCHAR>
    )
  <SQL_RPARENCHAR> "*/"
}
void index_hint() : 
{}
{

"/*+" < SQL_INDEX > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void index_asc_hint() : 
{}
{

"/*+" < INDEX_ASC > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void index_combine_hint() : 
{}
{

"/*+" < INDEX_COMBINE > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void index_desc_hint() : 
{}
{

"/*+" < INDEX_DESC > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void index_ffs_hint() : 
{}
{

"/*+" < INDEX_FFS > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void index_join_hint() : 
{}
{

"/*+" < INDEX_JOIN > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void index_ss_hint() : 
{}
{

"/*+" < INDEX_SS > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void index_ss_asc_hint() : 
{}
{

"/*+" < INDEX_SS_ASC > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void index_ss_desc_hint() : 
{}
{

"/*+" < INDEX_SS_DESC > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void inmemory_hint() : 
{}
{

"/*+" < INMEMORY > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void inmemory_pruning_hint() : 
{}
{

"/*+" < INMEMORY_PRUNING > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void leading_hint() : 
{}
{

"/*+" < LEADING > ( [ "@" queryblock() ] tablespec() ( tablespec() )*  ) "*/"
}
void merge_hint() : 
{}
{

"/*+" < MERGE > [ ( "@" queryblock() )  | ( [ "@" queryblock() ] tablespec() ) ] "*/"
}
void model_min_analysis_hint() : 
{}
{

"/*+" < MODEL_MIN_ANALYSIS > "*/"
}
void monitor_hint() : 
{}
{

"/*+" < MONITOR > "*/"
}
void native_foj_hint() : 
{}
{

"/*+" < NATIVE_FULL_OUTER_JOIN > "*/"
}
void noappend_hint() : 
{}
{

"/*+" < NOAPPEND > "*/"
}
void nocache_hint() : 
{}
{

"/*+" < NOCACHE > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void no_clustering_hint() : 
{}
{

"/*+" < NO_CLUSTERING > "*/"
}
void no_expand_hint() : 
{}
{

"/*+" < NO_EXPAND > [ ( "@" queryblock() ) ] "*/"
}
void no_fact_hint() : 
{}
{

"/*+" < NO_FACT > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void no_gather_opt_stats_hint() : 
{}
{

"/*+" < NO_GATHER_OPTIMIZER_STATISTICS > "*/"
}
void no_index_hint() : 
{}
{

"/*+" < NO_INDEX > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void no_index_ffs_hint() : 
{}
{

"/*+" < NO_INDEX_FFS > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )*  ] ) "*/"
}
void no_index_ss_hint() : 
{}
{

"/*+" < NO_INDEX_SS > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )*  ] ) "*/"
}
void no_inmemory_hint() : 
{}
{

"/*+" < NO_INMEMORY > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void no_inmemory_pruning_hint() : 
{}
{

"/*+" < NO_INMEMORY_PRUNING > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void no_merge_hint() : 
{}
{

"/*+" < NO_MERGE > [ ( "@" queryblock() )  | ( [ "@" queryblock() ] tablespec() ) ] "*/"
}
void no_monitor_hint() : 
{}
{

"/*+" < NO_MONITOR > "*/"
}
void no_native_foj_hint() : 
{}
{

"/*+" < NO_NATIVE_FULL_OUTER_JOIN > "*/"
}
void no_parallel_hint() : 
{}
{

"/*+" < NO_PARALLEL > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void no_parallel_index_hint() : 
{}
{

"/*+" < NO_PARALLEL_INDEX > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}
void no_pq_concurrent_union_hint() : 
{}
{

"/*+" < NO_PQ_CONCURRENT_UNION > [ ( "@" queryblock() ) ] "*/"
}
void no_pq_skew_hint() : 
{}
{

"/*+" < NO_PQ_SKEW > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void no_push_pred_hint() : 
{}
{

"/*+" < NO_PUSH_PRED > [ ( "@" queryblock() ) | ( [ "@" queryblock() ] tablespec() ) ] "*/"
}
void no_push_subq_hint() : 
{}
{

"/*+" < NO_PUSH_SUBQ > [ ( "@" queryblock() ) ] "*/"
}
void no_px_join_filter_hint() : 
{}
{

"/*+" < NO_PX_JOIN_FILTER > (tablespec()) "*/"
}
void no_query_transformatn_hint() : 
{}
{

"/*+" < NO_QUERY_TRANSFORMATION > "*/"
}
void no_result_cache_hint() : 
{}
{

"/*+" < NO_RESULT_CACHE > "*/"
}
void no_rewrite_hint() : 
{}
{

"/*+" < NO_REWRITE > [ ( "@" queryblock() ) ] "*/"
}
void no_star_transformation_hint() : 
{}
{

"/*+" < NO_STAR_TRANSFORMATION > [ ( "@" queryblock() ) ] "*/"
}
void no_statement_queuing_hint() : 
{}
{

"/*+" < NO_STATEMENT_QUEUING > "*/"
}
void no_unnest_hint() : 
{}
{

"/*+" < NO_UNNEST > [ ( "@" queryblock() ) ] "*/"
}
void no_use_cube_hint() : 
{}
{

"/*+" < NO_USE_CUBE > ( [ "@" queryblock() ] tablespec() ( tablespec() )* ) "*/"
}
void no_use_hash_hint() : 
{}
{

"/*+" < NO_USE_HASH > ( [ "@" queryblock() ] tablespec() ( tablespec() )* ) "*/"
}
void no_use_merge_hint() : 
{}
{

"/*+" < NO_USE_MERGE > ( [ "@" queryblock() ] tablespec() ( tablespec() )* ) "*/"
}
void no_use_nl_hint() : 
{}
{

"/*+" < NO_USE_NL > ( [ "@" queryblock() ] tablespec() ( tablespec() )* ) "*/"
}
void no_xml_query_rewrite_hint() : 
{}
{

"/*+" < NO_XML_QUERY_REWRITE > "*/"
}
void no_xmlindex_rewrite_hint() : 
{}
{

"/*+" < NO_XMLINDEX_REWRITE > "*/"
}
void no_zonemap_hint() : 
{}
{

"/*+" < NO_ZONEMAP > ( [ "@" queryblock() ] tablespec() ( < SCAN > | < SQL_JOIN > | < PARTITION > ) ) "*/"
}



void opt_param_hint() : 
{}
{

"/*+" < OPT_PARAM > ( parameter_name() [< SQL_COMMA_CHAR >] parameter_value() ) "*/"
}
void ordered_hint() : 
{}
{

"/*+" < ORDERED > "*/"
}
void parallel_hint_statement() : 
{}
{

"/*+" < PARALLEL > [ ( < SQL_DEFAULT > | < AUTO > | < MANUAL > | integer() ) ] "*/"
}
void parallel_hint_object() : 
{}
{

"/*+" < PARALLEL > ( [ "@" queryblock() ] tablespec() [ integer() | < SQL_DEFAULT > ] ) "*/"
}
void parallel_index_hint() : 
{}
{

"/*+" < PARALLEL_INDEX >
  ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ]
    [ ( integer() | < SQL_DEFAULT > ) ] ) "*/"
}
void pq_concurrent_union_hint() : 
{}
{

"/*+" < PQ_CONCURRENT_UNION > [ ( "@" queryblock() ) ] "*/"
}


void pq_distribute_hint() : 
{}
{

"/*+" < PQ_DISTRIBUTE >
  ( [ "@" queryblock() ] tablespec() 
    ( distribution() | outer_distribution() inner_distribution() )
  ) "*/"
}
void pq_filter_hint() : 
{}
{

"/*+" < PQ_FILTER > ( < SERIAL > | < NONE > | < HASH > | < RANDOM > ) "*/"
}
void pq_skew_hint() : 
{}
{

"/*+" < PQ_SKEW > ( [ "@" queryblock() ] tablespec() ) "*/"
}
void push_pred_hint() : 
{}
{

"/*+" < PUSH_PRED > [ ( "@" queryblock() )  | ( [ "@" queryblock() ] tablespec() ) ] "*/"
}
void push_subq_hint() : 
{}
{

"/*+" < PUSH_SUBQ > [ ( "@" queryblock() ) ] "*/"
}
void px_join_filter_hint() : 
{}
{

"/*+" < PX_JOIN_FILTER > (tablespec()) "*/"
}
void qb_name_hint() : 
{}
{

"/*+" < QB_NAME > ( queryblock() ) "*/"
}
void result_cache_hint() : 
{}
{

"/*+" < RESULT_CACHE > "*/"
}
void retry_on_row_change() : 
{}
{

"/*+" < RETRY_ON_ROW_CHANGE > "*/"
}
void rewrite_hint() : 
{}
{

"/*+" < REWRITE > [ ( [ "@" queryblock() ] view() ( view() )* ) ] "*/"
}
void star_transformation_hint() : 
{}
{

"/*+" < STAR_TRANSFORMATION > [ ( "@" queryblock() ) ] "*/"
}
void statement_queuing_hint() : 
{}
{

"/*+" < STATEMENT_QUEUING > "*/"
}
void unnest_hint() : 
{}
{

"/*+" < UNNEST > [ ( "@" queryblock() ) ] "*/"
}
void use_concat_hint() : 
{}
{

"/*+" < USE_CONCAT > [ ( "@" queryblock() ) ] "*/"
}
void use_cube_hint() : 
{}
{

"/*+" < USE_CUBE > ( [ "@" queryblock() ] tablespec() ( tablespec() )* ) "*/"
}
void use_hash_hint() : 
{}
{

"/*+" < USE_HASH > ( [ "@" queryblock() ] tablespec() ( tablespec() )* ) "*/"
}
void use_merge_hint() : 
{}
{

"/*+" < USE_MERGE > ( [ "@" queryblock() ] tablespec() ( tablespec() )* ) "*/"
}
void use_nl_hint() : 
{}
{

"/*+" < USE_NL > ( [ "@" queryblock() ] tablespec() ( tablespec() )* ) "*/"
}
void use_nl_with_index_hint() : 
{}
{

"/*+" < USE_NL_WITH_INDEX > ( [ "@" queryblock() ] tablespec() [ indexspec() ( indexspec() )* ] ) "*/"
}



void database_object_or_part() : 
{}
{

[ schema()< SQL_PERIOD_CHAR > ] object() [ < SQL_PERIOD_CHAR >part() ] [ "@" dblink() ]
}



void dblink() : 
{}
{

database()[< SQL_PERIOD_CHAR >domain() (< SQL_PERIOD_CHAR >domain() )* ] [ "@" connection_qualifier() ]
}
void partition_extended_name() : 
{}
{

< PARTITION > 
(  partition()
|  < FOR> <SQL_LPARENCHAR> partition_key_value() ( < SQL_COMMA_CHAR > partition_key_value() )* <SQL_RPARENCHAR>  
)

}


void subpartition_extended_name() : 
{}
{

< SUBPARTITION >
(
  subpartition()
| < FOR> <SQL_LPARENCHAR> subpartition_key_value() (< SQL_COMMA_CHAR > subpartition_key_value())* <SQL_RPARENCHAR>
)
}
void partition_extension_clause() : 
{}
{

( < PARTITION > ( <SQL_LPARENCHAR> partition() <SQL_RPARENCHAR> | < FOR> <SQL_LPARENCHAR> partition_key_value() (< SQL_COMMA_CHAR > partition_key_value())* <SQL_RPARENCHAR> ) 
| < SUBPARTITION > ( <SQL_LPARENCHAR> subpartition() <SQL_RPARENCHAR> |  < FOR> <SQL_LPARENCHAR> subpartition_key_value() ( < SQL_COMMA_CHAR > subpartition_key_value() )* <SQL_RPARENCHAR> )
)
}




void multiset_except() : 
{}
{

nested_table1()
< MULTISET> < EXCEPT>[ <SQL_ALL > | < SQL_DISTINCT > ]
nested_table2()
}
void multiset_intersect() : 
{}
{

nested_table1()
< MULTISET> < SQL_INTERSECT>[ < SQL_ALL > | < SQL_DISTINCT > ]
nested_table2()
}
void multiset_union() : 
{}
{

nested_table1()
< MULTISET> < SQL_UNION>[ < SQL_ALL > | < SQL_DISTINCT > ]
nested_table2()
}




void expr() : 
{}
{
( simple_expression()
| compound_expression()
| case_expression()
| cursor_expression()
| datetime_expression()
| function_expression()
| interval_expression()
| json_object_access_expr()
| model_expression()
| object_access_expression()
| scalar_subquery_expression()
| type_constructor_expression()
| variable_expression()
)
}

void simple_expression() : 
{}
{

( [ query_name()< SQL_PERIOD_CHAR >
  | [schema()< SQL_PERIOD_CHAR >]
    ( table()< SQL_PERIOD_CHAR > | view()< SQL_PERIOD_CHAR > | materializedview()< SQL_PERIOD_CHAR > )
  ] ( column() | < ROWID > )
| string()
| number()
| <SQL_DOUBLE>
| sequence()< SQL_PERIOD_CHAR > ( < CURRVAL > | < NEXTVAL > )
| < ROWNUM >
| < SQL_NULL >
| <LEVEL>
| <SQL_ORA_SYSDATE >
)
}
void compound_expression() : 
{}
{
( <SQL_LPARENCHAR> expr() <SQL_RPARENCHAR>
| ( <SQL_PLUSCHAR> | <SQL_MINUSCHAR> | < PRIOR > ) expr()
|  ( <SQL_ASTERISKCHAR> | <SQL_SLASHCHAR> | <SQL_PLUSCHAR> | <SQL_MINUSCHAR> | < SQL_CONCATCHAR > ) expr()
)

}
void case_expression() : 
{}
{

< SQL_CASE > ( simple_case_expression()
     | searched_case_expression()
     )
     [ else_clause() ]
     < SQL_END >
}




void simple_case_expression() : 
{}
{

expr()
  ( < SQL_WHEN > comparison_expr() < SQL_THEN > return_expr() )+
}
void searched_case_expression() : 
{}
{

( < SQL_WHEN > condition() < SQL_THEN > return_expr() )+
}



void else_clause() : 
{}
{

< SQL_ELSE > else_expr()
}
void cursor_expression() : 
{}
{

< CURSOR > (subquery())
}


void datetime_expression() : 
{}
{

   < AT >
   ( < LOCAL >
   | < TIME> < ZONE>( < APOSTROPHE > (time_zone_name() | [ <SQL_PLUSCHAR> | <SQL_MINUSCHAR> ] hh() ":" mi() ) < APOSTROPHE >
               | < SQL_ORA_DBTIMEZONE >
               | expr()
               )
   )
}
void interval_expression() : 
{}
{

( expr1() <SQL_MINUSCHAR> expr2() )
   ( < DAY > [ (leading_field_precision()) ] < TO >
     < SECOND > [ (fractional_second_precision()) ]
   | < YEAR > [ (leading_field_precision()) ] < TO >
     < MONTH >
   )
}
void json_object_access_expr() : 
{}
{

table_alias()< SQL_PERIOD_CHAR >JSON_column() (< SQL_PERIOD_CHAR >JSON_object_key() )*
}
void model_expression() : 
{}
{

( measure_column() < LEFT_ > 
(
  condition()  ( < SQL_COMMA_CHAR >  condition() )*
|
  expr()  ( < SQL_COMMA_CHAR >  expr() )*
)
< RIGHT_ >
| aggregate_function() 
        ( < LEFT_ > ( condition() | expr() )[ < SQL_COMMA_CHAR > ( condition() | expr() )+] < RIGHT_ >
        | < LEFT_ > single_column_for_loop() (< SQL_COMMA_CHAR > single_column_for_loop())* < RIGHT_ >
        | < LEFT_ > multi_column_for_loop() < RIGHT_ >
        )
| analytic_function()
)

}
void object_access_expression() : 
{}
{
( table_alias()< SQL_PERIOD_CHAR >column()< SQL_PERIOD_CHAR >
| object_table_alias()< SQL_PERIOD_CHAR >
| <SQL_LPARENCHAR> expr() <SQL_RPARENCHAR> < SQL_PERIOD_CHAR >
)
( attribute() (< SQL_PERIOD_CHAR >attribute() )*
  [< SQL_PERIOD_CHAR >method() ([ argument() (< SQL_COMMA_CHAR > argument() )* ]) ]
| method() ([ argument() (< SQL_COMMA_CHAR > argument() )* ])
)
}
void placeholder_expression() : 
{}
{

":"host_variable()
   [ [ < INDICATOR > ]
     ":"indicator_variable()
   ]
}
void type_constructor_expression() : 
{}
{

[ < NEW > ] [ schema()< SQL_PERIOD_CHAR > ]type_name()
   ([ expr() (< SQL_COMMA_CHAR > expr() )* ])
}

void condition() : 
{}
{

( simple_comparison_condition()
| floating_point_condition()
| logical_condition()
| model_condition()
| multiset_condition()
| pattern_matching_condition()
| range_condition()
| null_condition()
| XML_condition()
| JSON_condition()
| compound_condition()
| exists_condition()
| in_condition()
| is_of_type_condition()
)
}
void simple_comparison_condition() : 
{}
{

( expr() 
  ( <ESQL_EQ> | <SQL_NOTEQUALCHAR> | < SQL_NOTEQUALCHAR_WITH_XOR > | < SQL_UNEQUALCHAR > | <SQL_LESSTHANCHAR>  | < SQL_LESSTHANOREQUAL > | < SQL_MORETHANOREQUAL > |< SQL_MORETHANCHAR >)
  expr()
| <SQL_LPARENCHAR> expr() (< SQL_COMMA_CHAR > expr() )* <SQL_RPARENCHAR>
  ( <ESQL_EQ> | <SQL_NOTEQUALCHAR> | < SQL_NOTEQUALCHAR_WITH_XOR > | < SQL_UNEQUALCHAR > )
  <SQL_LPARENCHAR> subquery() <SQL_RPARENCHAR>
)
}
void expression_list() : 
{}
{
  expr() (< SQL_COMMA_CHAR > expr() )* 
}
void group_comparison_condition() : 
{}
{

( expr()
     ( <ESQL_EQ> | <SQL_NOTEQUALCHAR> | < SQL_NOTEQUALCHAR_WITH_XOR > | < SQL_UNEQUALCHAR > | <SQL_LESSTHANCHAR> | < SQL_LESSTHANOREQUAL > | < SQL_MORETHANOREQUAL > | < SQL_MORETHANCHAR > )
     ( < SQL_ANY > | < SQL_SOME > | < SQL_ALL > )
     (( expression_list() | subquery() ))
| ( expr() (< SQL_COMMA_CHAR > expr() )* )
  ( <ESQL_EQ> | <SQL_NOTEQUALCHAR> | < SQL_NOTEQUALCHAR_WITH_XOR > | < SQL_UNEQUALCHAR > )
  ( < SQL_ANY > | < SQL_SOME > | < SQL_ALL > )
  (( expression_list()
     (< SQL_COMMA_CHAR > expression_list() )*
   | subquery()
   )
  )
)
}

void floating_point_condition() : 
{}
{

expr() < SQL_IS > [ < SQL_NOT > ] ( < NAN > | < INFINITE > )
}
void is_any_condition() : 
{}
{
[ dimension_column() < SQL_IS > ] < SQL_ANY >
}
void is_present_condition() : 
{}
{

cell_reference() < SQL_IS> < PRESENT>}
void is_a_set_condition() : 
{}
{
nested_table() < SQL_IS > [ < SQL_NOT > ] <SQL_A_SET >
}
void is_empty_condition() : 
{}
{

nested_table() < SQL_IS > [ < SQL_NOT > ] < EMPTY >
}
void member_condition() : 
{}
{

expr() [ < SQL_NOT > ] < MEMBER > [ < OF > ] nested_table()
}
void submultiset_condition() : 
{}
{

nested_table1()
[ < SQL_NOT > ] < SUBMULTISET > [ < OF > ]
nested_table2()
}
void like_condition() : 
{}
{

char1() [ < SQL_NOT > ] ( < SQL_LIKE > | < LIKEC > | < LIKE2 > | < LIKE4 > )
  char2() [ < SQL_ESCAPE > esc_char() ]
}
void regexp_like_condition() : 
{}
{

< REGEXP_LIKE >(source_char()< SQL_COMMA_CHAR > pattern()
            [< SQL_COMMA_CHAR > match_param() ]
           )
}
void null_condition() : 
{}
{
expr() < SQL_IS > [ < SQL_NOT > ] < SQL_NULL >
}
void equals_path_condition() : 
{}
{

< EQUALS_PATH >
    (column()< SQL_COMMA_CHAR > path_string() [< SQL_COMMA_CHAR > correlation_integer() ])
}
void under_path_condition() : 
{}
{

< UNDER_PATH > (column() [< SQL_COMMA_CHAR > levels() ]< SQL_COMMA_CHAR > path_string()
             [< SQL_COMMA_CHAR > correlation_integer() ]
           )
}
void is_json_condition() : 
{}
{

expr() < SQL_IS > [ < SQL_NOT > ] < JSON > [ < STRICT > | < LAX > ] [ ( < SQL_WITH> | < WITHOUT > ) < UNIQUE> < KEYS>]
}
void json_exists_condition() : 
{}
{

< JSON_EXISTS >( expr()< SQL_COMMA_CHAR > JSON_path_expression() [ JSON_exists_on_error_clause() ] )
}
void json_path_expression() : 
{}
{

"$"( object_step() | array_step() )*
}
void object_step() : 
{}
{

< SQL_PERIOD_CHAR >( simple_name() | "complex_name()"  | <SQL_ASTERISKCHAR> )
}
void array_step() : 
{}
{

< LEFT_ > ( integer() | integer() < TO > integer() (< SQL_COMMA_CHAR > integer() | integer() < TO > integer() )* ) | <SQL_ASTERISKCHAR> < RIGHT_ >

}
void json_exists_on_error_clause() : 
{}
{

( < ERROR > | < TRUE > | < FALSE > ) < SQL_ON> < ERROR>}
void json_textcontains_condition() : 
{}
{

< JSON_TEXTCONTAINS >( column()< SQL_COMMA_CHAR > JSON_path_expression()< SQL_COMMA_CHAR > string() )
}
 
 
void compound_condition() : 
{}
{

( <SQL_LPARENCHAR> condition() <SQL_RPARENCHAR>
| < SQL_NOT > condition()
| ( < SQL_AND> | < SQL_OR> ) condition()
)
}
void between_condition() : 
{}
{

expr1() [ < SQL_NOT > ] < SQL_BETWEEN> expr2() < SQL_AND> expr3()
}
void exists_condition() : 
{}
{

< SQL_EXISTS> (subquery())
}
void in_condition() : 
{}
{

( expr() [ < SQL_NOT > ] < SQL_IN> (( expression_list() | subquery() ))
| ( expr() (< SQL_COMMA_CHAR > expr() )* )
    [ < SQL_NOT > ] < SQL_IN> (( expression_list() (< SQL_COMMA_CHAR > expression_list() )*
                | subquery()
                )
               )
)
}

void is_of_type_condition() : 
{}
{

expr() < SQL_IS > [ < SQL_NOT > ] < OF > [ < TYPE > ]
   ([ < ONLY > ] [ schema()< SQL_PERIOD_CHAR > ] type()
      ( < SQL_COMMA_CHAR > [ < ONLY > ] [ schema()< SQL_PERIOD_CHAR > ] type() )*
   )
}
void function() : 
{}
{
  [ <SQL_FN_CHAR >]
  (
    <SQL_IDENTIFIER>
| <SQL_ORA_DECODE >
| <SQL_ORA_NVL >
| <SQL_ORA_NVL2 >
| <SQL_ORA_SUBSTR >
| <SQL_ORA_SUBSTRB >
| <SQL_ORA_SUM >
| <SQL_ORA_CONCAT >
| <SQL_ORA_INICAP >
| <SQL_ORA_LOWER >
| <SQL_ORA_UPPER >
| <SQL_ORA_LENGTH >
| <SQL_ORA_LENGTHB >
| <SQL_ORA_INSTR >
| <SQL_ORA_LPAD >
| <SQL_ORA_RPAD >
| <SQL_ORA_LTRIM >
| <SQL_ORA_RTRIM >
| <SQL_ORA_TRIM >
| <SQL_ORA_ROUND >
| <SQL_ORA_TRUNC >
| <SQL_ORA_MOD >
| <SQL_ORA_CEIL >
| <SQL_ORA_FLOOR >
| <SQL_ORA_TO_CHAR >
| <SQL_ORA_TO_NUMBER >
| <SQL_ORA_TO_DATE >
| <SQL_ORA_OVER >
| <SQL_ORA_RANK >
| <SQL_ORA_ABS >
| <SQL_ORA_ACOS >
| <SQL_ORA_ATAN >
| <SQL_ORA_ATAN2 >
| <SQL_ORA_BITAND >
| <SQL_ORA_COS >
| <SQL_ORA_COSH >
| <SQL_ORA_EXP >
| <SQL_ORA_LN >
| <SQL_ORA_LOG >
| <SQL_ORA_NANVL >
| <SQL_ORA_POWER >
| <SQL_ORA_REMAINDER >
| <SQL_ORA_SIGN >
| <SQL_ORA_SIN >
| <SQL_ORA_SINH >
| <SQL_ORA_SQRT >
| <SQL_ORA_TAN >
| <SQL_ORA_TANH >
| <SQL_ORA_WIDTH_BUCKET >
| <SQL_ORA_CHR >
| <SQL_ORA_INITCAP >
| <SQL_ORA_NLS_INITCAP >
| <SQL_ORA_NLS_LOWER >
| <SQL_ORA_NLSSORT >
| <SQL_ORA_NLS_UPPER >
| <SQL_ORA_REGEXP_REPLACE >
| <SQL_ORA_REGEXP_SUBSTR >
| <SQL_ORA_SOUNDEX >
| <SQL_ORA_TRANSLATE >
| <SQL_ORA_TREAT >
| <SQL_ORA_ASCII >
| <SQL_ORA_REGEXP_INSTR >
| <SQL_ORA_ADD_MONTHS >
| <SQL_ORA_CURRENT_DATE >
| <SQL_ORA_CURRENT_TIMESTAMP >
| <SQL_ORA_DBTIMEZONE >
| <SQL_ORA_EXTRACT >
| <SQL_ORA_FROM_TZ >
| <SQL_ORA_LAST_DAY >
| <SQL_ORA_LOCALTIMESTAMP >
| <SQL_ORA_MONTHS_BETWEEN >
| <SQL_ORA_NEW_TIME >
| <SQL_ORA_NEXT_DAY >
| <SQL_ORA_NUMTODSINTERVAL >
| <SQL_ORA_NUMTOYMINTERVAL >
| <SQL_ORA_SESSIONTIMEZONE >
| <SQL_ORA_SYS_EXTRACT_UTC >
| <SQL_ORA_SYSDATE >
| <SQL_ORA_SYSTIMESTAMP >
| <SQL_ORA_TO_TIMESTAMP >
| <SQL_ORA_TO_TIMESTAMP_TZ >
| <SQL_ORA_TO_DSINTERVAL >
| <SQL_ORA_TO_YMINTERVAL >
| <SQL_ORA_TZ_OFFSET >
| <SQL_ORA_ASCIISTR >
| <SQL_ORA_BIN_TO_NUM >
| <SQL_ORA_CAST >
| <SQL_ORA_CHARTOROWID >
| <SQL_ORA_COMPOSE >
| <SQL_ORA_CONVERT >
| <SQL_ORA_DECOMPOSE >
| <SQL_ORA_HEXTORAW >
| <SQL_ORA_RAWTOHEX >
| <SQL_ORA_RAWTONHEX >
| <SQL_ORA_ROWIDTOCHAR >
| <SQL_ORA_ROWIDTONCHAR >
| <SQL_ORA_SCN_TO_TIMESTAMP >
| <SQL_ORA_TIMESTAMP_TO_SCN >
| <SQL_ORA_TO_BINARY_DOUBLE >
| <SQL_ORA_TO_BINARY_FLOAT >
| <SQL_ORA_TO_CLOB >
| <SQL_ORA_TO_LOB >
| <SQL_ORA_TO_MULTI_BYTE >
| <SQL_ORA_TO_NCHAR >
| <SQL_ORA_TO_NCLOB >
| <SQL_ORA_TO_SINGLE_BYTE >
| <SQL_ORA_UNISTR >
| <SQL_ORA_CARDINALITY >
| <SQL_ORA_COLLECT >
| <SQL_ORA_POWERMULTISET >
| <SQL_ORA_POWERMULTISET_BY_CARDINALITY >
| <SQL_ORA_BFILENAME >
| <SQL_ORA_COALESCE >
| <SQL_ORA_CV >
| <SQL_ORA_DEPTH >
| <SQL_ORA_DUMP >
| <SQL_ORA_EMPTY_BLOB >
| <SQL_ORA_EMPTY_CLOB >
| <SQL_ORA_EXISTSNODE >
| <SQL_ORA_EXTRACTVALUE >
| <SQL_ORA_GREATEST >
| <SQL_ORA_LEAST >
| <SQL_ORA_LNNVL >
| <SQL_ORA_NLS_CHARSET_DECL_LEN >
| <SQL_ORA_NLS_CHARSET_ID >
| <SQL_ORA_NLS_CHARSET_NAME >
| <SQL_ORA_NULLIF >
| <SQL_ORA_ORA_HASH >
| <SQL_ORA_PATH >
| <SQL_ORA_PRESENTNNV >
| <SQL_ORA_PRESENTV >
| <SQL_ORA_PREVIOUS >
| <SQL_ORA_SYS_CONNECT_BY_PATH >
| <SQL_ORA_SYS_CONTEXT >
| <SQL_ORA_SYS_DBURIGEN >
| <SQL_ORA_SYS_GUID >
| <SQL_ORA_SYS_TYPEID >
| <SQL_ORA_SYS_XMLAGG >
| <SQL_ORA_SYS_XMLGEN >
| <SQL_ORA_UID >
| <SQL_ORA_UPDATEXML >
| <SQL_ORA_USER >
| <SQL_ORA_USERENV >
| <SQL_ORA_VSIZE >
| <SQL_ORA_XMLAGG >
| <SQL_ORA_XMLCOLATTVAL >
| <SQL_ORA_XMLCONCAT >
| <SQL_ORA_XMLFOREST >
| <SQL_ORA_XMLSEQUENCE >
| <SQL_ORA_XMLTRANSFORM >
| <SQL_ORA_AVG >
| <SQL_ORA_CORR >
| <SQL_ORA_COUNT >
| <SQL_ORA_COVAR_POP >
| <SQL_ORA_COVAR_SAMP >
| <SQL_ORA_CUME_DIST >
| <SQL_ORA_DENSE_RANK >
| <SQL_ORA_FIRST >
| <SQL_ORA_GROUP_ID >
| <SQL_ORA_GROUPING >
| <SQL_ORA_GROUPING_ID >
| <SQL_ORA_LAST >
| <SQL_ORA_MAX >
| <SQL_ORA_MEDIAN >
| <SQL_ORA_MIN >
| <SQL_ORA_PERCENTILE_CONT >
| <SQL_ORA_PERCENTILE_DISC >
| <SQL_ORA_PERCENT_RANK >
| <SQL_ORA_STATS_BINOMIAL_TEST >
| <SQL_ORA_STATS_CROSSTAB >
| <SQL_ORA_STATS_F_TEST >
| <SQL_ORA_STATS_KS_TEST >
| <SQL_ORA_STATS_MODE >
| <SQL_ORA_STATS_MW_TEST >
| <SQL_ORA_STATS_ONE_WAY_ANOVA >
| <SQL_ORA_STATS_WSR_TEST >
| <SQL_ORA_STDDEV >
| <SQL_ORA_STDDEV_POP >
| <SQL_ORA_STDDEV_SAMP >
| <SQL_ORA_VAR_POP >
| <SQL_ORA_VAR_SAMP >
| <SQL_ORA_VARIANCE >
| <SQL_ORA_NTILE >
| <SQL_ORA_RATIO_TO_REPORT >
| <SQL_ORA_DEREF >
| <SQL_ORA_MAKE_REF >
| <SQL_ORA_REF >
| <SQL_ORA_REFTOHEX >
| <SQL_ORA_VALUE >
| <SQL_ORA_ITERATION_NUMBER >
  )
  [  <SQL_PERIOD_CHAR> <SQL_IDENTIFIER> [ <SQL_PERIOD_CHAR> <SQL_IDENTIFIER > ] ]
  < SQL_LPARENCHAR > [ [ < SQL_DISTINCT > | < SQL_ALL > ]  (  expr() ( [ <SQL_COMMA_CHAR>] expr() )* | < SQL_ASTERISKCHAR > ) ]
  < SQL_RPARENCHAR > [ < SQL_RBRACKET >  ]
/*           
( single_row_function()
| aggregate_function()
| analytic_function()
| object_reference_function()
| model_function()
| user_defined_function()
| OLAP_function()
| data_cartridge_function()
)
*/
}
void single_row_function() : 
{}
{

( numeric_function()
| character_function()
| datetime_function()
| comparison_function()
| large_object_function()
| collection_function()
| hierarchical_function()
| data_mining_function()
| XML_function()
| JSON_function()
| encoding_decoding_function()
| NULL_related_function()
| environment_id_function()
)
}
void analytic_function() : 
{}
{
( [ <SQL_LPARENCHAR> [ arguments() ] <SQL_RPARENCHAR> < SQL_ORA_OVER> ] <SQL_LPARENCHAR> analytic_clause() <SQL_RPARENCHAR> )+
}
void analytic_clause() : 
{}
{

[ query_partition_clause() ] [ order_by_clause() [ windowing_clause() ] ]
}

void order_by_clause() : 
{}
{

< SQL_ORDER> [ < SIBLINGS > ] < SQL_BY>
( expr() | position() | c_alias() )
[ < SQL_ASC> | < SQL_DESC> ]
[ < NULLS> < SQL_ORA_FIRST>| < NULLS> < SQL_ORA_LAST>]
  (
    < SQL_COMMA_CHAR > ( expr() | position() | c_alias() )
     [ < SQL_ASC> | < SQL_DESC> ]
     [ < NULLS> < SQL_ORA_FIRST>| < NULLS> < SQL_ORA_LAST>]
   )*
}
void windowing_clause() : 
{}
{

( < ROWS > | < RANGE > )
( < SQL_BETWEEN>
  ( < UNBOUNDED> < PRECEDING>| < CURRENT> < ROW>| value_expr() ( < PRECEDING > | < FOLLOWING > )
  ) 
  < SQL_AND>
  ( < UNBOUNDED> < FOLLOWING>| < CURRENT> < ROW>| value_expr() ( < PRECEDING > | < FOLLOWING > )
  )
| ( < UNBOUNDED> < PRECEDING>| < CURRENT> < ROW>| value_expr() < PRECEDING >
  )
)
}


/*sql_functions*/
void abs() : 
{}
{

< SQL_ORA_ABS>(n())
}
void acos() : 
{}
{

< SQL_ORA_ACOS>(n())
}
void add_months() : 
{}
{

< SQL_ORA_ADD_MONTHS>(date()< SQL_COMMA_CHAR > integer())
}
void appendchildxml() : 
{}
{

< APPENDCHILDXML >
  ( XMLType_instance()< SQL_COMMA_CHAR > XPath_string()< SQL_COMMA_CHAR > value_expr() [< SQL_COMMA_CHAR > namespace_string() ])
}

void approx_count_distinct() : 
{}
{

< APPROX_COUNT_DISTINCT >(expr())
}


void asin() : 
{}
{

< ASIN >(n())
}
void atan() : 
{}
{

< SQL_ORA_ATAN>(n())
}
void atan2() : 
{}
{

< SQL_ORA_ATAN2>(n1() < SQL_COMMA_CHAR > n2())
}
void avg() : 
{}
{

< SQL_ORA_AVG>([ < SQL_DISTINCT> | < SQL_ALL> ] expr()) [ < SQL_ORA_OVER>(analytic_clause()) ]
}
void bfilename() : 
{}
{

< SQL_ORA_BFILENAME>(< APOSTROPHE >directory()< APOSTROPHE >< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE >)
}
void bin_to_num() : 
{}
{

< SQL_ORA_BIN_TO_NUM>(expr() (< SQL_COMMA_CHAR > expr() )* )
}
void bitand() : 
{}
{

< SQL_ORA_BITAND>(expr1()< SQL_COMMA_CHAR > expr2())
}
void cardinality() : 
{}
{

< SQL_ORA_CARDINALITY>(nested_table())
}
void cast() : 
{}
{

< SQL_ORA_CAST>(( expr() | < MULTISET > (subquery()) ) < SQL_AS> type_name())
}
void ceil() : 
{}
{

< SQL_ORA_CEIL>(n())
}


void chr() : 
{}
{
< SQL_ORA_CHR>(n() [ < SQL_USING> < NCHAR_CS>])
}
void cluster_details() : 
{}
{

< CLUSTER_DETAILS > ( [ schema() < SQL_PERIOD_CHAR > ] model() 
        [ < SQL_COMMA_CHAR > cluster_id() [ < SQL_COMMA_CHAR > topN() ] ] [ <SQL_DESC > | < SQL_ASC > | <  SQL_ORA_ABS > ]
        mining_attribute_clause() )
}
void cluster_details_analytic() : 
{}
{

< CLUSTER_DETAILS >  ( INTO() n()
        [ < SQL_COMMA_CHAR > cluster_id() [ < SQL_COMMA_CHAR > topN() ] ] [ <SQL_DESC > | < SQL_ASC > | <  SQL_ORA_ABS > ]
        mining_attribute_clause() )
        OVER() ( mining_analytic_clause() )
}
void mining_attribute_clause() : 
{}
{

< SQL_USING>
( <SQL_ASTERISKCHAR> 
| ( [ schema() < SQL_PERIOD_CHAR > ] table() < SQL_PERIOD_CHAR > <SQL_ASTERISKCHAR> 
  | expr() [ < SQL_AS> alias() ]
  )
    (
      < SQL_COMMA_CHAR > ( [ schema() < SQL_PERIOD_CHAR > ] table() < SQL_PERIOD_CHAR > <SQL_ASTERISKCHAR> 
       | expr() [ < SQL_AS> alias() ]
       )
  )*
)
}
void mining_analytic_clause() : 
{}
{

[ query_partition_clause() ] [ order_by_clause() ]
}
void cluster_distance() : 
{}
{

< CLUSTER_DISTANCE > ( [ schema() < SQL_PERIOD_CHAR > ] model()
   [ < SQL_COMMA_CHAR > cluster_id() ] mining_attribute_clause() )
}
void cluster_distance_analytic() : 
{}
{

< CLUSTER_DISTANCE >  ( INTO() n() [< SQL_COMMA_CHAR > cluster_id()] mining_attribute_clause() )
                   OVER() ( mining_analytic_clause() )
}
 
 
void cluster_id() : 
{}
{

< CLUSTER_ID > ( [ schema() < SQL_PERIOD_CHAR > ] model() mining_attribute_clause() )
}
void cluster_id_analytic() : 
{}
{

< CLUSTER_ID >  ( INTO() n() mining_attribute_clause() )
                   OVER() ( mining_analytic_clause() )
}


void cluster_probability() : 
{}
{

< CLUSTER_PROBABILITY > ( [ schema() < SQL_PERIOD_CHAR > ] model()
   [ < SQL_COMMA_CHAR > cluster_id() ] mining_attribute_clause() )
}
void cluster_prob_analytic() : 
{}
{

< CLUSTER_PROBABILITY >  ( INTO() n() [< SQL_COMMA_CHAR > cluster_id()] mining_attribute_clause() )
                   OVER() ( mining_analytic_clause() )
}


void cluster_set() : 
{}
{

< CLUSTER_SET > ( [ schema() < SQL_PERIOD_CHAR > ] model() [ < SQL_COMMA_CHAR > topN() [ < SQL_COMMA_CHAR > cutoff() ] ] mining_attribute_clause() )
}
void cluster_set_analytic() : 
{}
{

< CLUSTER_SET >  ( INTO() n() [< SQL_COMMA_CHAR > topN() [< SQL_COMMA_CHAR > cutoff()]] mining_attribute_clause() )
                   OVER() ( mining_analytic_clause() )
}


void coalesce() : 
{}
{

< SQL_ORA_COALESCE>(expr() (< SQL_COMMA_CHAR > expr() )*)
}
void collect() : 
{}
{

< SQL_ORA_COLLECT>( [ < SQL_DISTINCT> | < UNIQUE > ] column() [ < SQL_ORDER> < SQL_BY>expr() ] )
}
void compose() : 
{}
{
< SQL_ORA_COMPOSE>/*(char())*/
}
void con_dbid_to_id() : 
{}
{

< CON_DBID_TO_ID >(container_dbid())
}
void con_guid_to_id() : 
{}
{

< CON_GUID_TO_ID >(container_guid())
}
void con_name_to_id() : 
{}
{

< CON_NAME_TO_ID >(container_name())
}
void con_uid_to_id() : 
{}
{

< CON_UID_TO_ID >(container_uid())
}
void concat() : 
{}
{

< SQL_ORA_CONCAT>(char1()< SQL_COMMA_CHAR > char2())
}

void sql_char() :
{}
{
  "sql_char"
}

void convert() : 
{}
{

< SQL_ORA_CONVERT>(sql_char()< SQL_COMMA_CHAR > dest_char_set()[< SQL_COMMA_CHAR > source_char_set() ])
}
void corr() : 
{}
{

< SQL_ORA_CORR>(expr1()< SQL_COMMA_CHAR > expr2()) [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void correlation() : 
{}
{

( < CORR_K > | < CORR_S > )
   (expr1()< SQL_COMMA_CHAR > expr2()
     [< SQL_COMMA_CHAR > ( < COEFFICIENT >
        | < ONE_SIDED_SIG >
        | < ONE_SIDED_SIG_POS >
        | < ONE_SIDED_SIG_NEG >
        | < TWO_SIDED_SIG >
        )
     ]
   )
}
void cos() : 
{}
{

< SQL_ORA_COS>(n())
}
void cosh() : 
{}
{

< SQL_ORA_COSH>(n())
}
void count() : 
{}
{

< SQL_ORA_COUNT>(( <SQL_ASTERISKCHAR> | [ < SQL_DISTINCT> | < SQL_ALL> ] expr() )) [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void covar_pop() : 
{}
{

< SQL_ORA_COVAR_POP>(expr1()< SQL_COMMA_CHAR > expr2())
   [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void covar_samp() : 
{}
{

< SQL_ORA_COVAR_SAMP>(expr1()< SQL_COMMA_CHAR > expr2()) [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void cube_table() : 
{}
{

< CUBE_TABLE >
( < APOSTROPHE > ( schema()< SQL_PERIOD_CHAR >cube() ( ( < HIERARCHY >  | < HRR > ) dimension() hierarchy() )*
    | schema()< SQL_PERIOD_CHAR >dimension() [ ( < HIERARCHY > | < HRR >) [dimension()] hierarchy() ]
    )
  < APOSTROPHE >
)
}

void cume_dist() :
{}
{
	( cume_dist_aggregate() | cume_dist_analytic() )}

void cume_dist_aggregate() : 
{}
{

< SQL_ORA_CUME_DIST>(expr()(< SQL_COMMA_CHAR >expr() )*) < WITHIN> < SQL_GROUP>(< SQL_ORDER> < SQL_BY>expr() [ < SQL_DESC> | < SQL_ASC> ]
                 [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ] 
            (
              < SQL_COMMA_CHAR > expr() [ < SQL_DESC> | < SQL_ASC> ]
                    [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
         )*
  )
}
void cume_dist_analytic() : 
{}
{

< SQL_ORA_CUME_DIST><SQL_LPARENCHAR> <SQL_RPARENCHAR> < SQL_ORA_OVER> ([ query_partition_clause() ] order_by_clause())
}
void current_date() : 
{}
{

< SQL_ORA_CURRENT_DATE>
}
void current_timestamp() : 
{}
{

< SQL_ORA_CURRENT_TIMESTAMP> [ (precision()) ]
}
void cv() : 
{}
{

< SQL_ORA_CV>([ dimension_column() ])
}
void dataobj_to_partition() : 
{}
{

< DATAOBJ_TO_PARTITION >( table()< SQL_COMMA_CHAR > partition_id() )
}
void dbtimezone() : 
{}
{

< SQL_ORA_DBTIMEZONE>
}

void default_return() :
{}
{
	"default"
}

void decode() : 
{}
{

< SQL_ORA_DECODE>(expr()< SQL_COMMA_CHAR > search()< SQL_COMMA_CHAR > result() (< SQL_COMMA_CHAR > search()< SQL_COMMA_CHAR > result() )*  [< SQL_COMMA_CHAR > default_return() ])
}
void decompose() : 
{}
{

< SQL_ORA_DECOMPOSE>( string() [< SQL_COMMA_CHAR > ( < APOSTROPHE >< CANONICAL >< APOSTROPHE > | < APOSTROPHE >< COMPATIBILITY >< APOSTROPHE > ) ] )
}
void deletexml() : 
{}
{

< DELETEXML >( XMLType_instance()< SQL_COMMA_CHAR > XPath_string() [< SQL_COMMA_CHAR > namespace_string() ])
}

void dense_rank() :
{}
{
  dense_rank_aggregate() | dense_rank_analytic()}

void dense_rank_aggregate() : 
{}
{

< SQL_ORA_DENSE_RANK>(expr() (< SQL_COMMA_CHAR > expr() )*) < WITHIN> < SQL_GROUP>(< SQL_ORDER> < SQL_BY>expr() [ < SQL_DESC> | < SQL_ASC> ]
                 [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
            (
              < SQL_COMMA_CHAR >expr() [ < SQL_DESC> | < SQL_ASC> ]
                   [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
          )*
  )
}
void dense_rank_analytic() : 
{}
{

< SQL_ORA_DENSE_RANK><SQL_LPARENCHAR> <SQL_RPARENCHAR> < SQL_ORA_OVER>([ query_partition_clause() ] order_by_clause())
}
void depth() : 
{}
{

< SQL_ORA_DEPTH>(correlation_integer())
}
void deref() : 
{}
{

< SQL_ORA_DEREF>(expr())
}
void dump() : 
{}
{

< SQL_ORA_DUMP>(expr()[< SQL_COMMA_CHAR > return_fmt() [< SQL_COMMA_CHAR > start_position() [< SQL_COMMA_CHAR > length() ] ] ])
}
void empty_lob() : 
{}
{

( < SQL_ORA_EMPTY_BLOB> | < SQL_ORA_EMPTY_CLOB> )<SQL_LPARENCHAR> <SQL_RPARENCHAR>
}
void existsnode() : 
{}
{

< SQL_ORA_EXISTSNODE>(XMLType_instance()< SQL_COMMA_CHAR > XPath_string() [< SQL_COMMA_CHAR > namespace_string() ])
}
void exp() : 
{}
{

< SQL_ORA_EXP>(n())
}
void extract_datetime() : 
{}
{

< SQL_ORA_EXTRACT>( ( < YEAR >
         | < MONTH >
         | < DAY >
         | < HOUR >
         | < MINUTE >
         | < SECOND >
         | < TIMEZONE_HOUR >
         | < TIMEZONE_MINUTE >
         | < TIMEZONE_REGION >
         | < TIMEZONE_ABBR >
         )
         < SQL_FROM> ( expr() )
       )
}
void extract_xml() : 
{}
{

< SQL_ORA_EXTRACT>(XMLType_instance()< SQL_COMMA_CHAR > XPath_string() [< SQL_COMMA_CHAR > namespace_string() ])
}
void extractvalue() : 
{}
{

< SQL_ORA_EXTRACTVALUE>(XMLType_instance()< SQL_COMMA_CHAR > XPath_string() [< SQL_COMMA_CHAR > namespace_string() ])
}
void feature_details() : 
{}
{

< FEATURE_DETAILS > ( [ schema() < SQL_PERIOD_CHAR > ] model()
        [ < SQL_COMMA_CHAR > feature_id() [ < SQL_COMMA_CHAR > topN() ] ] [ DESC() | ASC() | ABS() ]
        mining_attribute_clause() )
}
void feature_details_analytic() : 
{}
{

< FEATURE_DETAILS >  ( INTO() n()
        [ < SQL_COMMA_CHAR > feature_id() [ < SQL_COMMA_CHAR > topN() ] ] [ DESC() | ASC() | ABS() ]
        mining_attribute_clause() )
        OVER() ( mining_analytic_clause() )
}



void feature_id() : 
{}
{

< FEATURE_ID >( [ schema() < SQL_PERIOD_CHAR > ] model() mining_attribute_clause() )
}
void feature_id_analytic() : 
{}
{

< FEATURE_ID >( INTO() n() mining_attribute_clause() )
                  OVER() ( mining_analytic_clause())
}


void feature_set() : 
{}
{

< FEATURE_SET >( [ schema() < SQL_PERIOD_CHAR > ] model() [< SQL_COMMA_CHAR > topN() [< SQL_COMMA_CHAR > cutoff() ] ] mining_attribute_clause() )
}
void feature_set_analytic() : 
{}
{

< FEATURE_SET >( INTO() n() [< SQL_COMMA_CHAR > topN() [< SQL_COMMA_CHAR > cutoff() ] ] mining_attribute_clause() )
                  ( OVER() mining_analytic_clause() )
}


void feature_value() : 
{}
{

< FEATURE_VALUE >( [ schema() < SQL_PERIOD_CHAR > ] model() [< SQL_COMMA_CHAR > feature_id() ] mining_attribute_clause() )
}
void feature_value_analytic() : 
{}
{

< FEATURE_VALUE >( INTO() n() [ < SQL_COMMA_CHAR > feature_id() ] mining_attribute_clause() )
                     OVER() ( mining_analytic_clause() )
}


void first() : 
{}
{
   < KEEP >
   ( < SQL_ORA_DENSE_RANK> < SQL_ORA_FIRST> < SQL_ORDER> < SQL_BY>
    expr() [ < SQL_DESC> | < SQL_ASC> ]
         [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
    (
      < SQL_COMMA_CHAR > expr() [ < SQL_DESC> | < SQL_ASC> ]
            [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
  )*
   )
   [ < SQL_ORA_OVER> ( [query_partition_clause()] ) ]
}
void first_value() : 
{}
{

< FIRST_VALUE > 
  ( (expr()) [ (< RESPECT > | < IGNORE >) NULLS() ]
  | (expr() [ (< RESPECT > | < IGNORE >) NULLS() ])
  )
  < SQL_ORA_OVER> (analytic_clause())
}
void floor() : 
{}
{

< SQL_ORA_FLOOR>(n())
}
void from_tz() : 
{}
{

< SQL_ORA_FROM_TZ>(timestamp_value()< SQL_COMMA_CHAR > time_zone_value())
}
void greatest() : 
{}
{

< SQL_ORA_GREATEST>(expr() (< SQL_COMMA_CHAR > expr() )*)
}
void group_id() : 
{}
{

< SQL_ORA_GROUP_ID><SQL_LPARENCHAR> <SQL_RPARENCHAR>
}
void grouping() : 
{}
{

< SQL_ORA_GROUPING><SQL_LPARENCHAR>expr()<SQL_RPARENCHAR>
}
void grouping_id() : 
{}
{

< SQL_ORA_GROUPING_ID>(expr() (< SQL_COMMA_CHAR > expr() )* )
}
void hextoraw() : 
{}
{

< SQL_ORA_HEXTORAW>(sql_char())
}
void initcap() : 
{}
{

< SQL_ORA_INITCAP>(sql_char())
}
void insertchildxml() : 
{}
{

< INSERTCHILDXML >
  ( XMLType_instance()< SQL_COMMA_CHAR > XPath_string()< SQL_COMMA_CHAR > child_expr()< SQL_COMMA_CHAR > value_expr() [< SQL_COMMA_CHAR > namespace_string() ])
}
void insertchildxmlafter() : 
{}
{

< INSERTCHILDXMLAFTER >
  ( XMLType_instance()< SQL_COMMA_CHAR > XPath_string()< SQL_COMMA_CHAR > child_expr()< SQL_COMMA_CHAR > value_expr() [< SQL_COMMA_CHAR > namespace_string() ] )
}
void insertchildxmlbefore() : 
{}
{

< INSERTCHILDXMLBEFORE >
  ( XMLType_instance()< SQL_COMMA_CHAR > XPath_string()< SQL_COMMA_CHAR > child_expr()< SQL_COMMA_CHAR > value_expr() [< SQL_COMMA_CHAR > namespace_string() ] )
}
void insertxmlafter() : 
{}
{

< INSERTXMLAFTER >
  ( XMLType_instance()< SQL_COMMA_CHAR > XPath_string()< SQL_COMMA_CHAR > value_expr() [< SQL_COMMA_CHAR > namespace_string() ] )
}
void insertxmlbefore() : 
{}
{

< INSERTXMLBEFORE >
  ( XMLType_instance()< SQL_COMMA_CHAR > XPath_string()< SQL_COMMA_CHAR > value_expr() [< SQL_COMMA_CHAR > namespace_string() ] )
}
void instr() : 
{}
{

( < SQL_ORA_INSTR>
| < INSTRB >
| < INSTRC >
| < INSTR2 >
| < INSTR4 >
)
(string() < SQL_COMMA_CHAR > substring() [< SQL_COMMA_CHAR > position() [< SQL_COMMA_CHAR > occurrence() ] ])
}
void iteration_number() : 
{}
{

< SQL_ORA_ITERATION_NUMBER>
}
void json_query() : 
{}
{

< JSON_QUERY >
  ( expr()< SQL_COMMA_CHAR > JSON_path_expression() [ JSON_query_returning_clause() ]
    [ JSON_query_wrapper_clause() ] [ JSON_query_on_error_clause() ]
  )
}



void json_query_returning_clause() : 
{}
{

[ < RETURNING > JSON_query_return_type() ] [ < PRETTY > ] [ < SQL_ORA_ASCII> ]
}
void json_query_return_type() : 
{}
{

< VARCHAR2 > [ ( size() [< BYTE > | < CHAR >] ) ]
}
void json_query_wrapper_clause() : 
{}
{

< WITHOUT > [ < ARRAY > ] < WRAPPER >
| < SQL_WITH> [ < UNCONDITIONAL > | < CONDITIONAL > ] [ < ARRAY > ] < WRAPPER >
}
void json_query_on_error_clause() : 
{}
{

( < ERROR > | < SQL_NULL> | < EMPTY > ) < SQL_ON> < ERROR>}
void json_table() : 
{}
{

< JSON_TABLE > ( expr()< SQL_COMMA_CHAR > JSON_path_expression()
  [ JSON_table_on_error_clause() ] JSON_columns_clause() )
}



void json_table_on_error_clause() : 
{}
{

( < ERROR > | < SQL_NULL> | < SQL_DEFAULT > literal() ) < SQL_ON> < ERROR>}
void json_columns_clause() : 
{}
{

< COLUMNS > ( JSON_column_definition() (< SQL_COMMA_CHAR > JSON_column_definition() )* )
}
void json_column_definition() : 
{}
{

JSON_exists_column()
| JSON_query_column()
| JSON_value_column()
| JSON_nested_path()
| ordinality_column()
}
void json_exists_column() : 
{}
{

column_name() JSON_value_return_type()
  < SQL_EXISTS> < SQL_ORA_PATH>JSON_path_expression() [ JSON_exists_on_error_clause() ]
}
void json_query_column() : 
{}
{

column_name() JSON_query_return_type()
  < FORMAT> < JSON>[ JSON_query_wrapper_clause() ]
  < SQL_ORA_PATH> JSON_path_expression() [ JSON_query_on_error_clause() ]
}
void json_value_column() : 
{}
{

column_name() JSON_value_return_type() < SQL_ORA_PATH> JSON_path_expression()
  [ JSON_value_on_error_clause() ]
}
void json_nested_path() : 
{}
{

< NESTED> < SQL_ORA_PATH>JSON_path_expression() JSON_columns_clause()
}
void ordinality_column() : 
{}
{

column_name() < FOR> < ORDINALITY>}
void json_value() : 
{}
{

< JSON_VALUE >
  ( expr()< SQL_COMMA_CHAR > JSON_path_expression() [ JSON_value_returning_clause() ]
    [ JSON_value_on_error_clause() ]
  )
}



void json_value_returning_clause() : 
{}
{

[ < RETURNING > JSON_value_return_type() ] [ < SQL_ORA_ASCII> ]
}
void json_value_return_type() : 
{}
{

( < VARCHAR2 > [ ( size() [< BYTE > | < CHAR >] ) ]
| < NUMBER > [ ( precision() [< SQL_COMMA_CHAR > scale()] ) ]
)
}
void json_value_on_error_clause() : 
{}
{

( < ERROR > | < SQL_NULL> | < SQL_DEFAULT > literal() ) < SQL_ON> < ERROR>}
void lag() : 
{}
{

< LAG >
  ( ( value_expr() [< SQL_COMMA_CHAR > offset() [< SQL_COMMA_CHAR > sql_default()]]) [ ( < RESPECT > | < IGNORE > ) < NULLS > ] 
  | ( value_expr() [ ( < RESPECT > | < IGNORE > ) < NULLS > ] [< SQL_COMMA_CHAR > offset() [< SQL_COMMA_CHAR > sql_default()]] )
  )
  < SQL_ORA_OVER> ([ query_partition_clause() ] order_by_clause())
}
void last() : 
{}
{

< KEEP >
  (< SQL_ORA_DENSE_RANK> < SQL_ORA_LAST> < SQL_ORDER> < SQL_BY>
    expr() [ < SQL_DESC> | < SQL_ASC> ]
         [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
    (
      < SQL_COMMA_CHAR > expr() [ < SQL_DESC> | < SQL_ASC> ]
            [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
   )*
  )
  [ < SQL_ORA_OVER> ( [query_partition_clause()] ) ]
}
void last_day() : 
{}
{

< SQL_ORA_LAST_DAY>(date())
}
void last_value() : 
{}
{

< LAST_VALUE >
(
  <SQL_LPARENCHAR> expr() <SQL_RPARENCHAR>  [ ( < RESPECT > | < IGNORE > ) NULLS() ]
  | <SQL_LPARENCHAR> expr() [ ( < RESPECT > | < IGNORE > ) NULLS() ] <SQL_RPARENCHAR>
)
  < SQL_ORA_OVER> <SQL_LPARENCHAR> analytic_clause() <SQL_RPARENCHAR>
}

void lead() : 
{}
{

< LEAD >
  ( ( value_expr() [< SQL_COMMA_CHAR > offset() [< SQL_COMMA_CHAR > sql_default()]] ) [ ( < RESPECT > | < IGNORE > ) < NULLS > ] 
  | ( value_expr() [ ( < RESPECT > | < IGNORE > ) < NULLS > ] [< SQL_COMMA_CHAR > offset() [< SQL_COMMA_CHAR > sql_default()]] )
  )
  < SQL_ORA_OVER> ([ query_partition_clause() ] order_by_clause())
}
void least() : 
{}
{

< SQL_ORA_LEAST>(expr() (< SQL_COMMA_CHAR > expr() )*)
}
void length() : 
{}
{

( < SQL_ORA_LENGTH>
| < SQL_ORA_LENGTHB>
| < LENGTHC >
| < LENGTH2 >
| < LENGTH4 >
)
(sql_char())
}
void listagg() : 
{}
{

< LISTAGG >(measure_expr() [< SQL_COMMA_CHAR > < APOSTROPHE >delimiter()< APOSTROPHE >])
  < WITHIN> < SQL_GROUP>(order_by_clause()) [< SQL_ORA_OVER> query_partition_clause()]
}
void ln() : 
{}
{

< SQL_ORA_LN>(n())
}
void lnnvl() : 
{}
{

< SQL_ORA_LNNVL>(condition())
}
void localtimestamp() : 
{}
{

< SQL_ORA_LOCALTIMESTAMP> [ (timestamp_precision()) ]
}
void log() : 
{}
{

< SQL_ORA_LOG>(n2()< SQL_COMMA_CHAR > n1())
}
void lower() : 
{}
{

< SQL_ORA_LOWER>(sql_char())
}
void lpad() : 
{}
{

< SQL_ORA_LPAD>(expr1()< SQL_COMMA_CHAR > n() [< SQL_COMMA_CHAR > expr2() ])
}
void ltrim() : 
{}
{

< SQL_ORA_LTRIM>(sql_char() [< SQL_COMMA_CHAR > set() ])
}
void make_ref() : 
{}
{

< SQL_ORA_MAKE_REF>(( table() | view() ) < SQL_COMMA_CHAR > key() (< SQL_COMMA_CHAR > key() )* )
}
void max() : 
{}
{

< SQL_ORA_MAX>([ < SQL_DISTINCT> | < SQL_ALL> ] expr()) [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void median() : 
{}
{

< SQL_ORA_MEDIAN>(expr()) [ < SQL_ORA_OVER> (query_partition_clause()) ]
}
void min() : 
{}
{

< SQL_ORA_MIN>([ < SQL_DISTINCT> | < SQL_ALL> ] expr()) [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void mod() : 
{}
{

< SQL_ORA_MOD>(n2()< SQL_COMMA_CHAR > n1())
}
void months_between() : 
{}
{

< SQL_ORA_MONTHS_BETWEEN>(date1()< SQL_COMMA_CHAR > date2())
}
void nanvl() : 
{}
{

< SQL_ORA_NANVL>(n2()< SQL_COMMA_CHAR > n1())
}
void nchr() : 
{}
{

< NCHR >(number())
}
void new_time() : 
{}
{

< SQL_ORA_NEW_TIME>(date()< SQL_COMMA_CHAR > timezone1()< SQL_COMMA_CHAR > timezone2())
}
void next_day() : 
{}
{

< SQL_ORA_NEXT_DAY>(date()< SQL_COMMA_CHAR > sql_char())
}
void nls_charset_decl_len() : 
{}
{

< SQL_ORA_NLS_CHARSET_DECL_LEN>(byte_count()< SQL_COMMA_CHAR > < APOSTROPHE >char_set_id()< APOSTROPHE >)
}
void nls_charset_id() : 
{}
{

< SQL_ORA_NLS_CHARSET_ID>(string())
}
void nls_charset_name() : 
{}
{

< SQL_ORA_NLS_CHARSET_NAME>(number())
}
void nls_initcap() : 
{}
{

< SQL_ORA_NLS_INITCAP>(sql_char() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ])
}
void nls_lower() : 
{}
{

< SQL_ORA_NLS_LOWER>(sql_char() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ])
}
void nls_upper() : 
{}
{

< SQL_ORA_NLS_UPPER>(sql_char() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ])
}
void nlssort() : 
{}
{

< SQL_ORA_NLSSORT>(sql_char() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ])
}
void nth_value() : 
{}
{

< NTH_VALUE  >(measure_expr()< SQL_COMMA_CHAR > n())
  [ < SQL_FROM> ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ][ ( < RESPECT > | < IGNORE > ) < NULLS > ] 
  < SQL_ORA_OVER> (analytic_clause())
}
void ntile() : 
{}
{

< SQL_ORA_NTILE>(expr()) < SQL_ORA_OVER> ([ query_partition_clause() ] order_by_clause())
}
void nullif() : 
{}
{

< SQL_ORA_NULLIF>(expr1()< SQL_COMMA_CHAR > expr2())
}
void numtodsinterval() : 
{}
{

< SQL_ORA_NUMTODSINTERVAL>(n()< SQL_COMMA_CHAR > < APOSTROPHE >interval_unit()< APOSTROPHE >)
}
void numtoyminterval() : 
{}
{

< SQL_ORA_NUMTOYMINTERVAL>(n()< SQL_COMMA_CHAR > < APOSTROPHE >interval_unit()< APOSTROPHE >)
}
void nvl() : 
{}
{

< SQL_ORA_NVL>(expr1()< SQL_COMMA_CHAR > expr2())
}
void nvl2() : 
{}
{

< SQL_ORA_NVL2>(expr1()< SQL_COMMA_CHAR > expr2()< SQL_COMMA_CHAR > expr3())
}
void ora_dst_affected() : 
{}
{

< ORA_DST_AFFECTED >(datetime_expr())
}
void ora_dst_convert() : 
{}
{

< ORA_DST_CONVERT >(datetime_expr() [< SQL_COMMA_CHAR > integer() [< SQL_COMMA_CHAR > integer() ]])
}
void ora_dst_error() : 
{}
{

< ORA_DST_ERROR >(datetime_expr())
}
void ora_hash() : 
{}
{

< SQL_ORA_ORA_HASH>(expr() [< SQL_COMMA_CHAR > max_bucket() [< SQL_COMMA_CHAR > seed_value() ] ])
}
void ora_invoking_user() : 
{}
{

< ORA_INVOKING_USER >
}
void ora_invoking_userid() : 
{}
{

< ORA_INVOKING_USERID >
}
void path() : 
{}
{

< SQL_ORA_PATH>(correlation_integer())
}

void percent_rank() :
{}
{
  percent_rank_aggregate() | percent_rank_analytic()}

void percent_rank_aggregate() : 
{}
{

< SQL_ORA_PERCENT_RANK>(expr() ( < SQL_COMMA_CHAR > expr() )* ) < WITHIN> < SQL_GROUP>(< SQL_ORDER> < SQL_BY>expr() [ < SQL_DESC> | < SQL_ASC> ]
         [< NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
    (
      < SQL_COMMA_CHAR > expr() [ < SQL_DESC> | < SQL_ASC> ]
            [< NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
  )*
   )
}
void percent_rank_analytic() : 
{}
{

   < SQL_ORA_PERCENT_RANK><SQL_LPARENCHAR> <SQL_RPARENCHAR>
   < SQL_ORA_OVER> ([ query_partition_clause() ] order_by_clause())
}
void percentile_cont() : 
{}
{

< SQL_ORA_PERCENTILE_CONT>(expr()) < WITHIN> < SQL_GROUP>(< SQL_ORDER> < SQL_BY>expr() [ < SQL_DESC> | < SQL_ASC> ])
   [ < SQL_ORA_OVER> (query_partition_clause()) ]
}
void percentile_disc() : 
{}
{

< SQL_ORA_PERCENTILE_DISC>(expr()) < WITHIN> < SQL_GROUP>(< SQL_ORDER> < SQL_BY>expr() [ < SQL_DESC> | < SQL_ASC> ])
   [ < SQL_ORA_OVER> (query_partition_clause()) ]
}
void power() : 
{}
{

< SQL_ORA_POWER>(n2()< SQL_COMMA_CHAR > n1())
}
void powermultiset() : 
{}
{

< SQL_ORA_POWERMULTISET>(expr())
}
void powermultiset_by_cardnlty() : 
{}
{

< SQL_ORA_POWERMULTISET_BY_CARDINALITY>(expr()< SQL_COMMA_CHAR > cardinality())
}
void prediction() : 
{}
{

< PREDICTION > ( [ schema() < SQL_PERIOD_CHAR > ] model() [ cost_matrix_clause() ] mining_attribute_clause() )
}
void prediction_analytic() : 
{}
{

< PREDICTION > ( ( OF() ANOMALY() | FOR() expr() ) [ cost_matrix_clause() ] mining_attribute_clause() )
                   OVER() ( mining_analytic_clause() )
}
void cost_matrix_clause() : 
{}
{

< COST >
  ( < MODEL > [< AUTO >]
  | ( class_value() ( < SQL_COMMA_CHAR > class_value() )* )
        < SQL_VALUES> ( ( cost_value() (< SQL_COMMA_CHAR > cost_value() )*) 
                 ( < SQL_COMMA_CHAR > (cost_value() (< SQL_COMMA_CHAR > cost_value() )* ) )*
               )
  )
}


void prediction_bounds() : 
{}
{

< PREDICTION_BOUNDS >
( [schema()< SQL_PERIOD_CHAR >] model()
  [< SQL_COMMA_CHAR > confidence_level() [< SQL_COMMA_CHAR > class_value()]]
  mining_attribute_clause()
)
}

void prediction_cost() : 
{}
{

< PREDICTION_COST > ( [ schema() < SQL_PERIOD_CHAR > ] model() [ < SQL_COMMA_CHAR > sql_class() ] cost_matrix_clause()
 mining_attribute_clause() )
}
void prediction_cost_analytic() : 
{}
{

< PREDICTION_COST > ( ( OF() ANOMALY() | FOR() expr() ) [ < SQL_COMMA_CHAR > sql_class() ] cost_matrix_clause()
 mining_attribute_clause() )
 OVER() (mining_analytic_clause())
}



void prediction_details() : 
{}
{

< PREDICTION_DETAILS > ( [ schema() < SQL_PERIOD_CHAR > ] model() 
                      [ < SQL_COMMA_CHAR > class_value() [ < SQL_COMMA_CHAR > topN() ] ] [ DESC() | ASC() | ABS() ]
                       mining_attribute_clause() )
}
void prediction_details_analytic() : 
{}
{

< PREDICTION_DETAILS > ( ( OF() ANOMALY() | FOR() expr() )
     [ < SQL_COMMA_CHAR > class_value() [ < SQL_COMMA_CHAR > topN() ] ] [ DESC() | ASC() | ABS() ]
      mining_attribute_clause() )
      OVER() ( mining_analytic_clause() )
}




void prediction_probability() : 
{}
{

< PREDICTION_PROBABILITY > ( [ schema() < SQL_PERIOD_CHAR > ] model() [ < SQL_COMMA_CHAR > sql_class() ] 
   mining_attribute_clause() )
}
void prediction_prob_analytic() : 
{}
{

< PREDICTION_PROBABILITY > (  ( OF() ANOMALY() | FOR() expr() )
   [ < SQL_COMMA_CHAR > sql_class() ]
   mining_attribute_clause() )
   OVER() (mining_analytic_clause() )
}



void prediction_set() : 
{}
{

< PREDICTION_SET > ( [ schema() < SQL_PERIOD_CHAR > ] model() [ < SQL_COMMA_CHAR > bestN() [ < SQL_COMMA_CHAR > cutoff() ] ] 
  [ cost_matrix_clause() ] mining_attribute_clause() )
}
void prediction_set_analytic() : 
{}
{

< PREDICTION_SET > ( ( OF() ANOMALY() | FOR() "expr()" ) [ < SQL_COMMA_CHAR > bestN() [ < SQL_COMMA_CHAR > cutoff() ] ]
                     [ cost_matrix_clause() ] mining_attribute_clause() )
                      OVER() ( mining_analytic_clause() )
}




void presentnnv() : 
{}
{

< SQL_ORA_PRESENTNNV>(cell_reference()< SQL_COMMA_CHAR > expr1()< SQL_COMMA_CHAR > expr2())
}
void presentv() : 
{}
{

< SQL_ORA_PRESENTV>(cell_reference()< SQL_COMMA_CHAR > expr1()< SQL_COMMA_CHAR > expr2())
}
void previous() : 
{}
{

< SQL_ORA_PREVIOUS>(cell_reference())
}

void rank() :
{}
{
  rank_aggregate() | rank_analytic()}

void rank_aggregate() : 
{}
{

< SQL_ORA_RANK>(expr() (< SQL_COMMA_CHAR > expr() )*) < WITHIN> < SQL_GROUP>(< SQL_ORDER> < SQL_BY>expr() [ < SQL_DESC> | < SQL_ASC> ]
         [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
    (
      < SQL_COMMA_CHAR > expr() [ < SQL_DESC> | < SQL_ASC> ]
            [ < NULLS > ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) ]
  )*
   )
}
void rank_analytic() : 
{}
{

< SQL_ORA_RANK><SQL_LPARENCHAR> <SQL_RPARENCHAR>
   < SQL_ORA_OVER> ([ query_partition_clause() ] order_by_clause())
}
void ratio_to_report() : 
{}
{

< SQL_ORA_RATIO_TO_REPORT>(expr())
   < SQL_ORA_OVER> ([ query_partition_clause() ])
}
void rawtohex() : 
{}
{

< SQL_ORA_RAWTOHEX>(raw())
}
void rawtonhex() : 
{}
{

< SQL_ORA_RAWTONHEX>(raw())
}
void ref() : 
{}
{

< SQL_ORA_REF> (correlation_variable())
}
void reftohex() : 
{}
{

< SQL_ORA_REFTOHEX> (expr())
}
void regexp_count() : 
{}
{

< REGEXP_COUNT > (source_char()< SQL_COMMA_CHAR > pattern() [< SQL_COMMA_CHAR > position() [< SQL_COMMA_CHAR > match_param()]])
}
void regexp_instr() : 
{}
{

< SQL_ORA_REGEXP_INSTR> <SQL_LPARENCHAR> source_char()< SQL_COMMA_CHAR > pattern()
              [< SQL_COMMA_CHAR > position()
                 [< SQL_COMMA_CHAR > occurrence()
                    [< SQL_COMMA_CHAR > return_opt()
                       [< SQL_COMMA_CHAR > match_param()
                          [< SQL_COMMA_CHAR > subexpr()]
                       ]
                    ]
                 ]
              ]
              <SQL_RPARENCHAR>
}
void regexp_replace() : 
{}
{

< SQL_ORA_REGEXP_REPLACE>(source_char()< SQL_COMMA_CHAR > pattern()
               [< SQL_COMMA_CHAR > replace_string()
                  [< SQL_COMMA_CHAR > position()
                     [< SQL_COMMA_CHAR > occurrence()
                        [< SQL_COMMA_CHAR > match_param() ]
                     ]
                  ]
               ]
              )
}
void regexp_substr() : 
{}
{

< SQL_ORA_REGEXP_SUBSTR>(source_char()< SQL_COMMA_CHAR > pattern()
              [< SQL_COMMA_CHAR > position()
                 [< SQL_COMMA_CHAR > occurrence()
                    [< SQL_COMMA_CHAR > match_param()
                       [< SQL_COMMA_CHAR > subexpr()
                       ]
                    ]
                 ]
              ]
             )
}
void linear_regr() : 
{}
{

( < REGR_SLOPE > 
| < REGR_INTERCEPT > 
| < REGR_COUNT > 
| < REGR_R2 > 
| < REGR_AVGX >
| < REGR_AVGY > 
| < REGR_SXX > 
| < REGR_SYY > 
| < REGR_SXY >
)
(expr1() < SQL_COMMA_CHAR > expr2())
[ < SQL_ORA_OVER> (analytic_clause()) ]
}
void remainder() : 
{}
{

< SQL_ORA_REMAINDER>(n2()< SQL_COMMA_CHAR > n1())
}
void replace() : 
{}
{

< SQL_REPLACE>(sql_char()< SQL_COMMA_CHAR > search_string()
        [< SQL_COMMA_CHAR > replacement_string() ]
       )
}
void round_date() : 
{}
{

< SQL_ORA_ROUND>(date() [< SQL_COMMA_CHAR > fmt() ])
}
void round_number() : 
{}
{

< SQL_ORA_ROUND>(n() [< SQL_COMMA_CHAR > integer() ])
}
void row_number() : 
{}
{

< ROW_NUMBER ><SQL_LPARENCHAR> <SQL_RPARENCHAR>
   < SQL_ORA_OVER> ([ query_partition_clause() ] order_by_clause())
}
void rowidtochar() : 
{}
{

< SQL_ORA_ROWIDTOCHAR>(rowid())
}
void rowidtonchar() : 
{}
{

< SQL_ORA_ROWIDTONCHAR>(rowid())
}
void rpad() : 
{}
{

< SQL_ORA_RPAD>(expr1() < SQL_COMMA_CHAR > n() [< SQL_COMMA_CHAR > expr2() ])
}
void rtrim() : 
{}
{

< SQL_ORA_RTRIM>(sql_char() [< SQL_COMMA_CHAR > set() ])
}
void scn_to_timestamp() : 
{}
{

< SQL_ORA_SCN_TO_TIMESTAMP>(number())
}
void sessiontimezone() : 
{}
{

< SQL_ORA_SESSIONTIMEZONE>
}
void set() : 
{}
{

< SQL_SET> (nested_table())
}
void sign() : 
{}
{

< SQL_ORA_SIGN>(n())
}
void sin() : 
{}
{

< SQL_ORA_SIN>(n())
}
void sinh() : 
{}
{

< SQL_ORA_SINH>(n())
}
void soundex() : 
{}
{

< SQL_ORA_SOUNDEX><SQL_LPARENCHAR> sql_char() <SQL_RPARENCHAR>
}
void sqrt() : 
{}
{

< SQL_ORA_SQRT><SQL_LPARENCHAR> n() <SQL_RPARENCHAR>
}
void standard_hash() : 
{}
{

< STANDARD_HASH >(expr() [< SQL_COMMA_CHAR > < APOSTROPHE >method()< APOSTROPHE > ])
}
void stats_binomial_test() : 
{}
{

< SQL_ORA_STATS_BINOMIAL_TEST>(expr1()< SQL_COMMA_CHAR > expr2()< SQL_COMMA_CHAR > p()
                    [< SQL_COMMA_CHAR > ( < TWO_SIDED_PROB >
                       | < EXACT_PROB >
                       | < ONE_SIDED_PROB_OR_MORE >
                       | < ONE_SIDED_PROB_OR_LESS >
                       )
                    ]
                   )
}
void stats_crosstab() : 
{}
{

< SQL_ORA_STATS_CROSSTAB>(expr1()< SQL_COMMA_CHAR > expr2()
               [< SQL_COMMA_CHAR > ( < CHISQ_OBS >
                  | < CHISQ_SIG >
                  | < CHISQ_DF >
                  | < PHI_COEFFICIENT >
                  | < CRAMERS_V >
                  | < CONT_COEFFICIENT >
                  | < COHENS_K >
                  )
               ]
              )
}
void stats_f_test() : 
{}
{

< SQL_ORA_STATS_F_TEST>(expr1()< SQL_COMMA_CHAR > expr2()
             [< SQL_COMMA_CHAR > ( ( < STATISTIC >
                  | < DF_NUM >
                  | < DF_DEN >
                  | < ONE_SIDED_SIG >
                  ) < SQL_COMMA_CHAR > expr3()
                | < TWO_SIDED_SIG >
                )
             ]
            )
}
void stats_ks_test() : 
{}
{

< SQL_ORA_STATS_KS_TEST>(expr1()< SQL_COMMA_CHAR > expr2()
              [< SQL_COMMA_CHAR > ( < STATISTIC > | < SIG > ) ]
             )
}
void stats_mode() : 
{}
{

< SQL_ORA_STATS_MODE>(expr())
}
void stats_mw_test() : 
{}
{

< SQL_ORA_STATS_MW_TEST>(expr1()< SQL_COMMA_CHAR > expr2()
              [< SQL_COMMA_CHAR > ( < STATISTIC >
                 | < U_STATISTIC >
                 | < ONE_SIDED_SIG > < SQL_COMMA_CHAR > expr3()
                 | < TWO_SIDED_SIG >
                 )
              ]
             )
}
void stats_one_way_anova() : 
{}
{

< SQL_ORA_STATS_ONE_WAY_ANOVA>(expr1()< SQL_COMMA_CHAR > expr2()
                    [< SQL_COMMA_CHAR > ( < SUM_SQUARES_BETWEEN >
                       | < SUM_SQUARES_WITHIN >
                       | < DF_BETWEEN >
                       | < DF_WITHIN >
                       | < MEAN_SQUARES_BETWEEN >
                       | < MEAN_SQUARES_WITHIN >
                       | < F_RATIO >
                       | < SIG >
                       )
                    ]
                   )
}
void stats_t_test() : 
{}
{
(
  < STATS_T_TEST_ONE > <SQL_LPARENCHAR> expr1() [< SQL_COMMA_CHAR > expr2() ]
|
  ( ( < STATS_T_TEST_PAIRED >
    | < STATS_T_TEST_INDEP >
    | < STATS_T_TEST_INDEPU >
    ) <SQL_LPARENCHAR> expr1()< SQL_COMMA_CHAR > expr2() <SQL_RPARENCHAR>
  )
)
[< SQL_COMMA_CHAR > ( ( < STATISTIC > | < ONE_SIDED_SIG > ) < SQL_COMMA_CHAR > expr3() | < TWO_SIDED_SIG > | < DF > ) ] <SQL_RPARENCHAR>

}
void stats_wsr_test() : 
{}
{

< SQL_ORA_STATS_WSR_TEST>(expr1()< SQL_COMMA_CHAR > expr2()
               [< SQL_COMMA_CHAR > ( < STATISTIC >
                  | < ONE_SIDED_SIG >
                  | < TWO_SIDED_SIG >
                  )
               ]
              )
}
void stddev() : 
{}
{

< SQL_ORA_STDDEV>([ < SQL_DISTINCT> | < SQL_ALL> ] expr())
   [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void stddev_pop() : 
{}
{

< SQL_ORA_STDDEV_POP>(expr())
   [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void stddev_samp() : 
{}
{

< SQL_ORA_STDDEV_SAMP>(expr())
   [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void substr() : 
{}
{

( < SQL_ORA_SUBSTR>
| < SQL_ORA_SUBSTRB>
| < SUBSTRC >
| < SUBSTR2 >
| < SUBSTR4 >
)
(sql_char()< SQL_COMMA_CHAR > position() [< SQL_COMMA_CHAR > substring_length() ])
}
void sum() : 
{}
{

< SQL_ORA_SUM>([ < SQL_DISTINCT> | < SQL_ALL> ] expr())
   [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void sys_connect_by_path() : 
{}
{

< SQL_ORA_SYS_CONNECT_BY_PATH>(column()< SQL_COMMA_CHAR > sql_char())
}
void sys_context() : 
{}
{

< SQL_ORA_SYS_CONTEXT>(< APOSTROPHE >namespace()< APOSTROPHE >< SQL_COMMA_CHAR > < APOSTROPHE >parameter()< APOSTROPHE > [< SQL_COMMA_CHAR > length() ])
}
void sys_dburigen() : 
{}
{

< SQL_ORA_SYS_DBURIGEN>(( column() | attribute() )
             [ rowid() ]
               (
                 < SQL_COMMA_CHAR > ( column() | attribute() )
                  [ rowid() ]
             )*
             [< SQL_COMMA_CHAR > < APOSTROPHE >text() <SQL_LPARENCHAR> <SQL_RPARENCHAR> < APOSTROPHE > ]
            )
}
void sys_extract_utc() : 
{}
{

< SQL_ORA_SYS_EXTRACT_UTC>(datetime_with_timezone())
}
void sys_guid() : 
{}
{

< SQL_ORA_SYS_GUID><SQL_LPARENCHAR> <SQL_RPARENCHAR>
}
void sys_op_zone_id() : 
{}
{

< SYS_OP_ZONE_ID >( [ [ schema()< SQL_PERIOD_CHAR > ] table()< SQL_PERIOD_CHAR > | t_alias()< SQL_PERIOD_CHAR > ] rowid() [< SQL_COMMA_CHAR > scale() ] )
}
void sys_typeid() : 
{}
{

< SQL_ORA_SYS_TYPEID>(object_type_value())
}
void sys_xmlagg() : 
{}
{

< SQL_ORA_SYS_XMLAGG>(expr() [< SQL_COMMA_CHAR > fmt() ])
}
void sys_xmlgen() : 
{}
{

< SQL_ORA_SYS_XMLGEN>(expr() [< SQL_COMMA_CHAR > fmt() ])
}
void sysdate() : 
{}
{

< SQL_ORA_SYSDATE>
}
void systimestamp() : 
{}
{

< SQL_ORA_SYSTIMESTAMP>
}
void tan() : 
{}
{

< SQL_ORA_TAN>(n())
}
void tanh() : 
{}
{

< SQL_ORA_TANH>(n())
}
void timestamp_to_scn() : 
{}
{

< SQL_ORA_TIMESTAMP_TO_SCN>(timestamp())
}
void to_binary_double() : 
{}
{

< SQL_ORA_TO_BINARY_DOUBLE>(expr() [< SQL_COMMA_CHAR > fmt() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ])
}
void to_binary_float() : 
{}
{

< SQL_ORA_TO_BINARY_FLOAT>(expr() [< SQL_COMMA_CHAR > fmt() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ])
}
void to_blob() : 
{}
{

< TO_BLOB > ( raw_value() )
}
void to_char_char() : 
{}
{

< SQL_ORA_TO_CHAR>(nchar() | clob() | nclob())
}
void to_char_date() : 
{}
{
< SQL_ORA_TO_CHAR> <SQL_LPARENCHAR> (<SQL_IDENTIFIER> | < SQL_ORA_SYSDATE >| interval() )  [< SQL_COMMA_CHAR > <SQL_CHAR_LITERAL> [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ] <SQL_RPARENCHAR>
}
void to_char_number() : 
{}
{

< SQL_ORA_TO_CHAR>(n() [< SQL_COMMA_CHAR > fmt() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ])
}
void to_clob() : 
{}
{

< SQL_ORA_TO_CLOB>(lob_column() | sql_char())
}
void to_date() : 
{}
{

< SQL_ORA_TO_DATE>(sql_char() [< SQL_COMMA_CHAR > fmt() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ])
}
void to_dsinterval() : 
{}
{

< SQL_ORA_TO_DSINTERVAL> ( < APOSTROPHE > ( sql_format() | ds_iso_format() ) < APOSTROPHE > )
}
void sql_format() : 
{}
{
[<SQL_PLUSCHAR> | <SQL_MINUSCHAR>] days() hours() ":" minutes() ":" seconds() [< SQL_PERIOD_CHAR > frac_secs() ]
}
void ds_iso_format() : 
{}
{

[<SQL_MINUSCHAR>] < P > [days() < D >]
  [< T > [hours() < H >] [minutes() < M >] [seconds() [< SQL_PERIOD_CHAR > frac_secs()] < S > ] ]
}
void to_lob() : 
{}
{

< SQL_ORA_TO_LOB>(long_column())
}
void to_multi_byte() : 
{}
{

< SQL_ORA_TO_MULTI_BYTE>(sql_char())
}
void to_nchar_char() : 
{}
{

< SQL_ORA_TO_NCHAR>((sql_char() | clob() | nclob()))
}
void to_nchar_date() : 
{}
{

< SQL_ORA_TO_NCHAR>(( datetime() | interval() )
         [< SQL_COMMA_CHAR > fmt() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ]
        )
}
void to_nchar_number() : 
{}
{

< SQL_ORA_TO_NCHAR>(n() [< SQL_COMMA_CHAR > fmt() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ])
}
void to_nclob() : 
{}
{

< SQL_ORA_TO_NCLOB>(lob_column() | sql_char())
}
void to_number() : 
{}
{

< SQL_ORA_TO_NUMBER>(expr() [< SQL_COMMA_CHAR > fmt() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ])
}
void to_single_byte() : 
{}
{

< SQL_ORA_TO_SINGLE_BYTE>(sql_char())
}
void to_timestamp() : 
{}
{

< SQL_ORA_TO_TIMESTAMP>(sql_char() [< SQL_COMMA_CHAR > fmt() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ])
}
void to_timestamp_tz() : 
{}
{

< SQL_ORA_TO_TIMESTAMP_TZ>(sql_char() [< SQL_COMMA_CHAR > fmt() [< SQL_COMMA_CHAR > < APOSTROPHE >nlsparam()< APOSTROPHE > ] ])
}
void to_yminterval() : 
{}
{

< SQL_ORA_TO_YMINTERVAL>
  ( < APOSTROPHE >  ( [<SQL_PLUSCHAR>|<SQL_MINUSCHAR>] years() <SQL_MINUSCHAR> months() 
       | ym_iso_format() 
       ) < APOSTROPHE > )
}
void ym_iso_format() : 
{}
{

[<SQL_MINUSCHAR>] < P > [ years() < Y > ] [months() < M >] [days() < D >]
  [< T > [hours() < H >] [minutes() < M >] [seconds() [< SQL_PERIOD_CHAR > frac_secs()] < S > ] ]
}
void translate() : 
{}
{

< SQL_ORA_TRANSLATE>(expr()< SQL_COMMA_CHAR > from_string()< SQL_COMMA_CHAR > to_string())
}
void translate_using() : 
{}
{

< SQL_ORA_TRANSLATE> ( sql_char() < SQL_USING>
          ( < CHAR_CS > | < NCHAR_CS > )
          )
}
void treat() : 
{}
{

< SQL_ORA_TREAT>(expr() < SQL_AS> [ < SQL_ORA_REF> ] [ schema()< SQL_PERIOD_CHAR > ]type())
}
void trim() : 
{}
{

< SQL_ORA_TRIM>([ ( ( < LEADING > | < TRAILING > | < BOTH > )
         [ trim_character() ]
       | trim_character()
       )
       < SQL_FROM> 
     ]
     trim_source()
    )
}
void trunc_date() : 
{}
{

< SQL_ORA_TRUNC>(date() [< SQL_COMMA_CHAR > fmt() ])
}
void trunc_number() : 
{}
{

< SQL_ORA_TRUNC>(n1() [< SQL_COMMA_CHAR > n2() ])
}
void tz_offset() : 
{}
{

< SQL_ORA_TZ_OFFSET>(( < APOSTROPHE >time_zone_name()< APOSTROPHE >
          | < APOSTROPHE >( <SQL_PLUSCHAR> | <SQL_MINUSCHAR> ) hh() ":" mi()< APOSTROPHE >
          | < SQL_ORA_SESSIONTIMEZONE>
          | < DBTMEZONE >
          )
         )
}
void uid() : 
{}
{

< SQL_ORA_UID>
}
void unistr() : 
{}
{

< SQL_ORA_UNISTR>( string() )
}
void updatexml() : 
{}
{

< SQL_ORA_UPDATEXML>
      (XMLType_instance()< SQL_COMMA_CHAR >
        XPath_string()< SQL_COMMA_CHAR > value_expr()
          (
            < SQL_COMMA_CHAR > XPath_string()< SQL_COMMA_CHAR > value_expr() )*
        [< SQL_COMMA_CHAR > namespace_string() ]
      )
}
void upper() : 
{}
{

< SQL_ORA_UPPER><SQL_LPARENCHAR>sql_char()<SQL_RPARENCHAR>
}
void user() : 
{}
{

< SQL_ORA_USER>
}
void userenv() : 
{}
{

< SQL_ORA_USERENV>(< APOSTROPHE >parameter()< APOSTROPHE >)
}
void value() : 
{}
{

< SQL_ORA_VALUE>(correlation_variable())
}
void var_pop() : 
{}
{

< SQL_ORA_VAR_POP>(expr()) [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void var_samp() : 
{}
{

< SQL_ORA_VAR_SAMP>(expr()) [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void variance() : 
{}
{

< SQL_ORA_VARIANCE>([ < SQL_DISTINCT> | < SQL_ALL> ] expr())
        [ < SQL_ORA_OVER> (analytic_clause()) ]
}
void vsize() : 
{}
{

< SQL_ORA_VSIZE>(expr())
}
void width_bucket() : 
{}
{

< SQL_ORA_WIDTH_BUCKET>
   (expr()< SQL_COMMA_CHAR > min_value()< SQL_COMMA_CHAR > max_value()< SQL_COMMA_CHAR > num_buckets())
}
void xmlagg() : 
{}
{

< SQL_ORA_XMLAGG>(XMLType_instance() [ order_by_clause() ])
}
void xmlcast() : 
{}
{

< XMLCAST > ( value_expression() < SQL_AS> datatype() )
}
void xmlcdata() : 
{}
{

< XMLCDATA > ( value_expr() )
}
void xmlcolattval() : 
{}
{

< SQL_ORA_XMLCOLATTVAL>
  (value_expr() [ < SQL_AS> ( c_alias()  | < EVALNAME > value_expr() ) ]
    (
      < SQL_COMMA_CHAR > value_expr() [ < SQL_AS> ( c_alias()  | < EVALNAME > value_expr() ) ]
    )*
  )
}
void xmlcomment() : 
{}
{

< XMLCOMMENT > ( value_expr() )
}
void xmlconcat() : 
{}
{

< SQL_ORA_XMLCONCAT>(XMLType_instance() ( < SQL_COMMA_CHAR > XMLType_instance() )* )
}
void xmldiff() : 
{}
{

< XMLDIFF > ( XMLType_document()< SQL_COMMA_CHAR > XMLType_document() [ < SQL_COMMA_CHAR > integer()< SQL_COMMA_CHAR > string() ] )
}
void xmlelement() : 
{}
{

< XMLELEMENT >
 ( [ < ENTITYESCAPING > | < NOENTITYESCAPING > ]
   [ < NAME > ]
     ( identifier()
     | < EVALNAME > value_expr()
     )
   [< SQL_COMMA_CHAR > XML_attributes_clause() ]
   (
     < SQL_COMMA_CHAR > value_expr() [ [< SQL_AS>] c_alias() ])*
 )
}
void xml_attributes_clause() : 
{}
{

< XMLATTRIBUTES >
  [ < ENTITYESCAPING > | < NOENTITYESCAPING > ]
  [ < SCHEMACHECK > | < NOSCHEMACHECK > ]
value_expr() [ ( [< SQL_AS>] c_alias() ) | ( < SQL_AS> < EVALNAME>value_expr() ) ]
  (
    < SQL_COMMA_CHAR > value_expr() [ ( [< SQL_AS>] c_alias() ) | ( < SQL_AS> < EVALNAME>value_expr() ) ]
  )*
}
void xmlexists() : 
{}
{

< XMLEXISTS > ( XQuery_string() [ XML_passing_clause() ] )
}
void xml_passing_clause() : 
{}
{

< PASSING > [ < SQL_BY> < SQL_ORA_VALUE>] 
    expr() [ < SQL_AS> identifier() ]
      (
        < SQL_COMMA_CHAR > expr() [ < SQL_AS> identifier() ] 
    )*
}
void xmlforest() : 
{}
{

< SQL_ORA_XMLFOREST>
  ( value_expr() [ < SQL_AS> ( c_alias() | EVALNAME() value_expr() ) ]
    (
      < SQL_COMMA_CHAR > value_expr() [ < SQL_AS> ( c_alias() | EVALNAME() value_expr() ) ]
    )*
  )
}
void xmlisvalid() : 
{}
{

< XMLISVALID > ( XMLType_instance() [< SQL_COMMA_CHAR > XMLSchema_URL() [< SQL_COMMA_CHAR > element() ]] )
}
void xmlparse() : 
{}
{

< XMLPARSE >
  (( < DOCUMENT > | < CONTENT > ) value_expr() [ < WELLFORMED > ]
  )
}
void xmlpatch() : 
{}
{

< XMLPATCH > ( XMLType_document()< SQL_COMMA_CHAR > XMLType_document() )
}
void xmlpi() : 
{}
{

< XMLPI >
 ( ( [ < NAME > ] identifier()
   | < EVALNAME > value_expr()
   ) [< SQL_COMMA_CHAR > value_expr() ]
 )
}
void xmlquery() : 
{}
{

< XMLQUERY >
 ( XQuery_string() 
   [ XML_passing_clause() ] 
   < RETURNING > <CONTENT > [ < SQL_NULL> < SQL_ON> <EMPTY > ]  
 )
}
 
void xmlroot() : 
{}
{

< XMLROOT >
  ( value_expr()< SQL_COMMA_CHAR > < VERSION > 
  ( value_expr() | < NO> < SQL_ORA_VALUE>)
  [< SQL_COMMA_CHAR > < STANDALONE > ( < YES > | < NO > | < NO> < SQL_ORA_VALUE>) ]
  )
}
void xmlsequence() : 
{}
{

< SQL_ORA_XMLSEQUENCE>( XMLType_instance()
           | sys_refcursor_instance() [< SQL_COMMA_CHAR > fmt() ]
           )
}
void xmlserialize() : 
{}
{

< XMLSERIALIZE >
  ( ( < DOCUMENT > | < CONTENT > ) value_expr() [ < SQL_AS> datatype() ]
    [ < ENCODING > xml_encoding_spec() ]
    [ < VERSION > string_literal() ]
    [ < NO> < INDENT>| ( < INDENT > [< SIZE > <ESQL_EQ> number()] ) ]
    [ ( < HIDE > | < SHOW > ) < DEFAULTS > ]
  )
}
void xmltable() : 
{}
{

< XMLTABLE >
 ( 
  [ XMLnamespaces_clause() < SQL_COMMA_CHAR > ] XQuery_string() XMLTABLE_options() 
 )
}
void xml_namespaces_clause() : 
{}
{
< XMLNAMESPACES >
  <SQL_LPARENCHAR> 
    [ string() < SQL_AS> identifier() ] ( < SQL_COMMA_CHAR > string() < SQL_AS> identifier()  )* 
    [ < SQL_DEFAULT > string() ]
  <SQL_RPARENCHAR>
}
void xmltable_options() : 
{}
{

[ XML_passing_clause() ]
[ < RETURNING > <SEQUENCE > < SQL_BY> < SQL_ORA_REF> ]
[ < COLUMNS > XML_table_column() (< SQL_COMMA_CHAR > XML_table_column())* ]
}
 
void xml_table_column() : 
{}
{

column()
  ( < FOR> < ORDINALITY>| ( datatype() | < XMLTYPE > [ (< SEQUENCE >) < SQL_BY> < SQL_ORA_REF>] )
    [ < SQL_ORA_PATH> string() ] [ < SQL_DEFAULT > expr() ]
  )
}
void xmltransform() : 
{}
{

< SQL_ORA_XMLTRANSFORM>(XMLType_instance()< SQL_COMMA_CHAR > ( XMLType_instance()
                               | string()
                               )
                   )
}
void user_defined_function() : 
{}
{
[ schema()< SQL_PERIOD_CHAR > ]
(  sql_package()< SQL_PERIOD_CHAR >  function() | user_defined_operator() )
[ "@" dblink()< SQL_PERIOD_CHAR > ]
[ <SQL_LPARENCHAR> [ [ < SQL_DISTINCT> | < SQL_ALL> ] expr() (< SQL_COMMA_CHAR > expr() )* ] <SQL_RPARENCHAR> ]
}
void allocate_extent_clause() : 
{}
{

< ALLOCATE> < EXTENT>[ ( ( < SIZE > size_clause()
      | < DATAFILE > < APOSTROPHE >filename()< APOSTROPHE >
      | < INSTANCE > integer()
      )+
    )
  ]
}
void constraint() : 
{}
{

( inline_constraint()
| out_of_line_constraint()
| inline_ref_constraint()
| out_of_line_ref_constraint()
)
}
void inline_constraint() : 
{}
{
[ < CONSTRAINT > constraint_name() ]
( [ < SQL_NOT > ] < SQL_NULL>
| < UNIQUE >
| < SQL_PRIMARY> < SQL_KEY>
| references_clause()
| < CHECK > <SQL_LPARENCHAR> condition() <SQL_RPARENCHAR>
)
[ constraint_state() ]
}
void out_of_line_constraint() : 
{}
{
[ < CONSTRAINT > constraint_name() ]
( < UNIQUE > <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )* <SQL_RPARENCHAR>
| < SQL_PRIMARY> < SQL_KEY> <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )* <SQL_RPARENCHAR>
| < FOREIGN> < SQL_KEY> <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )* <SQL_RPARENCHAR> references_clause()
| < CHECK > <SQL_LPARENCHAR> condition() <SQL_RPARENCHAR>
)
[ constraint_state() ]
}
void inline_ref_constraint() : 
{}
{

( < SCOPE >  < SQL_IS> [ schema() < SQL_PERIOD_CHAR > ] scope_table()
| < SQL_WITH> < ROWID>
| [ < CONSTRAINT > constraint_name() ]
  references_clause()
  [ constraint_state() ]
)
}
void out_of_line_ref_constraint() : 
{}
{

( < SCOPE> < FOR> <SQL_LPARENCHAR> ( ref_col() | ref_attr() ) <SQL_RPARENCHAR> < SQL_IS > [ schema()< SQL_PERIOD_CHAR > ] scope_table()
 | < SQL_ORA_REF> <SQL_LPARENCHAR> ( ref_col() | ref_attr() ) <SQL_RPARENCHAR> < SQL_WITH> < ROWID>|
 [ < CONSTRAINT > constraint_name() ] < FOREIGN> < SQL_KEY> <SQL_LPARENCHAR> ( ref_col() [< SQL_COMMA_CHAR > ref_col() ] | ref_attr() [< SQL_COMMA_CHAR > ref_attr() ] ) <SQL_RPARENCHAR> references_clause()
    [ constraint_state() ]
)
}
void references_clause() : 
{}
{

< REFERENCES > [ schema()< SQL_PERIOD_CHAR > ] object() [ (column() (< SQL_COMMA_CHAR > column() )*) ]
  [< SQL_ON> < SQL_DELETE>( < CASCADE > | < SQL_SET> < SQL_NULL>) ]
}
void constraint_state() : 
{}
{
(
  [ < SQL_NOT > ] < DEFERRABLE > 
|    < INITIALLY > ( < IMMEDIATE > | < DEFERRED > ) 
|  ( < RELY > | < NORELY > ) 
|  using_index_clause() 
| (  < ENABLE > | < DISABLE >  ) 
| (  < VALIDATE > | < NOVALIDATE > ) 
|  exceptions_clause() 
)+
}
void using_index_clause() : 
{}
{

< SQL_USING> < SQL_INDEX>( [ schema()< SQL_PERIOD_CHAR > ] index()
  | <SQL_LPARENCHAR> create_index_statement() <SQL_RPARENCHAR>
  | index_properties()
  )
}
void index_properties() : 
{}
{
 ( ( global_partitioned_index()
    | local_partitioned_index()
    )
  | index_attributes()
  )+
| < INDEXTYPE> < SQL_IS>( domain_index_clause()
                      | XMLTable_index_clause()
                      | XMLIndex_clause()
                      )
}
void index_attributes() : 
{}
{
 ( physical_attributes_clause()
  | logging_clause()
  | < ONLINE >
  | < TABLESPACE > ( tablespace() | < SQL_DEFAULT > )
  | index_compression()
  | ( < SORT > | < NOSORT > )
  | < REVERSE >
  | < VISIBLE > | < INVISIBLE >
  | partial_index_clause()
  | parallel_clause()
  )+

}
void exceptions_clause() : 
{}
{

< EXCEPTIONS> < SQL_INTO>[ schema()< SQL_PERIOD_CHAR > ] table()
}
void deallocate_unused_clause() : 
{}
{

< DEALLOCATE> < UNUSED>[ < KEEP > size_clause() ]
}
void file_specification() : 
{}
{

( datafile_tempfile_spec()
| redo_log_file_spec()
)
}
void datafile_tempfile_spec() : 
{}
{
(
 < APOSTROPHE >filename()< APOSTROPHE > | < APOSTROPHE >asm_filename()< APOSTROPHE > 
 |  < SIZE > size_clause() 
 |  < REUSE > 
 autoextend_clause()
) 
}
void redo_log_file_spec() : 
{}
{
 < APOSTROPHE > filename() | asm_filename()< APOSTROPHE >
| <SQL_LPARENCHAR> < APOSTROPHE >filename() | asm_filename()< APOSTROPHE >
   ( < SQL_COMMA_CHAR > < APOSTROPHE >filename() | asm_filename()< APOSTROPHE > )*
  <SQL_RPARENCHAR>

[ < SIZE > size_clause() ]
[ < BLOCKSIZE > size_clause() ]
[ < REUSE > ]
}
void asm_filename() : 
{}
{

( fully_qualified_file_name()
| numeric_file_name()
| incomplete_file_name()
| alias_file_name()
)
}
void fully_qualified_file_name() : 
{}
{

<SQL_PLUSCHAR>diskgroup_name()<SQL_SLASHCHAR>db_name()<SQL_SLASHCHAR>file_type()<SQL_SLASHCHAR>
   file_type_tag()< SQL_PERIOD_CHAR >filenumber()< SQL_PERIOD_CHAR >incarnation_number()
}
void numeric_file_name() : 
{}
{

<SQL_PLUSCHAR>diskgroup_name()< SQL_PERIOD_CHAR >filenumber()< SQL_PERIOD_CHAR >incarnation_number()
}
void incomplete_file_name() : 
{}
{

<SQL_PLUSCHAR>diskgroup_name() [ (template_name()) ]
}
void alias_file_name() : 
{}
{

<SQL_PLUSCHAR>diskgroup_name() [ (template_name()) ] <SQL_SLASHCHAR>alias_name()
}
void autoextend_clause() : 
{}
{

< AUTOEXTEND >
   ( < OFF >
   | < SQL_ON> [ < NEXT > size_clause() ]
        [ maxsize_clause() ]
   )
}
void maxsize_clause() : 
{}
{

< MAXSIZE > ( < UNLIMITED > | size_clause() )
}
void logging_clause() : 
{}
{

( < LOGGING > | < NOLOGGING > | <  FILESYSTEM_LIKE_LOGGING > )
}
void parallel_clause() : 
{}
{

( < NOPARALLEL > | < PARALLEL > [ integer() ] )
}
void physical_attributes_clause() : 
{}
{
( < PCTFREE > integer()
  | < PCTUSED > integer()
  | < INITRANS > integer()
  | storage_clause()
  )+

}
void size_clause() : 
{}
{

integer() [ < K > | < M > | < G > | < T > | < P > | < E > ]
}
void storage_clause() : 
{}
{
< STORAGE >
(( < INITIAL > size_clause()
 | < NEXT > size_clause()
 | < MINEXTENTS > integer()
 | < MAXEXTENTS > ( integer() | < UNLIMITED > )
 | maxsize_clause()
 | < PCTINCREASE > integer()
 | < FREELISTS > integer()
 | < FREELIST> < GROUPS>integer()
 | < OPTIMAL > [ size_clause() | < SQL_NULL> ]
 | < BUFFER_POOL > ( < KEEP > | < RECYCLE > | < SQL_DEFAULT > )
 | < FLASH_CACHE > ( < KEEP > | < NONE > | < SQL_DEFAULT > )
 | < ENCRYPT >
 )+
)
}

void select_test() :
{}
{
  (select() )+}
 
void select() : 
{}
{
subquery() [ for_update_clause() ] 
}
void subquery() : 
{}
{
( query_block()
| ( < SQL_UNION> [< SQL_ALL>] | < SQL_INTERSECT> | < MINUS > ) subquery()
    ( ( < SQL_UNION> [< SQL_ALL>] | < SQL_INTERSECT> | < MINUS > ) subquery() )*
| <SQL_LPARENCHAR>  subquery() <SQL_RPARENCHAR>
) [ order_by_clause() ] [ row_limiting_clause() ]
}
void query_block() : 
{}
{
[ with_clause() ]
< SQL_SELECT> [ hint() ] [ ( < SQL_DISTINCT> | < UNIQUE >  | < SQL_ALL> ) ] select_list()
  < SQL_FROM> ( [< SQL_COMMA_CHAR > ] table_reference() | [ <SQL_LPARENCHAR> ] join_clause() [<SQL_RPARENCHAR>] )+
  [ where_clause() ]
  [ hierarchical_query_clause() ]
  [ group_by_clause() ]
  [ model_clause() ]
}
void hierarchical_query_clause() : 
{}
{

( < CONNECT> < SQL_BY>[ < NOCYCLE > ] condition() [ < START> < SQL_WITH>condition() ]
| < START> < SQL_WITH>condition() < CONNECT> < SQL_BY>[ < NOCYCLE > ] condition()
)
}

void administer_key_management() : 
{}
{
< ADMINISTER > < SQL_KEY> < MANAGEMENT >
  ( keystore_management_clauses()
  | key_management_clauses()
  | secret_management_clauses()
  ) 
}
void keystore_management_clauses() : 
{}
{

( create_keystore()
| open_keystore()
| close_keystore()
| backup_keystore()
| alter_keystore_password()
| merge_into_new_keystore()
| merge_into_exist_keystore()
)
}
void create_keystore() : 
{}
{

< SQL_CREATE>
  ( < KEYSTORE > < APOSTROPHE >keystore_location()< APOSTROPHE >
  | [ < LOCAL > ] < AUTO_ > < LOGIN > < KEYSTORE > < SQL_FROM> < KEYSTORE > < APOSTROPHE >keystore_location()< APOSTROPHE >
  )
  < IDENTIFIED> < SQL_BY>keystore_password()
}
void open_keystore() : 
{}
{

< SQL_SET> < KEYSTORE > < SQL_OPEN> 
  < IDENTIFIED > < SQL_BY> keystore_password()
  [ < CONTAINER > <ESQL_EQ> ( < SQL_ALL> | < CURRENT > ) ]
}
void close_keystore() : 
{}
{

< SQL_SET> <KEYSTORE > < CLOSE >
  [ < IDENTIFIED> < SQL_BY>keystore_password() ]
  [ < CONTAINER > <ESQL_EQ> ( < SQL_ALL> | < CURRENT > ) ]
}
void backup_keystore() : 
{}
{

< BACKUP> < KEYSTORE>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ]
  < IDENTIFIED> < SQL_BY>keystore_password()
  [ < TO > < APOSTROPHE >keystore_location()< APOSTROPHE > ]
}
void alter_keystore_password() : 
{}
{

< ALTER > < KEYSTORE > < PASSWORD >
  < IDENTIFIED> < SQL_BY>old_keystore_password()
  < SQL_SET> new_keystore_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
}
void merge_into_new_keystore() : 
{}
{

< MERGE> < KEYSTORE>< APOSTROPHE >keystore1_location()< APOSTROPHE > [ < IDENTIFIED> < SQL_BY>keystore1_password() ]
  < SQL_AND> < KEYSTORE>< APOSTROPHE >keystore2_location()< APOSTROPHE > [ < IDENTIFIED> < SQL_BY>keystore2_password() ]
  < SQL_INTO> <NEW > < KEYSTORE > < APOSTROPHE >keystore3_location()< APOSTROPHE > < IDENTIFIED> < SQL_BY>keystore3_password()
}
void merge_into_exist_keystore() : 
{}
{

< MERGE> < KEYSTORE>< APOSTROPHE >keystore1_location()< APOSTROPHE > [ < IDENTIFIED> < SQL_BY>keystore1_password() ]
  < SQL_INTO> <EXISTING > < KEYSTORE > < APOSTROPHE >keystore2_location()< APOSTROPHE > < IDENTIFIED> < SQL_BY>keystore2_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
}
void key_management_clauses() : 
{}
{

( set_key()
| create_key()
| use_key()
| set_key_tag()
| export_keys()
| import_keys()
| migrate_key()
| reverse_migrate_key()
)
}
void set_key() : 
{}
{

< SQL_SET> [ < ENCRYPTION > ] < SQL_KEY> [ < SQL_USING> < TAG>< APOSTROPHE >tag()< APOSTROPHE > ]
  < IDENTIFIED> < SQL_BY>keystore_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
  [ < CONTAINER > <ESQL_EQ> ( < SQL_ALL> | < CURRENT > ) ]
}
void create_key() : 
{}
{

< SQL_CREATE> [ < ENCRYPTION > ] < SQL_KEY> [ < SQL_USING> < TAG>< APOSTROPHE >tag()< APOSTROPHE > ]
  < IDENTIFIED> < SQL_BY>keystore_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
  [ < CONTAINER > <ESQL_EQ> ( < SQL_ALL> | < CURRENT > ) ]
}
void use_key() : 
{}
{

< USE > [ < ENCRYPTION > ] < SQL_KEY> < APOSTROPHE >key_id()< APOSTROPHE > [ < SQL_USING> < TAG>< APOSTROPHE >tag()< APOSTROPHE > ]
  < IDENTIFIED> < SQL_BY>keystore_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
}
void set_key_tag() : 
{}
{

< SQL_SET> < TAG>< APOSTROPHE >tag()< APOSTROPHE > < FOR > < APOSTROPHE >key_id()< APOSTROPHE > < IDENTIFIED> < SQL_BY>keystore_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
}
void export_keys() : 
{}
{

< EXPORT > [ < ENCRYPTION > ] < KEYS > < SQL_WITH> < SECRET>secret()
  < TO > < APOSTROPHE >filename()< APOSTROPHE >
  < IDENTIFIED> < SQL_BY>keystore_password()
  [ < SQL_WITH> <IDENTIFIER > < SQL_IN> ( < APOSTROPHE >key_id()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >key_id()< APOSTROPHE > )* | <SQL_LPARENCHAR> subquery() <SQL_RPARENCHAR> ) ]
}
void import_keys() : 
{}
{

< IMPORT > [ < ENCRYPTION > ] < KEYS > < SQL_WITH> < SECRET>secret()
  < SQL_FROM> < APOSTROPHE >filename()< APOSTROPHE >
  < IDENTIFIED> < SQL_BY>keystore_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
}
void migrate_key() : 
{}
{

< SQL_SET> [ < ENCRYPTION > ] < SQL_KEY> < IDENTIFIED > < SQL_BY> HSM_auth_string()
  [ < SQL_USING> < TAG>< APOSTROPHE >tag()< APOSTROPHE > ]
  < MIGRATE> < SQL_USING>software_keystore_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
}
void reverse_migrate_key() : 
{}
{

< SQL_SET> [ < ENCRYPTION > ] < SQL_KEY> < IDENTIFIED> < SQL_BY>software_keystore_password()
  [ < SQL_USING> < TAG>< APOSTROPHE >tag()< APOSTROPHE > ]
  < REVERSE > < MIGRATE > < SQL_USING> HSM_auth_string()
}
void secret_management_clauses() : 
{}
{

( add_update_secret()
| delete_secret()
)
}
void add_update_secret() : 
{}
{

( < ADD > | < SQL_UPDATE> ) < SECRET > < APOSTROPHE >secret()< APOSTROPHE > < FOR> < CLIENT>< APOSTROPHE >client_identifier()< APOSTROPHE >
  [ < SQL_USING> < TAG>< APOSTROPHE >tag()< APOSTROPHE > ]
  < IDENTIFIED> < SQL_BY>keystore_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
}
void delete_secret() : 
{}
{

< SQL_DELETE> < SECRET > < FOR > <  CLIENT > < APOSTROPHE >client_identifier()< APOSTROPHE >
  < IDENTIFIED> < SQL_BY>keystore_password()
  [ < SQL_WITH> < BACKUP>[ < SQL_USING> < APOSTROPHE >backup_identifier()< APOSTROPHE > ] ]
}
void alter_audit_policy() : 
{}
{

< ALTER > < AUDIT > <  POLICY > policy()
  [ < ADD > [ privilege_audit_clause() ] [ action_audit_clause() ] [ role_audit_clause() ] ]
  [ < SQL_DROP> [ privilege_audit_clause() ] [ action_audit_clause() ] [ role_audit_clause() ] ]
  [ < CONDITION > ( < SQL_DROP> | < APOSTROPHE >audit_condition()< APOSTROPHE > < EVALUATE> < PER>( < STATEMENT > | < SESSION > | < INSTANCE > ) ) ] 
}
void privilege_audit_clause() : 
{}
{

< PRIVILEGES > system_privilege() ( < SQL_COMMA_CHAR > system_privilege() )*
}
void action_audit_clause() : 
{}
{

( standard_actions() | component_actions() )+
}
void standard_actions() : 
{}
{

< ACTIONS >
  ( ( object_action() | < SQL_ALL> )
    < SQL_ON> ( < DIRECTORY > directory_name()
       | < MINING> < MODEL>[ schema()< SQL_PERIOD_CHAR > ] object_name()
       | [ schema()< SQL_PERIOD_CHAR > ] object_name() )
  | ( system_action() | < SQL_ALL> )
  )
    (
       ( object_action() | < SQL_ALL> )
      < SQL_ON> ( < DIRECTORY > directory_name()
         | < MINING> < MODEL>[ schema()< SQL_PERIOD_CHAR > ] object_name()
         | [ schema()< SQL_PERIOD_CHAR > ] object_name() )
    | ( system_action() | < SQL_ALL> ) )*
}
void component_actions() : 
{}
{

< ACTIONS> < COMPONENT> <ESQL_EQ>
  ( < DATAPUMP > | < DIRECT_LOAD > | < OLS > | < XS > ) component_action() (< SQL_COMMA_CHAR > component_action() )*
  |
  < DV > component_action() < SQL_ON> object_name() (< SQL_COMMA_CHAR > component_action() < SQL_ON> object_name() )*
}
void role_audit_clause() : 
{}
{

< ROLES > role() (< SQL_COMMA_CHAR > role() )*
}
void alter_cluster() : 
{}
{

< ALTER> < CLUSTER>[ schema()< SQL_PERIOD_CHAR > ] cluster()
  ( physical_attributes_clause()
  | < SIZE > size_clause()
  | [ < MODIFY> < PARTITION>partition() ] allocate_extent_clause()
  | deallocate_unused_clause()
  | ( < CACHE > | < NOCACHE > )
  )+
  [ parallel_clause() ] 
}
 


 
void alter_database() : 
{}
{

< ALTER> < DATABASE>[ database() ]
  ( startup_clauses()
  | recovery_clauses()
  | database_file_clauses()
  | logfile_clauses()
  | controlfile_clauses()
  | standby_database_clauses()
  | default_settings_clauses()
  | instance_clauses()
  | security_clause()
  ) 
}
void startup_clauses() : 
{}
{

( < MOUNT > [ ( < STANDBY > | < CLONE > ) < DATABASE > ]
| < SQL_OPEN>
  ( [ < READ> < WRITE>]
      [ < RESETLOGS > | < NORESETLOGS > ]
        [ < UPGRADE > | < DOWNGRADE > ]
  | < READ> < ONLY>)
)
}
void recovery_clauses() : 
{}
{

( general_recovery()
| managed_standby_recovery()
| < SQL_BEGIN> < BACKUP>| < SQL_END> < BACKUP>)
}
void general_recovery() : 
{}
{

< RECOVER >
[ < AUTOMATIC > ]
[ < SQL_FROM> < APOSTROPHE >location()< APOSTROPHE > ]
( ( full_database_recovery()
  | partial_database_recovery()
  | < LOGFILE > < APOSTROPHE >filename()< APOSTROPHE >
  )
  [ ( < TEST >
    | < ALLOW > integer() < CORRUPTION >
    | parallel_clause()
    )+
  ]
| < CONTINUE > [ < SQL_DEFAULT > ]
| < CANCEL >
)
}
void full_database_recovery() : 
{}
{

[ < STANDBY > ] < DATABASE >
[ ( < UNTIL > ( < CANCEL >
          | < TIME > date()
          | < CHANGE > integer()
          | < CONSISTENT >
          )
  | < SQL_USING> < BACKUP > < CONTROLFILE >
  | < SNAPSHOT> < TIME>date()
  )+
]
}
void partial_database_recovery() : 
{}
{

( < TABLESPACE > tablespace() (< SQL_COMMA_CHAR > tablespace() )*
| < DATAFILE > ( < APOSTROPHE >filename()< APOSTROPHE > | filenumber() )
             ( < SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > | filenumber() )*
)
}

void managed_standby_recovery() : 
{}
{

< RECOVER >
( < MANAGED > < STANDBY > <  DATABASE >
    [ ( < SQL_USING> < ARCHIVED ><  LOGFILE >
      | < DISCONNECT > [< SQL_FROM> < SESSION>]
      | < NODELAY >
      | < UNTIL > < CHANGE > integer()
      | < UNTIL> < CONSISTENT>| parallel_clause()
      )+
    | < FINISH >
    | < CANCEL >
    ]
| < TO > < LOGICAL > <  STANDBY > ( db_name() | < KEEP> < IDENTITY>)
)
}
void database_file_clauses() : 
{}
{

( < RENAME> < FILE>< APOSTROPHE >filename()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > )*
   < TO > < APOSTROPHE >filename()< APOSTROPHE >
| create_datafile_clause()
| alter_datafile_clause()
| alter_tempfile_clause()
| move_datafile_clause()
)
}
void create_datafile_clause() : 
{}
{

< SQL_CREATE> < DATAFILE>( < APOSTROPHE >filename()< APOSTROPHE > | filenumber() )
     ( < SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > | filenumber() )* 
   [ < SQL_AS> ( file_specification()
          ( < SQL_COMMA_CHAR > file_specification() )*
        | < NEW >
        )
   ]
}
void alter_datafile_clause() : 
{}
{

< DATAFILE >
   ( < APOSTROPHE >filename()< APOSTROPHE > | filenumber() )
     ( < SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > | filenumber() )* 
   ( < ONLINE >
   | < OFFLINE > [ < FOR> < SQL_DROP>]
   | < RESIZE > size_clause()
   | autoextend_clause()
   | < SQL_END> < BACKUP>)
}
void alter_tempfile_clause() : 
{}
{

< TEMPFILE >
   ( < APOSTROPHE >filename()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > )*
   | filenumber() (< SQL_COMMA_CHAR > filenumber() )*
   )
   ( < RESIZE > size_clause()
   | autoextend_clause()
   | < SQL_DROP> [ < INCLUDING> < DATAFILES>]
   | < ONLINE >
   | < OFFLINE >
   )
}
void move_datafile_clause() : 
{}
{

< MOVE> < DATAFILE>( < APOSTROPHE >filename()< APOSTROPHE > | < APOSTROPHE >asm_filename()< APOSTROPHE > | file_number() )
 [ < TO > ( < APOSTROPHE >filename()< APOSTROPHE > | < APOSTROPHE >asm_filename()< APOSTROPHE > ) ]
 [ < REUSE > ] [ < KEEP > ]
}


void logfile_clauses() : 
{}
{

( ( < ARCHIVELOG > [ < MANUAL > ]
  | < NOARCHIVELOG >
  )
| [ < NO > ] < FORCE > < LOGGING >
| < RENAME> < FILE>< APOSTROPHE >filename()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > )*
    < TO > < APOSTROPHE >filename()< APOSTROPHE >
| < CLEAR > [ < UNARCHIVED > ]
    < LOGFILE > logfile_descriptor() (< SQL_COMMA_CHAR > logfile_descriptor() )*
    [ < UNRECOVERABLE> < DATAFILE>]
| add_logfile_clauses()
| drop_logfile_clauses()
| switch_logfile_clause()
| supplemental_db_logging()
)
}
void add_logfile_clauses() : 
{}
{

< ADD > [ < STANDBY > ] < LOGFILE >
   ( 
     ( [ < INSTANCE > < APOSTROPHE >instance_name()< APOSTROPHE > ] | [ < THREAD > < APOSTROPHE >integer()< APOSTROPHE > ] )
     [ < SQL_GROUP> integer() ] redo_log_file_spec()
       ( < SQL_COMMA_CHAR > [ < SQL_GROUP> integer() ] redo_log_file_spec() )*
   | < MEMBER > < APOSTROPHE >filename()< APOSTROPHE > [ < REUSE > ] (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > [ < REUSE > ] )*
        < TO > logfile_descriptor() (< SQL_COMMA_CHAR > logfile_descriptor() )*
   )
}
void drop_logfile_clauses() : 
{}
{

< SQL_DROP> [ < STANDBY > ] < LOGFILE >
   ( logfile_descriptor()
     ( < SQL_COMMA_CHAR > logfile_descriptor() )*
   | < MEMBER > < APOSTROPHE >filename()< APOSTROPHE >
            ( < SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > )*
   )
}
void switch_logfile_clause() : 
{}
{

< SWITCH > < SQL_ALL> < LOGFILES > < TO > < BLOCKSIZE > integer()
}
void supplemental_db_logging() : 
{}
{

( < ADD > | < SQL_DROP> ) < SUPPLEMENTAL> < SQL_ORA_LOG>( < DATA >
| supplemental_id_key_clause()
| supplemental_plsql_clause()
)
}

void supplemental_plsql_clause() : 
{}
{

< DATA > < FOR > < PROCEDURAL > <  REPLICATION >
}
void logfile_descriptor() : 
{}
{

( < SQL_GROUP> integer()
| (< APOSTROPHE >filename()< APOSTROPHE > ( < SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > )* )
| < APOSTROPHE >filename()< APOSTROPHE >
)
}
void controlfile_clauses() : 
{}
{

< SQL_CREATE> ( [ < LOGICAL > | < PHYSICAL > ] < STANDBY > | < FAR > < SYNC > < INSTANCE > )
  < CONTROLFILE> < SQL_AS>< APOSTROPHE >filename()< APOSTROPHE > [ < REUSE > ]
| < BACKUP > < CONTROLFILE > <  TO >
  ( < APOSTROPHE >filename()< APOSTROPHE > [ < REUSE > ]
  | trace_file_clause()
  )
}
void trace_file_clause() : 
{}
{

< TRACE >
  [ < SQL_AS> < APOSTROPHE >filename()< APOSTROPHE > [ < REUSE > ] ]
  [ < RESETLOGS > | < NORESETLOGS > ]
}
void standby_database_clauses() : 
{}
{

( ( activate_standby_db_clause()
| maximize_standby_db_clause()
| register_logfile_clause()
| commit_switchover_clause()
| start_standby_clause()
| stop_standby_clause()
| convert_database_clause()
) [ parallel_clause() ] )
|
( switchover_clause() | failover_clause() )
}
void activate_standby_db_clause() : 
{}
{

< ACTIVATE >
     [ < PHYSICAL > | < LOGICAL > ]
     < STANDBY> < DATABASE>[ < FINISH> < APPLY>]
}
void maximize_standby_db_clause() : 
{}
{

< SQL_SET> < STANDBY > <  DATABASE > < TO > < MAXIMIZE >
( < PROTECTION > | < AVAILABILITY > | < PERFORMANCE > )
}
void register_logfile_clause() : 
{}
{
< REGISTER > [ < SQL_OR> < SQL_REPLACE> ]
  [ < PHYSICAL > | < LOGICAL > ]
  < LOGFILE > [ file_specification()  (  < SQL_COMMA_CHAR > file_specification() )* ]
  [ < FOR > logminer_session_name() ]
}
void switchover_clause() : 
{}
{

< SWITCHOVER> < TO>target_db_name() [ < VERIFY > | < FORCE > ]
}
void failover_clause() : 
{}
{

< FAILOVER> < TO>target_db_name() [ < FORCE > ]
}
void commit_switchover_clause() : 
{}
{

( < PREPARE > | < COMMIT > ) < TO > < SWITCHOVER >
[ < TO > ( ( [ < PHYSICAL > | < LOGICAL > ] < SQL_PRIMARY>
     | [ < PHYSICAL > ] < STANDBY >
     ) [ ( < SQL_WITH> | < WITHOUT > ) < SESSION> < SHUTDOWN>( < WAIT > | < NOWAIT > )
       ]
     | < LOGICAL> < STANDBY>)
| < CANCEL >
]
}
void start_standby_clause() : 
{}
{

< START > <LOGICAL >< STANDBY ><APPLY >
[ < IMMEDIATE > ]
[ < NODELAY > ]
[ < NEW> < SQL_PRIMARY>dblink()
| < INITIAL > [ scn_value() ]
| ( < SQL_SKIP > <FAILED >< TRANSACTION > | < FINISH > )
]
}
void stop_standby_clause() : 
{}
{

( < STOP > | < ABORT > ) < LOGICAL >< STANDBY >< APPLY >
}
void convert_database_clause() : 
{}
{

< SQL_ORA_CONVERT> < TO>( < PHYSICAL > | < SNAPSHOT > ) < STANDBY >
}
void default_settings_clauses() : 
{}
{

( < SQL_DEFAULT> < EDITION><ESQL_EQ> edition_name()
| < SQL_SET> < SQL_DEFAULT>( < BIGFILE > | < SMALLFILE > ) < TABLESPACE >
| < SQL_DEFAULT> < TABLESPACE>tablespace()
| < SQL_DEFAULT >< TEMPORARY >< TABLESPACE > ( tablespace() | tablespace_group_name() )
| < RENAME > < GLOBAL_NAME > < TO > database()< SQL_PERIOD_CHAR >domain() (< SQL_PERIOD_CHAR >domain() )+
| < ENABLE >< BLOCK >< CHANGE > < TRACKING > [ < SQL_USING> < FILE>< APOSTROPHE >filename()< APOSTROPHE > [ < REUSE > ] ]
| < DISABLE >< BLOCK ><CHANGE >< TRACKING >
| [< NO >] < FORCE >< SQL_FULL><DATABASE >< CACHING >
| flashback_mode_clause()
| set_time_zone_clause()
)
}
void set_time_zone_clause() : 
{}
{

< SQL_SET> < TIME_ZONE><ESQL_EQ>
   < APOSTROPHE >( ( <SQL_PLUSCHAR> | <SQL_MINUSCHAR> ) hh() ":" mi() | time_zone_region() )< APOSTROPHE >
}
void flashback_mode_clause() : 
{}
{

< FLASHBACK > ( < SQL_ON> | < OFF > )
}
void instance_clauses() : 
{}
{

( < ENABLE > | < DISABLE > ) < INSTANCE > < APOSTROPHE >instance_name()< APOSTROPHE >
}
void security_clause() : 
{}
{

< GUARD > ( < SQL_ALL> | < STANDBY > | < NONE > )
}
void alter_database_link() : 
{}
{

< ALTER ><DATABASE ><LINK > dblink()
  ( < CONNECT> < TO>user() < IDENTIFIED> < SQL_BY>password() [ dblink_authentication() ]
  | dblink_authentication()
  )
}
void dblink_authentication() : 
{}
{

< AUTHENTICATED> < SQL_BY>user() < IDENTIFIED> < SQL_BY>password()
}
void alter_dimension() : 
{}
{

< ALTER> < DIMENSION>[ schema()< SQL_PERIOD_CHAR > ] dimension()
  ( < ADD > ( level_clause()
        | hierarchy_clause()
        | attribute_clause()
        | extended_attribute_clause()
        )
  )+
  |
  ( < SQL_DROP> ( < LEVEL > level() [ < RESTRICT > | < CASCADE > ]
         | < HIERARCHY > hierarchy()
         | < ATTRIBUTE > attribute() ( < LEVEL > level() [ < COLUMN > column() ] )*
         )
  )+
  |
  < COMPILE >
  
}
void level_clause() : 
{}
{

< LEVEL > level() < SQL_IS >
   ( level_table()< SQL_PERIOD_CHAR >level_column()
   | (level_table()< SQL_PERIOD_CHAR >level_column()
      (< SQL_COMMA_CHAR > level_table()< SQL_PERIOD_CHAR >level_column() )+
     )
   )
}
void hierarchy_clause() : 
{}
{

< HIERARCHY > hierarchy()
(child_level() ( < CHILD> < OF>parent_level() )+
  [ dimension_join_clause() ]
)
}
void dimension_join_clause() : 
{}
{

( < SQL_JOIN> < SQL_KEY>( child_key_column()
   | (child_key_column() (< SQL_COMMA_CHAR > child_key_column() )+)
   )
  < REFERENCES > parent_level()
)+
}
void attribute_clause() : 
{}
{

< ATTRIBUTE > level() < DETERMINES >
   ( dependent_column()
   | ( dependent_column()
       (< SQL_COMMA_CHAR > dependent_column() )+ )
   )
}
void extended_attribute_clause() : 
{}
{

< ATTRIBUTE > attribute()
  ( < LEVEL > level()
    < DETERMINES > ( dependent_column()
               | (dependent_column() (< SQL_COMMA_CHAR > dependent_column() )+ )
               )
  )+
}
void alter_diskgroup() : 
{}
{

< ALTER> < DISKGROUP>( diskgroup_name()
      ( ( ( add_disk_clause() | drop_disk_clause() )
          (< SQL_COMMA_CHAR > ( add_disk_clause() | drop_disk_clause() ) )+
        | resize_disk_clause()
        ) [ rebalance_diskgroup_clause() ]
      | replace_disk_clause()
      | rename_disk_clause()
      | disk_online_clause()
      | disk_offline_clause()
      | rebalance_diskgroup_clause()
      | check_diskgroup_clause()
      | diskgroup_template_clauses()
      | diskgroup_directory_clauses()
      | diskgroup_alias_clauses()
      | diskgroup_volume_clauses()
      | diskgroup_attributes()
      | modify_diskgroup_file()
      | drop_diskgroup_file_clause()
      | usergroup_clauses()
      | user_clauses()
      | file_permissions_clause()
      | file_owner_clause()
      | scrub_clause()
      )
    | ( diskgroup_name() (< SQL_COMMA_CHAR > diskgroup_name() )+
      | < SQL_ALL>
      ) ( undrop_disk_clause()
        | diskgroup_availability()
        | enable_disable_volume()
        )
  ) 
}
void add_disk_clause() : 
{}
{

< ADD >
  ( [ < QUORUM > | < REGULAR > ] [ < FAILGROUP > failgroup_name() ]
    < DISK > qualified_disk_clause() (< SQL_COMMA_CHAR > qualified_disk_clause() )+
  )+
}
void qualified_disk_clause() : 
{}
{

search_string()
[ < NAME > disk_name() ]
[ < SIZE > size_clause() ]
[ < FORCE > | < NOFORCE > ]
}
void drop_disk_clause() : 
{}
{

< SQL_DROP>
( [< QUORUM > |<  REGULAR >] < DISK >
    disk_name() [ < FORCE > | < NOFORCE > ]
    ( < SQL_COMMA_CHAR > disk_name() [ < FORCE > | < NOFORCE > ] )*
| < DISKS > < SQL_IN> <LEFT_ > QUORUM() |<  REGULAR > <RIGHT_ > FAILGROUP()
    failgroup_name() [ < FORCE > | < NOFORCE > ]
    ( < SQL_COMMA_CHAR > failgroup_name() [ < FORCE > | < NOFORCE > ] )* 
)
}
void resize_disk_clause() : 
{}
{

< RESIZE >
( < SQL_ALL> [ < SIZE > size_clause() ]
| < LEFT_ >QUORUM() |<  REGULAR > <RIGHT_> DISK()
   disk_name() [ < SIZE > size_clause() ]
   ( < SQL_COMMA_CHAR > disk_name() [ < SIZE > size_clause() ] )*
| < DISKS > < SQL_IN>  <LEFT_>QUORUM() |<  REGULAR > <RIGHT_> FAILGROUP()
    failgroup_name() [ < SIZE > size_clause() ]
    ( < SQL_COMMA_CHAR > failgroup_name() [ < SIZE > size_clause() ] )*
)
}
void replace_disk_clause() : 
{}
{

< SQL_REPLACE> < DISK>disk_name() < SQL_WITH> < APOSTROPHE >path_name()< APOSTROPHE > [ < FORCE > | < NOFORCE > ]
  ( < SQL_COMMA_CHAR > disk_name() < SQL_WITH> < APOSTROPHE >path_name()< APOSTROPHE > [ < FORCE > | < NOFORCE > ] )*
[ < SQL_ORA_POWER> integer() ] [ < WAIT > | < NOWAIT > ]
}
void rename_disk_clause() : 
{}
{

< RENAME >
  ( < DISK > old_disk_name() < TO > new_disk_name() (< SQL_COMMA_CHAR > old_disk_name() < TO > new_disk_name() )+
  | < DISKS> < SQL_ALL>)
}
void disk_online_clause() : 
{}
{

< ONLINE >
  ( ( [< QUORUM > |<  REGULAR >] < DISK > disk_name() (< SQL_COMMA_CHAR > disk_name())+
    | < DISKS > < SQL_IN>  <LEFT_> QUORUM() |<  REGULAR > <RIGHT_>  FAILGROUP() failgroup_name() (< SQL_COMMA_CHAR > failgroup_name())+
    )+
  | < SQL_ALL>
  ) [ < SQL_ORA_POWER> integer() ] [ <WAIT > | < NOWAIT >  ]
}
void disk_offline_clause() : 
{}
{

< OFFLINE >
  ( [< QUORUM > |<  REGULAR >] < DISK > disk_name() (< SQL_COMMA_CHAR > disk_name() )+
  | < DISKS > < SQL_IN> <LEFT_>QUORUM() |<  REGULAR > <RIGHT_> FAILGROUP() failgroup_name() (< SQL_COMMA_CHAR > failgroup_name() )+
  )+ [timeout_clause()]
}
void timeout_clause() : 
{}
{

< SQL_DROP> < AFTER>integer() ( < M > | < H > )
}
void undrop_disk_clause() : 
{}
{

< UNDROP> < DISKS>}
void rebalance_diskgroup_clause() : 
{}
{

< REBALANCE > [< SQL_ORA_POWER> integer()] [< WAIT > | < NOWAIT >]
}
void check_diskgroup_clause() : 
{}
{

< CHECK > [ < REPAIR > | < NOREPAIR > ]
}
void diskgroup_template_clauses() : 
{}
{

( ( < ADD > | < MODIFY > ) < TEMPLATE > template_name() qualified_template_clause()
      (< SQL_COMMA_CHAR > template_name() qualified_template_clause() )+
| < SQL_DROP> < TEMPLATE>template_name() (< SQL_COMMA_CHAR > template_name() )+
)
}
void qualified_template_clause() : 
{}
{

< ATTRIBUTE >
( redundancy_clause() 
  striping_clause() 
  disk_region_clause()
)
}
void redundancy_clause() : 
{}
{

 < MIRROR > | < HIGH > | < UNPROTECTED > 
}
void striping_clause() : 
{}
{

[ < FINE > | < COARSE > ]
}
void disk_region_clause() : 
{}
{

[ < HOT > | < COLD > ] [ < MIRRORHOT > | < MIRRORCOLD > ]
}
void diskgroup_directory_clauses() : 
{}
{

( < ADD> < DIRECTORY>< APOSTROPHE >filename()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > )+
| < SQL_DROP> < DIRECTORY>< APOSTROPHE >filename()< APOSTROPHE > [ < FORCE > | < NOFORCE > ]
    ( < SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > [ < FORCE > | < NOFORCE > ] )*
| < RENAME> < DIRECTORY>< APOSTROPHE >old_dir_name()< APOSTROPHE > < TO > < APOSTROPHE >new_dir_name()< APOSTROPHE >
    (< SQL_COMMA_CHAR > < APOSTROPHE >old_dir_name()< APOSTROPHE > < TO > < APOSTROPHE >new_dir_name()< APOSTROPHE > )+
)
}
void diskgroup_alias_clauses() : 
{}
{

( < ADD> < ALIAS>< APOSTROPHE >alias_name()< APOSTROPHE > < FOR > < APOSTROPHE >filename()< APOSTROPHE >
    (< SQL_COMMA_CHAR > < APOSTROPHE >alias_name()< APOSTROPHE > < FOR > < APOSTROPHE >filename()< APOSTROPHE > )+
| < SQL_DROP> < ALIAS>< APOSTROPHE >alias_name()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >alias_name()< APOSTROPHE > )+
| < RENAME> < ALIAS>< APOSTROPHE >old_alias_name()< APOSTROPHE > < TO > < APOSTROPHE >new_alias_name()< APOSTROPHE >
    (< SQL_COMMA_CHAR > < APOSTROPHE >old_alias_name()< APOSTROPHE > < TO > < APOSTROPHE >new_alias_name()< APOSTROPHE > )+
)
}
void diskgroup_volume_clauses() : 
{}
{

( add_volume_clause()
| modify_volume_clause()
| < RESIZE> < VOLUME>asm_volume() < SIZE > size_clause()
| < SQL_DROP> < VOLUME>asm_volume()
)
}
void add_volume_clause() : 
{}
{
< ADD> < VOLUME>asm_volume() < SIZE > size_clause() [redundancy_clause()]
  [ < STRIPE_WIDTH > integer() [ < K> | < M > ] ]
  [ < STRIPE_COLUMNS > integer() ]
  [ < ATTRIBUTE > (disk_region_clause()) ]
}

void modify_volume_clause() : 
{}
{

< MODIFY> < VOLUME>asm_volume()
  [ < ATTRIBUTE > (disk_region_clause()) ]
  [ < MOUNTPATH > < APOSTROPHE >mountpath_name()< APOSTROPHE > ]
  [ < USAGE > < APOSTROPHE >usage_name()< APOSTROPHE > ]
}
void diskgroup_attributes() : 
{}
{

< SQL_SET> < ATTRIBUTE>< APOSTROPHE >attribute_name()< APOSTROPHE > <ESQL_EQ> < APOSTROPHE >attribute_value()< APOSTROPHE >
}
void modify_diskgroup_file() : 
{}
{

< MODIFY> < FILE>< APOSTROPHE >filename()< APOSTROPHE > < ATTRIBUTE > ( disk_region_clause() )
  (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > < ATTRIBUTE > ( disk_region_clause() ) )+
}
void drop_diskgroup_file_clause() : 
{}
{
< SQL_DROP> < FILE>< APOSTROPHE >filename()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > )+
}
void usergroup_clauses() : 
{}
{

( < ADD> < USERGROUP>usergroup() < SQL_WITH> < MEMBER>user() (< SQL_COMMA_CHAR > user())+
| < MODIFY> < USERGROUP>usergroup() ( < ADD > | < SQL_DROP> ) < MEMBER > user() (< SQL_COMMA_CHAR > user())+
| < SQL_DROP> < USERGROUP>usergroup() 
)
}
void user_clauses() : 
{}
{

( < ADD> < SQL_ORA_USER>user() (< SQL_COMMA_CHAR > user())+
| < SQL_DROP> < SQL_ORA_USER>user() (< SQL_COMMA_CHAR > user())+ [< CASCADE >]
| < SQL_REPLACE> < SQL_ORA_USER>old_user() < SQL_WITH> new_user() (< SQL_COMMA_CHAR > old_user() < SQL_WITH> new_user())+
)
}
void file_permissions_clause() : 
{}
{

< SQL_SET> < PERMISSION>( < OWNER > | < SQL_GROUP> | < OTHER > )
  <ESQL_EQ> ( < NONE > | < READ> < ONLY>| < READ> < WRITE>)
  (< SQL_COMMA_CHAR > ( < OWNER > | < SQL_GROUP> | < OTHER > | < SQL_ALL> )
    <ESQL_EQ> ( < NONE > | < READ> < ONLY>| < READ> < WRITE>) )+
    < FOR> < FILE>< APOSTROPHE >filename()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE >)+
}
void file_owner_clause() : 
{}
{

< SQL_SET> < OWNERSHIP>( < OWNER > <ESQL_EQ> user() | < SQL_GROUP> <ESQL_EQ> usergroup() 
                  (< SQL_COMMA_CHAR > < OWNER > <ESQL_EQ> user() | < SQL_GROUP> <ESQL_EQ> usergroup() )+
              ) < FOR> < FILE>< APOSTROPHE >filename()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE >)+
}
void scrub_clause() : 
{}
{

< SCRUB > [ < FILE > < APOSTROPHE >asm_filename()< APOSTROPHE > | < DISK > disk_name() ]
  [ < REPAIR > | < NOREPAIR >]
  [ < SQL_ORA_POWER> ( < AUTO > | < LOW > | < HIGH > | < SQL_ORA_MAX> ) ]
  [ < WAIT > | < NOWAIT > ]
  [ < FORCE > | < NOFORCE > ]
}
void diskgroup_availability() : 
{}
{

( < MOUNT > [ <RESTRICTED > | < NORMAL > ] 
           [ <FORCE > | < NOFORCE > ]
| < DISMOUNT > [ < FORCE >| < NOFORCE > ]
)
}
void enable_disable_volume() : 
{}
{

( <  ENABLE >  | <  DISABLE > ) <  VOLUME >
  ( asm_volume() (< SQL_COMMA_CHAR > asm_volume())+
  | < SQL_ALL>
  )
}
void alter_flashback_archive() : 
{}
{

< ALTER >< FLASHBACK >< ARCHIVE > flashback_archive()
  ( < SQL_SET> < SQL_DEFAULT>| ( <  ADD >  | <  MODIFY > ) <  TABLESPACE > tablespace() [flashback_archive_quota()]
  | < REMOVE> < TABLESPACE>tablespace_name()
  | < MODIFY> < RETENTION>flashback_archive_retention()
  | < PURGE > ( < SQL_ALL> | < BEFORE > ( < SCN > expr() | < TIMESTAMP > expr() ) )
  | [< NO >] < OPTIMIZE> < DATA>)
}
void flashback_archive_quota() : 
{}
{

< QUOTA > integer() ( < M > | < G > | < T > | < P > | < E > )
}
void flashback_archive_retention() : 
{}
{

< RETENTION > integer() ( <  YEAR >  | <  MONTH >  | <  DAY > )
}
void alter_function() : 
{}
{

< ALTER> < FUNCTION>[ schema()< SQL_PERIOD_CHAR > ] function_name()
( function_compile_clause() | ( < EDITIONABLE > | < NONEDITIONABLE > ) )
}
void alter_index() : 
{}
{

< ALTER> < SQL_INDEX>[ schema()< SQL_PERIOD_CHAR > ]index()
  ( ( deallocate_unused_clause()
    | allocate_extent_clause()
    | shrink_clause()
    | parallel_clause()
    | physical_attributes_clause()
    | logging_clause()
    | partial_index_clause()
    )+
  | rebuild_clause()
  | < PARAMETERS > <SQL_LPARENCHAR> < APOSTROPHE >ODCI_parameters()< APOSTROPHE > <SQL_RPARENCHAR>
  | < COMPILE >
  | ( < ENABLE > | < DISABLE > )
  | < UNUSABLE > [ < ONLINE > ]
  | < VISIBLE > | < INVISIBLE >
  | < RENAME > < TO > new_name()
  | < SQL_ORA_COALESCE> [ < CLEANUP > ]
  | ( < MONITORING > | < NOMONITORING > ) < USAGE >
  | < SQL_UPDATE>< BLOCK >< REFERENCES >
  | alter_index_partitioning()
  )
  
}

void shrink_clause() : 
{}
{

< SHRINK> < SPACE> [ < COMPACT > ] [ < CASCADE > ]
}


 
void partial_index_clause() : 
{}
{

< INDEXING > ( < PARTIAL > | < SQL_FULL> )
}
void rebuild_clause() : 
{}
{

< REBUILD >
  [ ( < PARTITION > partition()
    | < SUBPARTITION > subpartition()
    )
  | ( < REVERSE > | < NOREVERSE > )
  ]
  ( parallel_clause()
  | < TABLESPACE > tablespace()
  | < PARAMETERS > ( < APOSTROPHE >ODCI_parameters()< APOSTROPHE > )
  | XMLIndex_parameters_clause()
  | < ONLINE >
  | physical_attributes_clause()
  | index_compression()
  | logging_clause()
  | partial_index_clause()
  )+
}
void index_compression() : 
{}
{

( prefix_compression()
| advanced_index_compression()
)
}
void prefix_compression() : 
{}
{

< COMPRESS > [ integer() ] | < NOCOMPRESS >
}
void advanced_index_compression() : 
{}
{

< COMPRESS >< ADVANCED >< LOW > | < NOCOMPRESS >
}
void alter_index_partitioning() : 
{}
{

( modify_index_default_attrs()
| add_hash_index_partition()
| modify_index_partition()
| rename_index_partition()
| drop_index_partition()
| split_index_partition()
| coalesce_index_partition()
| modify_index_subpartition()
)
}
void modify_index_default_attrs() : 
{}
{

< MODIFY ><SQL_DEFAULT >< ATTRIBUTES >
   [ < FOR> < PARTITION>partition() ]
   ( physical_attributes_clause()
   | < TABLESPACE > ( tablespace() | < SQL_DEFAULT > )
   | logging_clause()
   )+
}
void add_hash_index_partition() : 
{}
{

< ADD> < PARTITION>[ partition_name() ]
   [ < TABLESPACE > tablespace_name() ]
   [ index_compression() ]
   [ parallel_clause() ]
}
void coalesce_index_partition() : 
{}
{

< SQL_ORA_COALESCE> < PARTITION>[ parallel_clause() ]
}
void modify_index_partition() : 
{}
{

< MODIFY> < PARTITION>partition()
( ( deallocate_unused_clause()
  | allocate_extent_clause()
  | physical_attributes_clause()
  | logging_clause()
  | index_compression()
  )+
| < PARAMETERS > (< APOSTROPHE >ODCI_parameters()< APOSTROPHE >)
| < SQL_ORA_COALESCE> [ < CLEANUP > ]
| < SQL_UPDATE><BLOCK ><REFERENCES >
| < UNUSABLE >
)
}
void rename_index_partition() : 
{}
{

< RENAME >
  ( < PARTITION > partition() | < SUBPARTITION > subpartition() )
< TO > new_name()
}
void drop_index_partition() : 
{}
{

< SQL_DROP> < PARTITION>partition_name()
}
void split_index_partition() : 
{}
{

< SPLIT> < PARTITION>partition_name_old()
   < AT > (literal() (< SQL_COMMA_CHAR > literal() )+)
   [ < SQL_INTO> (index_partition_description()< SQL_COMMA_CHAR >
           index_partition_description()
          )
   ]
   [ parallel_clause() ]
}
void index_partition_description() : 
{}
{

< PARTITION >
[ partition()
   [ ( segment_attributes_clause()
     | index_compression()
     )+
   | < PARAMETERS > ( < APOSTROPHE >ODCI_parameters()< APOSTROPHE > )
   ]
   [ < USABLE > | < UNUSABLE > ]
]
}
void segment_attributes_clause() : 
{}
{

( physical_attributes_clause()
| < TABLESPACE > tablespace()
| logging_clause()
)+
}
void modify_index_subpartition() : 
{}
{

< MODIFY> < SUBPARTITION>subpartition()
( < UNUSABLE >
| allocate_extent_clause()
| deallocate_unused_clause()
)
}
void alter_indextype() : 
{}
{

< ALTER> < INDEXTYPE>[ schema()< SQL_PERIOD_CHAR > ] indextype()
  ( ( < ADD > | < SQL_DROP> ) [ schema()< SQL_PERIOD_CHAR > ] operator() ( parameter_types() ) 
      ( < SQL_COMMA_CHAR > ( < ADD > | < SQL_DROP> ) [schema()< SQL_PERIOD_CHAR > ] operator() ( parameter_types() ) )* [ using_type_clause() ]
  | < COMPILE >
  )
  [ < SQL_WITH> < LOCAL>[ < RANGE > ] < PARTITION > ] [ storage_table_clause() ]
  
}
void using_type_clause() : 
{}
{

< SQL_USING> [ schema()< SQL_PERIOD_CHAR > ] implementation_type() [ array_dml_clause() ]
}
void array_dml_clause() : 
{}
{
[ < SQL_WITH> | < WITHOUT > ]
< ARRAY> < DML>
[ <SQL_LPARENCHAR> [ schema()< SQL_PERIOD_CHAR > ]type()
   [ < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]varray_type() ] <SQL_RPARENCHAR>
    (
    < SQL_COMMA_CHAR > <SQL_LPARENCHAR> [ schema()< SQL_PERIOD_CHAR > ]type()
        [< SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]varray_type() ]<SQL_RPARENCHAR>
  )*
]  
  
}
void storage_table_clause() : 
{}
{

< SQL_WITH> (< SYSTEM > | < SQL_ORA_USER>) < MANAGED ><STORAGE > <TABLES  >
}

void invoker_rights_clause() : 
{}
{

< AUTHID > ( < CURRENT_USER > | < DEFINER > )
}
void alter_library() : 
{}
{

< ALTER> < LIBRARY>[ schema()< SQL_PERIOD_CHAR > ] library_name()
( library_compile_clause() | ( < EDITIONABLE > | < NONEDITIONABLE > ) )
}
void alter_materialized_view() : 
{}
{

< ALTER ><MATERIALIZED >< VIEW >
  [ schema()< SQL_PERIOD_CHAR > ] materialized_view()
  [ physical_attributes_clause()
  | modify_mv_column_clause()
  | table_compression()
  | inmemory_alter_table_clause()
  | LOB_storage_clause() (< SQL_COMMA_CHAR > LOB_storage_clause() )+
  | modify_LOB_storage_clause() (< SQL_COMMA_CHAR > modify_LOB_storage_clause() )+
  | alter_table_partitioning()
  | parallel_clause()
  | logging_clause()
  | allocate_extent_clause()
  | deallocate_unused_clause()
  | shrink_clause()
  | ( < CACHE > | < NOCACHE > )
  ]
  [ alter_iot_clauses() ]
  [ < SQL_USING> < SQL_INDEX> physical_attributes_clause() ]
  [ < MODIFY > scoped_table_ref_constraint()
  | alter_mv_refresh()
  ]
  [ evaluation_edition_clause() ]
  [ alter_query_rewrite_clause() 
  | < COMPILE >
  | < CONSIDER> < FRESH>] 
}

void modify_mv_column_clause() : 
{}
{

< MODIFY > ( column() [ < ENCRYPT > encryption_spec()
       | < DECRYPT > ] 
       )
}
void table_compression() : 
{}
{

< COMPRESS >
| < ROW >< STORE ><COMPRESS > [ < BASIC > | < ADVANCED > ]
| < COLUMN ><STORE ><COMPRESS > [ <  FOR > ( < QUERY > | < ARCHIVE > ) [ < LOW > | < HIGH > ] ]
  [ [< NO >] < ROW ><LEVEL ><LOCKING > ]
| < NOCOMPRESS >
}
void inmemory_alter_table_clause() : 
{}
{
( < INMEMORY > [ inmemory_parameters() ] |  inmemory_column_clause() )+
| < NO> < INMEMORY>
}
void inmemory_parameters() : 
{}
{
inmemory_memcompress() 
|  inmemory_priority() 
|  inmemory_distribute() 
|  inmemory_duplicate() 
}
void inmemory_memcompress() : 
{}
{

< MEMCOMPRESS> < FOR>( < DML > | < QUERY > [ < LOW > | < HIGH > ] | < CAPACITY > [ < LOW > | < HIGH > ] )
| < NO> < MEMCOMPRESS>}
void inmemory_priority() : 
{}
{

< PRIORITY > ( < NONE > | < LOW > | < MEDIUM > | < HIGH > | < CRITICAL > )
}
void inmemory_distribute() : 
{}
{

< DISTRIBUTE > [ < AUTO > | < SQL_BY> ( < ROWID> < RANGE>| < PARTITION > | < SUBPARTITION > ) ]
}
void inmemory_duplicate() : 
{}
{

< DUPLICATE > | < DUPLICATE> < SQL_ALL>| < NO> < DUPLICATE>}
void inmemory_column_clause() : 
{}
{

( < INMEMORY > [ inmemory_memcompress() ] | < NO> < INMEMORY>) ( column() (< SQL_COMMA_CHAR > column() )+ )
 ( ( < INMEMORY > [ inmemory_memcompress() ] | < NO> < INMEMORY>) ( column() (< SQL_COMMA_CHAR > column() )+ ) )*
}
void lob_storage_clause() : 
{}
{

< LOB >
( (LOB_item() (< SQL_COMMA_CHAR > LOB_item() )+)
     <STORE > < SQL_AS> ( ( < SECUREFILE > | <  BASICFILE > )
              | (LOB_storage_parameters())
              )+
| (LOB_item())
     <STORE > < SQL_AS> ( ( < SECUREFILE >  | <  BASICFILE >)
              | LOB_segname() 
              | (LOB_storage_parameters())
              )+
)
}
void lob_storage_parameters() : 
{}
{

( ( < TABLESPACE > tablespace()
  | LOB_parameters() [storage_clause()]
  )+
| storage_clauase()
)
}
void lob_parameters() : 
{}
{

( ( < ENABLE > | < DISABLE > ) < STORAGE >< SQL_IN><ROW >
  | < CHUNK > integer()
  | < PCTVERSION > integer()
  | < FREEPOOLS > integer()
  | LOB_retention_clause()
  | LOB_deduplicate_clause()
  | LOB_compression_clause()
  | ( < ENCRYPT > encryption_spec() | < DECRYPT > )
  | ( < CACHE > | < NOCACHE > | < CACHE> < READS>) [ logging_clause() ] 
)+
}
void modify_lob_storage_clause() : 
{}
{

< MODIFY> < LOB>(LOB_item())
   (modify_LOB_parameters())
}
void modify_lob_parameters() : 
{}
{

( storage_clause()
| < PCTVERSION > integer()
| < FREEPOOLS > integer()
| < REBUILD > < FREEPOOLS >
| LOB_retention_clause()
| LOB_deduplicate_clause()
| LOB_compression_clause()
| ( < ENCRYPT > encryption_spec() | < DECRYPT > )
| ( < CACHE > 
  | ( < NOCACHE > | < CACHE> < READS>) [ logging_clause() ]
  )
| allocate_extent_clause()
| shrink_clause()
| deallocate_unused_clause()
)+
}



 


void index_org_overflow_clause() : 
{}
{

[ < INCLUDING > column_name() ]
< OVERFLOW > [ segment_attributes_clause() ]
}
void alter_overflow_clause() : 
{}
{

( add_overflow_clause()
| < OVERFLOW >
     ( segment_attributes_clause()
     | allocate_extent_clause()
     | shrink_clause()
     | deallocate_unused_clause()
     )+
)
}
void add_overflow_clause() : 
{}
{

< ADD> < OVERFLOW>[ segment_attributes_clause() ]
  [ ( < PARTITION > [ segment_attributes_clause() ]
    ( < SQL_COMMA_CHAR > < PARTITION > [ segment_attributes_clause() ] )*
    )
  ]
}
void scoped_table_ref_constraint() : 
{}
{
< SCOPE> < FOR> <SQL_LPARENCHAR> ( ref_column() | ref_attribute() ) <SQL_RPARENCHAR> < SQL_IS > [ schema() < SQL_PERIOD_CHAR > ] ( scope_table_name() | c_alias() )

}
void alter_mv_refresh() : 
{}
{

< REFRESH >
   ( ( < FAST > | < COMPLETE > | < FORCE > )
   | < SQL_ON> ( < DEMAND > | < COMMIT > )
   | ( < START> < SQL_WITH>| < NEXT > ) date()
   | < SQL_WITH>< SQL_PRIMARY>< SQL_KEY>
   | < SQL_USING>
        ( < SQL_DEFAULT >< MASTER ><ROLLBACK >< SEGMENT >
        | < MASTER ><ROLLBACK >< SEGMENT > rollback_segment()
        )
   | < SQL_USING> ( < ENFORCED > | < TRUSTED > ) < CONSTRAINTS >
   )
}
void evaluation_edition_clause() : 
{}
{

< EVALUATE> < SQL_USING>( < CURRENT> < EDITION>| < EDITION > edition() | < SQL_NULL> < EDITION>)
}
void alter_query_rewrite_clause() : 
{}
{

[ < ENABLE > | < DISABLE > ] < QUERY> < REWRITE>[ unusable_editions_clause() ]
}
void unusable_editions_clause() : 
{}
{
 < UNUSABLE> < BEFORE>( < CURRENT> < EDITION>| < EDITION > edition() ) |
 < UNUSABLE ><BEGINNING >< SQL_WITH> ( < CURRENT> < EDITION>| < EDITION > edition() | < SQL_NULL> < EDITION>  ) 
}
void alter_materialized_view_log() : 
{}
{

< ALTER >< MATERIALIZED ><VIEW >< SQL_ORA_LOG> [ < FORCE > ]
  < SQL_ON> [ schema()< SQL_PERIOD_CHAR > ]table()
  [ physical_attributes_clause()
  | add_mv_log_column_clause()
  | alter_table_partitioning()
  | parallel_clause()
  | logging_clause()
  | allocate_extent_clause()
  | shrink_clause()
  | move_mv_log_clause()
  | ( < CACHE > | < NOCACHE > )
  ] [ mv_log_augmentation() ] [  mv_log_purge_clause() ] [ for_refresh_clause() ]
  
}

void add_mv_log_column_clause() : 
{}
{

< ADD > (column())
}

 
void move_mv_log_clause() : 
{}
{

< MOVE > segment_attributes_clause() [parallel_clause()]
}

void mv_log_augmentation() : 
{}
{

< ADD > ( ( < OBJECT> < ID>| < SQL_PRIMARY> < SQL_KEY>| < ROWID >
      | < SEQUENCE >
      ) [ (column() (< SQL_COMMA_CHAR > column() )+) ]
    | (column() (< SQL_COMMA_CHAR > column() )+ )
    )
    (< SQL_COMMA_CHAR > ( ( < OBJECT> < ID>| < SQL_PRIMARY> < SQL_KEY>| < ROWID >
           | < SEQUENCE >
           )
           [ (column() (< SQL_COMMA_CHAR > column() )+) ]
         | (column() (< SQL_COMMA_CHAR > column() )+)
         )
    )*
    [ new_values_clause() ]
}
void new_values_clause() : 
{}
{

( < INCLUDING > | < EXCLUDING > ) < NEW> < SQL_VALUES>}
void mv_log_purge_clause() : 
{}
{

< PURGE > ( < IMMEDIATE > [ < SYNCHRONOUS > | < ASYNCHRONOUS > ]
      | < START> < SQL_WITH>datetime_expr() [ < NEXT > datetime_expr() 
                                 | < REPEAT> < INTERVAL>interval_expr() 
                                 ]
      | [ < START> < SQL_WITH>datetime_expr() ] ( < NEXT > datetime_expr() 
                                     | < REPEAT> < INTERVAL>interval_expr() 
                                     )
      )
}


void for_refresh_clause() : 
{}
{

( < FOR > < SYNCHRONOUS > < REFRESH > < SQL_USING>  staging_log_name()
| < FOR > < FAST > < REFRESH > 
)
}
void alter_materialized_zonemap() : 
{}
{

< ALTER > < MATERIALIZED > < ZONEMAP >  [ schema()< SQL_PERIOD_CHAR > ] zonemap_name()
  ( alter_zonemap_attributes()
  | zonemap_refresh_clause()
  | ( < ENABLE > | < DISABLE > ) < PRUNING >
  | < COMPILE >
  | < REBUILD >
  | < UNUSABLE >
  ) 
}
void alter_zonemap_attributes() : 
{}
{

( < PCTFREE > integer()
| < PCTUSED > integer()
| ( < CACHE > | < NOCACHE > )
)+
}
void zonemap_refresh_clause() : 
{}
{

< REFRESH >
[ < FAST > | < COMPLETE > | < FORCE > ]
[ < SQL_ON> ( < DEMAND > | < COMMIT > | < LOAD > | < DATA> < MOVEMENT>| < LOAD > < DATA > < MOVEMENT >  ) ]
}
void alter_operator() : 
{}
{

< ALTER > < OPERATOR > [ schema()< SQL_PERIOD_CHAR > ] operator()
  ( add_binding_clause()
  | drop_binding_clause()
  | < COMPILE >
  ) 
}
void add_binding_clause() : 
{}
{

< ADD> < BINDING>(parameter_type() (< SQL_COMMA_CHAR > parameter_type() )+)
  < RETURN > (return_type())
  [ implementation_clause() ]
  using_function_clause()
}
void implementation_clause() : 
{}
{
( < ANCILLARY> < TO>primary_operator()
    ( parameter_type() (< SQL_COMMA_CHAR > parameter_type() )+)
      (< SQL_COMMA_CHAR > primary_operator()
         ( parameter_type() (< SQL_COMMA_CHAR > parameter_type() )+)
      )+
| context_clause()
)
}
void context_clause() : 
{}
{
  (
 < SQL_WITH> < SQL_INDEX> < CONTEXT > < SQL_COMMA_CHAR >
  < SCAN> < CONTEXT>implementation_type()
  [ < COMPUTE > < ANCILLARY > < DATA >  ]
 | 
 < SQL_WITH> < COLUMN > < CONTEXT >    
  )+
}
void using_function_clause() : 
{}
{
< SQL_USING> [ schema()< SQL_PERIOD_CHAR > ] [ sql_package() < SQL_PERIOD_CHAR > | type()< SQL_PERIOD_CHAR > ] function_name()
}
void drop_binding_clause() : 
{}
{

< SQL_DROP> < BINDING>(parameter_type() (< SQL_COMMA_CHAR > parameter_type() )+)
  [ < FORCE > ]
}
void alter_outline() : 
{}
{

< ALTER> < OUTLINE>[ < PUBLIC > | < PRIVATE > ] outline()
  ( < REBUILD >
  | < RENAME> < TO>new_outline_name()
  | < CHANGE > < CATEGORY > < TO >  new_category_name()
  | ( < ENABLE > | < DISABLE > )
  )+
  
}
void alter_package() : 
{}
{

< ALTER> < PACKAGE>[ schema()< SQL_PERIOD_CHAR > ] package_name()
( package_compile_clause() | ( < EDITIONABLE > | < NONEDITIONABLE > ) )
}
void alter_pluggable_database() : 
{}
{

< ALTER > < PLUGGABLE > < DATABASE > 
  ( pdb_unplug_clause()
  | pdb_settings_clauses()
  | pdb_datafile_clause()
  | pdb_recovery_clauses()
  | pdb_change_state()
  | pdb_change_state_from_root()
  ) 
}
void pdb_unplug_clause() : 
{}
{

pdb_name() < UNPLUG> < SQL_INTO>< APOSTROPHE >filename()< APOSTROPHE >
}
void pdb_settings_clauses() : 
{}
{

[ pdb_name() ]
( < SQL_DEFAULT> < EDITION><ESQL_EQ> edition_name()
| < SQL_SET> < SQL_DEFAULT>( < BIGFILE > | < SMALLFILE > ) < TABLESPACE >
| < SQL_DEFAULT> < TABLESPACE>tablespace_name()
| < SQL_DEFAULT > < TEMPORARY > < TABLESPACE >  ( tablespace() | tablespace_group_name() )
| < RENAME > < GLOBAL_NAME > < TO >  database()< SQL_PERIOD_CHAR >domain() (< SQL_PERIOD_CHAR > domain() )+
| set_time_zone_clause()
| database_file_clauses()
| supplemental_db_logging()
| pdb_storage_clause()
| pdb_logging_clauses()
)
}
void pdb_storage_clause() : 
{}
{

< STORAGE >
  ( ( < MAXSIZE > ( < UNLIMITED > | size_clause() )
    |
    < MAX_SHARED_TEMP_SIZE > ( < UNLIMITED > | size_clause() )+ )
  |
  < UNLIMITED >
  )
}
void pdb_logging_clauses() : 
{}
{

( logging_clause()
| pdb_force_logging_clause()
)
}

void pdb_force_logging_clause() : 
{}
{

( < ENABLE > | < DISABLE > ) < FORCE > ( < LOGGING > | < NOLOGGING > )
}
void pdb_datafile_clause() : 
{}
{

[ pdb_name() ] < DATAFILE >
  ( ( ( < APOSTROPHE >filename()< APOSTROPHE > | filenumber() ) (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > | filenumber() )+ ) | < SQL_ALL> )
  ( < ONLINE > | < OFFLINE > )
}
void pdb_recovery_clauses() : 
{}
{

[ pdb_name() ] ( pdb_general_recovery()
             | ( < SQL_BEGIN> | < SQL_END> ) < BACKUP >
             | ( < ENABLE > | < DISABLE > ) < RECOVERY >
             )
}
void pdb_general_recovery() : 
{}
{

< RECOVER > [ < AUTOMATIC > ]  [ < SQL_FROM> < APOSTROPHE >location()< APOSTROPHE > ]
  [ < DATABASE >
  |
  < TABLESPACE > tablespace() (< SQL_COMMA_CHAR > tablespace() )+
  |
  < DATAFILE > ( < APOSTROPHE >filename()< APOSTROPHE > | filenumber() )
             (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > | filenumber() )+
  |
  < LOGFILE > < APOSTROPHE >filename()< APOSTROPHE >
  |
  < CONTINUE > [ < SQL_DEFAULT > ]
  ]
}
void pdb_change_state() : 
{}
{

[ pdb_name() ] ( pdb_open() | pdb_close() | pdb_save_or_discard_state() )
}
void pdb_open() : 
{}
{

< SQL_OPEN>
  ( [ < READ> < WRITE>| < READ> < ONLY>] [ < RESTRICTED > ] [ < FORCE > ]
  | [ < READ> < WRITE>] < UPGRADE > [ < RESTRICTED > ]
  | < RESETLOGS >
  )
  [ instances_clause() ]
}
void instances_clause() : 
{}
{

< INSTANCES > <ESQL_EQ> ( ( < APOSTROPHE >instance_name()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >instance_name()< APOSTROPHE > )+ )
            | < SQL_ALL> [ < EXCEPT > ( < APOSTROPHE >instance_name()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >instance_name()< APOSTROPHE > )+ ) ]
            )
}
void pdb_close() : 
{}
{

< CLOSE > [ < IMMEDIATE > ] [ instances_clause() | relocate_clause() ]
}
void relocate_clause() : 
{}
{

< RELOCATE > [ < TO > < APOSTROPHE >instance_name()< APOSTROPHE > ] 
| < NORELOCATE >
}
void pdb_save_or_discard_state() : 
{}
{

( < SAVE > | < DISCARD > ) < STATE > [ instances_clause() ]
}
void pdb_change_state_from_root() : 
{}
{

( pdb_name() (< SQL_COMMA_CHAR > pdb_name() )+ | < SQL_ALL> [ < EXCEPT > pdb_name() (< SQL_COMMA_CHAR > pdb_name() )+ ] )
( pdb_open() | pdb_close() | pdb_save_or_discard_state() )
}
void alter_procedure() : 
{}
{

< ALTER> < PROCEDURE>[ schema()< SQL_PERIOD_CHAR > ] procedure_name()
( procedure_compile_clause() | ( < EDITIONABLE > | < NONEDITIONABLE > ) )
}
void alter_profile() : 
{}
{

< ALTER> < PROFILE>profile() < SQL_LIMIT>
  ( resource_parameters() | password_parameters() )+
  [ < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> ) ] 
}
void resource_parameters() : 
{}
{

( ( < SESSIONS_PER_USER >
  | < CPU_PER_SESSION >
  | < CPU_PER_CALL >
  | < CONNECT_TIME >
  | < IDLE_TIME >
  | < LOGICAL_READS_PER_SESSION >
  | < LOGICAL_READS_PER_CALL >
  | < COMPOSITE_LIMIT >
  )
  ( integer() | < UNLIMITED > | < SQL_DEFAULT > )
| < PRIVATE_SGA >
  ( size_clause() | < UNLIMITED > | < SQL_DEFAULT > )
)
}
void password_parameters() : 
{}
{

( ( < FAILED_LOGIN_ATTEMPTS >
  | < PASSWORD_LIFE_TIME >
  | < PASSWORD_REUSE_TIME >
  | < PASSWORD_REUSE_MAX >
  | < PASSWORD_LOCK_TIME >
  | < PASSWORD_GRACE_TIME >
  )
  ( expr() | < UNLIMITED > | < SQL_DEFAULT > )
| < PASSWORD_VERIFY_FUNCTION >
  ( function() | < SQL_NULL> | < SQL_DEFAULT > )
)
}
void alter_resource_cost() : 
{}
{

< ALTER > < RESOURCE > < COST > 
  ( ( < CPU_PER_SESSION >
    | < CONNECT_TIME >
    | < LOGICAL_READS_PER_SESSION >
    | < PRIVATE_SGA >
    ) integer()
  )+
  
}
void alter_role() : 
{}
{

< ALTER> < ROLE>role()
  ( < SQL_NOT> < IDENTIFIED>| < IDENTIFIED >
      ( < SQL_BY> password()
      | < SQL_USING> [ schema()< SQL_PERIOD_CHAR > ] sql_package()
      | < EXTERNALLY >
      | < GLOBALLY >
      )
  )
  [ < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> ) ] 
}
void alter_rollback_segment() : 
{}
{

< ALTER > < ROLLBACK > < SEGMENT >  rollback_segment()
  ( < ONLINE >
  | < OFFLINE >
  | storage_clause()
  | < SHRINK > [ < TO > size_clause() ]
  )
}
void alter_sequence() : 
{}
{

< ALTER> < SEQUENCE>[ schema()< SQL_PERIOD_CHAR > ] sequence()
  ( < INCREMENT> < SQL_BY>integer()
  | ( < MAXVALUE > integer() | < NOMAXVALUE > )
  | ( < MINVALUE > integer() | < NOMINVALUE > )
  | ( < CYCLE > | < NOCYCLE > )
  | ( < CACHE > integer() | < NOCACHE > )
  | ( < SQL_ORDER> | < NOORDER > )
  | ( < KEEP > | < NOKEEP > )
  | ( < SESSION > | < GLOBAL > )
  )+

}
void alter_session() : 
{}
{

< ALTER> < SESSION>( < ADVISE > ( < COMMIT > | < ROLLBACK > | < NOTHING > )
  | < CLOSE > < DATABASE > < LINK >  dblink()
  | ( < ENABLE > | < DISABLE > ) < COMMIT > < SQL_IN> < PROCEDURE > 
  | ( < ENABLE > | < DISABLE > ) < GUARD >
  | ( < ENABLE > | < DISABLE > | < FORCE > ) < PARALLEL >
    ( < DML > | < DDL > | < QUERY > ) [ < PARALLEL > integer() ]
  | ( < ENABLE> < RESUMABLE>[ < TIMEOUT > integer() ] [ < NAME > string() ]
    | < DISABLE> < RESUMABLE>)
  | < SYNC > < SQL_WITH> < SQL_PRIMARY>   
  | alter_session_set_clause()
  ) 
}
void alter_session_set_clause() : 
{}
{

< SQL_SET> ( ( parameter_name() <ESQL_EQ> parameter_value() )+
    | < EDITION > <ESQL_EQ> edition_name()
    | < CONTAINER > <ESQL_EQ> container_name()
    | < ROW > < ARCHIVAL > < VISIBILITY >  <ESQL_EQ> ( < ACTIVE > | < SQL_ALL> )
    )
}
void alter_synonym() : 
{}
{

< ALTER > [ < PUBLIC > ] < SYNONYM > [ schema()< SQL_PERIOD_CHAR > ] synonym()
  ( < EDITIONABLE > | < NONEDITIONABLE > | < COMPILE > ) 
}
void alter_system() : 
{}
{

< ALTER> < SYSTEM>( archive_log_clause()
  | checkpoint_clause()
  | check_datafiles_clause()
  | distributed_recov_clauses()
  | < FLUSH > ( < SHARED_POOL > | < BUFFER_CACHE > | < REDO> < TO>target_db_name() [ [ < NO > ] < CONFIRM> < APPLY>] )
  | end_session_clauses()
  | < SWITCH> < LOGFILE>| ( < SUSPEND > | < RESUME > )
  | quiesce_clauses()
  | rolling_migration_clauses()
  | rolling_patch_clauses()
  | security_clauses()
  | shutdown_dispatcher_clause()
  | < REGISTER >
  | < SQL_SET> alter_system_set_clause()
        ( alter_system_set_clause() )+
  | < RESET > alter_system_reset_clause()
          ( alter_system_reset_clause() )+
  | < RELOCATE> < CLIENT>client_id()
  ) 
}
void archive_log_clause() : 
{}
{

< ARCHIVE> < SQL_ORA_LOG>[ <  INSTANCE > < APOSTROPHE >instance_name()< APOSTROPHE > ]
   ( ( < SEQUENCE > integer()
     | < CHANGE > integer()
     | < CURRENT > [ < NOSWITCH > ]
     | < SQL_GROUP> integer()
     | < LOGFILE > < APOSTROPHE >filename()< APOSTROPHE >
          [ < SQL_USING> < BACKUP > < CONTROLFILE >  ]
     | < NEXT >
     | < SQL_ALL>
     )
     [ < TO > < APOSTROPHE >location()< APOSTROPHE > ]
   )
}
void checkpoint_clause() : 
{}
{

< CHECKPOINT > [ < GLOBAL > | < LOCAL > ]
}
void check_datafiles_clause() : 
{}
{

< CHECK> < DATAFILES>[ < GLOBAL > | < LOCAL > ]
}
void distributed_recov_clauses() : 
{}
{

( < ENABLE > | < DISABLE > ) < DISTRIBUTED> < RECOVERY>}
void end_session_clauses() : 
{}
{

( < DISCONNECT> < SESSION>< APOSTROPHE >integer1()< SQL_COMMA_CHAR > integer2()< APOSTROPHE >
     [ < POST_TRANSACTION > ]
| < KILL> < SESSION>< APOSTROPHE >integer1()< SQL_COMMA_CHAR > integer2() [< SQL_COMMA_CHAR > "@"integer3()]< APOSTROPHE >
)
[ < IMMEDIATE > | < NOREPLAY > ]
}
void quiesce_clauses() : 
{}
{

< QUIESCE> < RESTRICTED>| < UNQUIESCE >
}
void rolling_migration_clauses() : 
{}
{

( < START > < ROLLING > < MIGRATION > < TO >  < APOSTROPHE >ASM_version()< APOSTROPHE >
| < STOP > < ROLLING > < MIGRATION > 
)
}
void rolling_patch_clauses() : 
{}
{

( < START > < ROLLING > < PATCH > 
| < STOP > < ROLLING > < PATCH > 
)
}
void security_clauses() : 
{}
{

( ( < ENABLE > | < DISABLE > ) < RESTRICTED> < SESSION>| < SQL_SET> < ENCRYPTION > < WALLET > < SQL_OPEN> 
    < IDENTIFIED> < SQL_BY>( "wallet_password()" | "HSM_auth_string()" )
  | < SQL_SET> < ENCRYPTION > < WALLET > < CLOSE > 
    [ < IDENTIFIED> < SQL_BY>( "wallet_password()" | "HSM_auth_string()" ) ]
  | set_encryption_key()
)
}
void set_encryption_key() : 
{}
{

( < SQL_SET> < ENCRYPTION > < SQL_KEY> 
  (
    [ "certificate_id()" ] < IDENTIFIED> < SQL_BY>"wallet_password()"
    |
    < IDENTIFIED> < SQL_BY>"HSM_auth_string()" [ < MIGRATE> < SQL_USING>"wallet_password()" ]
  )
)
}
void shutdown_dispatcher_clause() : 
{}
{

< SHUTDOWN > [ < IMMEDIATE > ] dispatcher_name()
}
void alter_system_set_clause() : 
{}
{

( set_parameter_clause()
| < USE_STORED_OUTLINES > <ESQL_EQ> (< TRUE > | < FALSE > | category_name())
| < GLOBAL_TOPIC_ENABLED > <ESQL_EQ> (< TRUE > | < FALSE >)
)
}
void set_parameter_clause() : 
{}
{

parameter_name() <ESQL_EQ>
   parameter_value() (< SQL_COMMA_CHAR > parameter_value() )+
   [ < COMMENT > <ESQL_EQ> string() ]
   [ < DEFERRED > ]
   [ ( < SCOPE > <ESQL_EQ> ( < MEMORY > | < SPFILE > | < BOTH > )
     | < SID > <ESQL_EQ> ( < APOSTROPHE >sid()< APOSTROPHE > | < APOSTROPHE ><SQL_ASTERISKCHAR>< APOSTROPHE > )
     )+
   ]
   [ < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> ) ]
}
void alter_system_reset_clause() : 
{}
{

parameter_name()
   [ ( < SCOPE > <ESQL_EQ> < SPFILE > 
     | < SID > <ESQL_EQ> ( < APOSTROPHE >sid()< APOSTROPHE > | < APOSTROPHE ><SQL_ASTERISKCHAR>< APOSTROPHE > )
     )+
   ]
}
void alter_table() : 
{}
{

< ALTER> < SQL_TABLE>[ schema()< SQL_PERIOD_CHAR > ] table()
  [ alter_table_properties()
  | column_clauses()
  | constraint_clauses()
  | alter_table_partitioning()
  | alter_external_table()
  | move_table_clause()
  | modify_opaque_type()
  ]
  ( enable_disable_clause()
  | ( < ENABLE > | < DISABLE > ) ( < SQL_TABLE> < LOCK>| < SQL_ALL> < TRIGGERS>)
  )+
  
}
void alter_table_properties() : 
{}
{

( ( ( physical_attributes_clause()
    | logging_clause()
    | table_compression()
    | inmemory_alter_table_clause()
    | ilm_clause()
    | supplemental_table_logging()
    | allocate_extent_clause()
    | deallocate_unused_clause()
    | ( < CACHE > | < NOCACHE > )
    | < RESULT_CACHE > ( < MODE > (< SQL_DEFAULT >  | <  FORCE> ) )
    | upgrade_table_clause()
    | records_per_block_clause()
    | parallel_clause()
    | row_movement_clause()
    | flashback_archive_clause()
    )+
  | < RENAME> < TO>new_table_name()
  ) [ alter_iot_clauses() ] [ alter_xmlschema_clause() ]
|
( shrink_clause() 
  | < READ> < ONLY>| < READ> < WRITE>| < REKEY > encryption_spec() 
  | [< NO >] < ROW> < ARCHIVAL>| < ADD > attribute_clustering_clause()
  | < MODIFY> < CLUSTERING>[ clustering_when() ] [ zonemap_clause() ]
  | < SQL_DROP> < CLUSTERING>)
)
}


 
 
 
 
 
 
 
 
void ilm_clause() : 
{}
{

< ILM >
( < ADD> < POLICY>ilm_policy_clause()
| ( < SQL_DELETE> | < ENABLE > | < DISABLE > ) < POLICY > ilm_policy_name()
| < DELETE_ALL > | < ENABLE_ALL > | < DISABLE_ALL >
)
}
void ilm_policy_clause() : 
{}
{

( table_compression() | tiering_clause() )
( < SEGMENT > | < SQL_GROUP> | < ROW > )
(( < AFTER > number() ( ( < DAY > | < DAYS > ) | ( < MONTH > | < MONTHS > ) | ( < YEAR > | < YEARS > ) )
   < OF > ( ( < NO> < ACCESS>) | ( < NO> < MODIFICATION>) | < CREATION > ) )
 | < SQL_ON> function_name() )
}
void tiering_clause() : 
{}
{

< TIER> < TO>tablespace() [ < READ> < ONLY>]
}
void supplemental_table_logging() : 
{}
{

( < ADD > < SUPPLEMENTAL > < SQL_ORA_LOG> 
  ( supplemental_log_grp_clause() | supplemental_id_key_clause() )
    (< SQL_COMMA_CHAR > < SUPPLEMENTAL> < SQL_ORA_LOG>( supplemental_log_grp_clause() | supplemental_id_key_clause() )
    )+
| < SQL_DROP> < SUPPLEMENTAL > < SQL_ORA_LOG> 
  ( supplemental_id_key_clause() | < SQL_GROUP> log_group() )
    (< SQL_COMMA_CHAR > < SUPPLEMENTAL> < SQL_ORA_LOG>( supplemental_id_key_clause() | < SQL_GROUP> log_group() )
    )+
)
}
void supplemental_log_grp_clause() : 
{}
{

< SQL_GROUP> log_group()
(column() [ < NO> < SQL_ORA_LOG>]
  ( < SQL_COMMA_CHAR > column() [ < NO> < SQL_ORA_LOG>] )* )
  [ < ALWAYS > ]
}
void supplemental_id_key_clause() : 
{}
{

< DATA >
( ( < SQL_ALL> | < SQL_PRIMARY> < SQL_KEY>| < UNIQUE > | < FOREIGN> < SQL_KEY>)
    (< SQL_COMMA_CHAR > ( < SQL_ALL> | < SQL_PRIMARY> < SQL_KEY>| < UNIQUE > | < FOREIGN> < SQL_KEY>) )+
)
< COLUMNS >
}


void upgrade_table_clause() : 
{}
{

< UPGRADE > [ [< SQL_NOT > ] < INCLUDING> < DATA>]
   [ column_properties() ]
}
void records_per_block_clause() : 
{}
{

( < MINIMIZE > | < NOMINIMIZE > ) < RECORDS_PER_BLOCK >
}
void row_movement_clause() : 
{}
{

( < ENABLE > | < DISABLE > ) < ROW> < MOVEMENT>}
void flashback_archive_clause() : 
{}
{

< FLASHBACK> < ARCHIVE>[flashback_archive()] | < NO > < FLASHBACK > < ARCHIVE > 
}
void alter_iot_clauses() : 
{}
{

( index_org_table_clause()
| alter_overflow_clause()
| alter_mapping_table_clauses()
| < SQL_ORA_COALESCE>
)
}
void index_org_table_clause() : 
{}
{
 ( mapping_table_clause()
  | < PCTTHRESHOLD > integer()
  | prefix_compression()
  )+

[ index_org_overflow_clause() ]
}


 


 
 
 
 

 
void alter_mapping_table_clauses() : 
{}
{

< MAPPING> < SQL_TABLE>( allocate_extent_clause()
  | deallocate_unused_clause()
  )
}

void attribute_clustering_clause() : 
{}
{

< CLUSTERING > [ clustering_join() ] cluster_clause()
           [ clustering_when() ] [ zonemap_clause() ]
}
void clustering_join() : 
{}
{
[ schema()< SQL_PERIOD_CHAR >] table() < SQL_JOIN> [ schema()< SQL_PERIOD_CHAR > ] table() < SQL_ON> ( equijoin_condition() )
                    ( < SQL_COMMA_CHAR > < SQL_JOIN> [ schema()< SQL_PERIOD_CHAR > ] table() < SQL_ON> <SQL_LPARENCHAR> equijoin_condition() <SQL_RPARENCHAR> )*
}
void cluster_clause() : 
{}
{

< SQL_BY> [ < LINEAR > | < INTERLEAVED > ] < SQL_ORDER> clustering_columns()
}
void clustering_columns() : 
{}
{

clustering_column_group()
| ( clustering_column_group() (< SQL_COMMA_CHAR > clustering_column_group() )+ )
}
void clustering_column_group() : 
{}
{

( column() (< SQL_COMMA_CHAR > column() )+ )
}
void clustering_when() : 
{}
{
(
 ( < YES > | < NO > ) < SQL_ON> < LOAD> 
 ( < YES > | < NO > ) < SQL_ON> < DATA > < MOVEMENT >
)+   
}
void zonemap_clause() : 
{}
{

( < SQL_WITH> < MATERIALIZED > < ZONEMAP >  [ ( zonemap_name() ) ] )
|
( < WITHOUT > < MATERIALIZED > < ZONEMAP >  )
}
void column_clauses() : 
{}
{

( ( add_column_clause()
  | modify_column_clause()
  | drop_column_clause()
  | add_period_clause()
  | drop_period_clause()
  )+
| rename_column_clause()
| ( modify_collection_retrieval() )+
| ( modify_LOB_storage_clause() )+
| ( alter_varray_col_properties() )+
)
}
void add_column_clause() : 
{}
{

< ADD >
   (column_definition() | virtual_column_definition()
      (< SQL_COMMA_CHAR > column_definition() | virtual_column_definition())+
   )
   [ column_properties() ]
   [ out_of_line_part_storage() (< SQL_COMMA_CHAR > out_of_line_part_storage())+]
}
void column_definition() : 
{}
{

column() datatype() [ < SORT > ] [ < VISIBLE > | < INVISIBLE > ]
  [ < SQL_DEFAULT > [ < SQL_ON> < SQL_NULL>] expr() | identity_clause() ]
  [ < ENCRYPT > encryption_spec() ]
  [ ( ( inline_constraint() )+ )
  | inline_ref_constraint()
  ]
}
void identity_clause() : 
{}
{

< GENERATED >
[ < ALWAYS > | < SQL_BY> < SQL_DEFAULT > [ < SQL_ON> < SQL_NULL> ] ]
< SQL_AS> < IDENTITY > [ ( identity_options() ) ]
}
void identity_options() : 
{}
{

( < START > < SQL_WITH> ( integer() | < SQL_LIMIT> < SQL_ORA_VALUE>)
| < INCREMENT > < SQL_BY> integer()
| ( < MAXVALUE > integer() | < NOMAXVALUE > )
| ( < MINVALUE > integer() | < NOMINVALUE > )
| ( < CYCLE > | < NOCYCLE > )
| ( < CACHE > integer() | < NOCACHE > )
| ( < SQL_ORDER> | < NOORDER > ) )+
}
void virtual_column_definition() : 
{}
{

column() [ datatype() ] [ < VISIBLE > | < INVISIBLE > ]
  [ < GENERATED> < ALWAYS>] < SQL_AS> <SQL_LPARENCHAR> column_expression() <SQL_RPARENCHAR> [ < VIRTUAL > ]
  [ evaluation_edition_clause() ] [ unusable_editions_clause() ]
  ( inline_constraint() )*
}

 
void modify_column_clauses() : 
{}
{

< MODIFY >
( ( modify_col_properties() | modify_virtcol_properties()
    (< SQL_COMMA_CHAR > modify_col_properties() | modify_virtcol_properties() )+ )
| ( modify_col_visibility() (< SQL_COMMA_CHAR > modify_col_visibility() )+ )
| modify_col_substitutable()
)
}
void modify_col_properties() : 
{}
{

column() [ datatype() ]
       [ < SQL_DEFAULT > [ < SQL_ON> < SQL_NULL>] expr() | identity_clause() | < SQL_DROP> < IDENTITY > ]
       [ ( < ENCRYPT > encryption_spec() | < DECRYPT > ) ] 
       ( inline_constraint() )*
       [ LOB_storage_clause() ]
       [ alter_xmlschema_clause() ]
}
void encryption_spec() : 
{}
{

< SQL_USING> < APOSTROPHE >encrypt_algorithm()< APOSTROPHE > 
| < IDENTIFIED > < SQL_BY> password() 
| < APOSTROPHE >integrity_algorithm()< APOSTROPHE > 
| [ < NO > ] < SALT > 
}
void modify_virtcol_properties() : 
{}
{

column() [ datatype() ]
[ < GENERATED> < ALWAYS>] < SQL_AS> <SQL_LPARENCHAR> column_expression() <SQL_RPARENCHAR> [ < VIRTUAL > ]
evaluation_edition_clause() [ unusable_editions_clause() ]
}
void modify_col_visibility() : 
{}
{

column() ( < VISIBLE > | < INVISIBLE > )
}
void modify_col_substitutable() : 
{}
{

< COLUMN > column()
[ < SQL_NOT > ] < SUBSTITUTABLE > < AT > < SQL_ALL> < LEVELS > 
[ < FORCE > ]
}
void drop_column_clause() : 
{}
{

( < SQL_SET> < UNUSED>( < COLUMN > column()
             | (column() (< SQL_COMMA_CHAR > column() )+)
             )
  [ ( < CASCADE> < CONSTRAINTS>| < INVALIDATE > )+ ]
  [ < ONLINE > ]
| < SQL_DROP> ( < COLUMN > column()
       | (column() (< SQL_COMMA_CHAR > column() )+)
       )
  [ ( < CASCADE> < CONSTRAINTS>| < INVALIDATE > )+ ]
  [ < CHECKPOINT > integer() ]
| < SQL_DROP> ( < UNUSED> < COLUMNS>| < COLUMNS> < CONTINUE>)
  [ < CHECKPOINT > integer() ]
)
}
void add_period_clause() : 
{}
{

< ADD > ( period_definition() )
}
void period_definition() : 
{}
{

< PERIOD> < FOR>valid_time_column() [ ( start_time_column()< SQL_COMMA_CHAR > end_time_column() ) ]
}
void drop_period_clause() : 
{}
{

< SQL_DROP> ( < PERIOD> < FOR>valid_time_column() )
}
void rename_column_clause() : 
{}
{

< RENAME > < COLUMN > old_name() < TO > new_name()
}
void modify_collection_retrieval() : 
{}
{

< MODIFY > < NESTED > < SQL_TABLE>  collection_item()
< RETURN> < SQL_AS>( < LOCATOR > | < SQL_ORA_VALUE> )
}
void constraint_clauses() : 
{}
{

( < ADD > ( ( out_of_line_constraint() )+
      | out_of_line_REF_constraint()
      )
| < MODIFY > ( < CONSTRAINT > constraint_name()
         | < SQL_PRIMARY> < SQL_KEY>
         | < UNIQUE > (column() (< SQL_COMMA_CHAR > column() )+)
         ) constraint_state() [ < CASCADE > ]
| < RENAME > < CONSTRAINT > old_name() < TO > new_name()
| drop_constraint_clause()
)
}
void drop_constraint_clause() : 
{}
{

< SQL_DROP>
   ( ( < SQL_PRIMARY> < SQL_KEY>| < UNIQUE > (column() (< SQL_COMMA_CHAR > column() )+)
     )
     [ < CASCADE > ]
     [ ( < KEEP > | < SQL_DROP> ) < SQL_INDEX> ]
   | < CONSTRAINT > constraint_name()
     [ < CASCADE > ]
   ) [ < ONLINE > ]
}
void column_properties() : 
{}
{

( object_type_col_properties()
| nested_table_col_properties()
| ( varray_col_properties() | LOB_storage_clause() )
    [ (LOB_partition_storage() (< SQL_COMMA_CHAR > LOB_partition_storage() )+) ]
| XMLType_column_properties()
)+
}
void out_of_line_part_storage() : 
{}
{

< PARTITION > partition()
  ( nested_table_col_properties() | LOB_storage_clause() | varray_col_properties() )
    ( nested_table_col_properties() | LOB_storage_clause() | varray_col_properties() )+
[ (< SUBPARTITION > subpartition()
   ( nested_table_col_properties() | LOB_storage_clause() | varray_col_properties() )
     ( nested_table_col_properties() | LOB_storage_clause() | varray_col_properties()
     )+
  )
]
}
void object_type_col_properties() : 
{}
{

< COLUMN > column() substitutable_column_clause()
}
void substitutable_column_clause() : 
{}
{

( [ < ELEMENT > ] < SQL_IS> < OF>[ < TYPE > ] <SQL_LPARENCHAR> [< ONLY >] type() <SQL_RPARENCHAR>
| [ < SQL_NOT > ] < SUBSTITUTABLE > < AT > < SQL_ALL> < LEVELS > 
)
}
void nested_table_col_properties() : 
{}
{

< NESTED> < SQL_TABLE>( nested_item() | < COLUMN_VALUE > )
[ substitutable_column_clause() ]
[ < LOCAL >  | <  GLOBAL > ]
< STORE> < SQL_AS>storage_table()
[ <SQL_LPARENCHAR> <SQL_LPARENCHAR> (object_properties() <SQL_RPARENCHAR>
    |  physical_properties() 
    |  column_properties() 
    )+
  <SQL_RPARENCHAR>
]
[ < RETURN > [ < SQL_AS> ]  ( < LOCATOR > | < SQL_ORA_VALUE> ) ]
}
void object_properties() : 
{}
{

( ( column() | attribute() )
    [ < SQL_DEFAULT > expr() ]
    [ ( inline_constraint() )+  | inline_ref_constraint() ]
| ( out_of_line_constraint()
  | out_of_line_ref_constraint()
  | supplemental_logging_props()
  )
)
}
void supplemental_logging_props() : 
{}
{

< SUPPLEMENTAL> < SQL_ORA_LOG>( supplemental_log_grp_clause()
                 | supplemental_id_key_clause()
                 )
}
void physical_properties() : 
{}
{

( [ deferred_segment_creation() ] segment_attributes_clause() [ table_compression() ]
    [ inmemory_table_clause() ] [ ilm_clause() ] 
| [ deferred_segment_creation() ] < ORGANIZATION >
  ( < HEAP > [ segment_attributes_clause() ] heap_org_table_clause() 
  | < SQL_INDEX> [ segment_attributes_clause() ] index_org_table_clause()
  | < EXTERNAL > external_table_clause()
  )
| < CLUSTER > cluster() (column() (< SQL_COMMA_CHAR > column() )+)
)
}
void deferred_segment_creation() : 
{}
{

< SEGMENT> < CREATION>( < IMMEDIATE > | < DEFERRED > )
}
void heap_org_table_clause() : 
{}
{

[ table_compression() ] [ inmemory_table_clause() ] [ ilm_clause() ]
}
void varray_col_properties() : 
{}
{

< VARRAY > varray_item() 
( [ substitutable_column_clause() ] varray_storage_clause()
| substitutable_column_clause()
)
}
void varray_storage_clause() : 
{}
{

<STORE > < SQL_AS> [ < SECUREFILE >  | <  BASICFILE > ] < LOB >
( [LOB_segname()] ( LOB_storage_parameters() )
| LOB_segname()
)
}
 
 
 
 
 
void lob_retention_clause() : 
{}
{

< RETENTION > [ < SQL_ORA_MAX> | < SQL_ORA_MIN> integer() | < AUTO > | < NONE > ]
}
void lob_deduplicate_clause() : 
{}
{

( < DEDUPLICATE  >  
| < KEEP_DUPLICATES >
)
}
void lob_compression_clause() : 
{}
{
( < COMPRESS > [ < HIGH > | <  MEDIUM > | <  LOW > ] | <  NOCOMPRESS > )
}
void alter_varray_col_properties() : 
{}
{

< MODIFY> < VARRAY>varray_item()
   ( modify_LOB_parameters() )
}
void lob_partition_storage() : 
{}
{

< PARTITION > partition()
( LOB_storage_clause() | varray_col_properties() )+
  [ (< SUBPARTITION > subpartition()
     ( LOB_partitioning_storage() | varray_col_properties() )+
    )
]
}
void lob_partitioning_storage() : 
{}
{

< LOB > (LOB_item()) < STORE> < SQL_AS>[< BASICFILE >  | <  SECUREFILE > ]
  [ LOB_segname() [ (< TABLESPACE > tablespace()) ]
  | (< TABLESPACE > tablespace())
  ]
}
void xmltype_column_properties() : 
{}
{

< XMLTYPE > [ < COLUMN > ] column()
   [ XMLType_storage() ]
   [ XMLSchema_spec() ]
}
void xmltype_storage() : 
{}
{

< STORE >
( < SQL_AS>
( < OBJECT> < RELATIONAL>| [< SECUREFILE >  | <  BASICFILE >]
  ( < CLOB > | < BINARY> < XML>)
    [ ( LOB_segname() [ (LOB_parameters()) ]
      | (LOB_parameters())
      )
    ]
)
| ( < SQL_ALL> < VARRAYS > < SQL_AS>  ( < LOBS > | < TABLES > ) )
)
}
void xmlschema_spec() : 
{}
{

[ < XMLSCHEMA > XMLSchema_URL() ]
< ELEMENT > ( element() | XMLSchema_URL() "#" element() )
  [ < STORE > < SQL_ALL> < VARRAYS > < SQL_AS>  ( < LOBS > | < TABLES > ) ]
  [ ( < ALLOW > | < DISALLOW > ) < NONSCHEMA > ]
  [ ( < ALLOW > | < DISALLOW > ) < ANYSCHEMA > ]
}
void alter_xmlschema_clause() : 
{}
{

( < ALLOW >  < ANYSCHEMA >
  | <  ALLOW >  < NONSCHEMA >
  | <  DISALLOW >  < NONSCHEMA >
  )
}
void alter_external_table() : 
{}
{

( add_column_clause()
| modify_column_clauses()
| drop_column_clause()
| parallel_clause()
| external_data_properties()
| < REJECT> < SQL_LIMIT>( integer() | < UNLIMITED > )
| < PROJECT> < COLUMN>( < SQL_ALL> | < REFERENCED > )
)
  ( add_column_clause()
  | modify_column_clauses()
  | drop_column_clause()
  | parallel_clause()
  | external_data_properties()
  | < REJECT> < SQL_LIMIT>( integer() | < UNLIMITED > )
  | < PROJECT> < COLUMN>( < SQL_ALL> | < REFERENCED > )
  )+
}
void external_data_properties() : 
{}
{

< SQL_DEFAULT> < DIRECTORY>directory()
[ < ACCESS> < PARAMETERS>( (opaque_format_spec())
  | < SQL_USING> < CLOB>subquery()
  )
]
< LOCATION >
   ([ directory()":" ] < APOSTROPHE >location_specifier()< APOSTROPHE >
      (
        < SQL_COMMA_CHAR > [ directory()":" ] < APOSTROPHE >location_specifier()< APOSTROPHE > )*
   )
}
void alter_table_partitioning() : 
{}
{

( modify_table_default_attrs()
| alter_interval_partitioning()
| set_subpartition_template()
| modify_table_partition()
| modify_table_subpartition()
| move_table_partition()
| move_table_subpartition()
| add_table_partition()
| coalesce_table_partition()
| drop_table_partition()
| drop_table_subpartition()
| rename_partition_subpart()
| truncate_partition_subpart()
| split_table_partition()
| split_table_subpartition()
| merge_table_partitions()
| merge_table_subpartitions()
| exchange_partition_subpart()
)
}
void modify_table_default_attrs() : 
{}
{

< MODIFY > < SQL_DEFAULT > < ATTRIBUTES > 
   [ < FOR > partition_extended_name() ]
   [ deferred_segment_creation() ]
   [ indexing_clause() ]
   [ segment_attributes_clause() ]
   [ table_compression() ]
   [ inmemory_clause() ]
   [ < PCTTHRESHOLD > integer() ]
   [ prefix_compression() ]
   [ alter_overflow_clause() ]
   ( ( < LOB > (LOB_item()) | < VARRAY > varray() ) (LOB_parameters()) )+
}
void indexing_clause() : 
{}
{

< INDEXING > ( < SQL_ON> | < OFF > )
}
void inmemory_clause() : 
{}
{
(
  < INMEMORY > [ inmemory_parameters() ]
| < NO> < INMEMORY>
)
}
void alter_interval_partitioning() : 
{}
{
( < SQL_SET> < INTERVAL> <SQL_LPARENCHAR>  [expr()] <SQL_RPARENCHAR>
| < SQL_SET> < STORE > < SQL_IN>  <SQL_LPARENCHAR> tablespace() (< SQL_COMMA_CHAR > tablespace())+ <SQL_RPARENCHAR>
)
}
void set_subpartition_template() : 
{}
{

< SQL_SET> < SUBPARTITION > < TEMPLATE > 
   ( ( range_subpartition_desc() (< SQL_COMMA_CHAR > range_subpartition_desc())+ )
   | ( list_subpartition_desc() (< SQL_COMMA_CHAR > list_subpartition_desc())+ )
   | ( individual_hash_subparts() (< SQL_COMMA_CHAR > individual_hash_subparts())+ )
   | <SQL_LPARENCHAR> <SQL_RPARENCHAR>
   | hash_subpartition_quantity()
   )
}
void modify_table_partition() : 
{}
{

( modify_range_partition()
| modify_hash_partition()
| modify_list_partition()
)
}
void modify_range_partition() : 
{}
{

< MODIFY > partition_extended_name()
   ( partition_attributes()
   | ( add_range_subpartition()
     | add_hash_subpartition()
     | add_list_subpartition()
     )
   | coalesce_table_subpartition()
   | alter_mapping_table_clause()
   | [ < REBUILD > ] < UNUSABLE > < LOCAL > < INDEXES >
   | indexing_clause()
   )
}
void modify_hash_partition() : 
{}
{

< MODIFY > partition_extended_name()
  ( partition_attributes()
  | coalesce_table_subpartition()
  | alter_mapping_table_clause()
  | [ < REBUILD > ] < UNUSABLE > < LOCAL > < INDEXES >
  | indexing_clause()
  )
}
void modify_list_partition() : 
{}
{

< MODIFY > partition_extended_name()
  ( partition_attributes()
  | ( < ADD > | < SQL_DROP> ) < SQL_VALUES> (literal()( < SQL_COMMA_CHAR > literal() )+)
  | ( add_range_subpartition()
    | add_list_subpartition()
    | add_hash_subpartition() 
    )
  | coalesce_table_subpartition()
  | [ < REBUILD > ] < UNUSABLE > < LOCAL > < INDEXES > 
  | indexing_clause()
  )
}
void modify_table_subpartition() : 
{}
{

< MODIFY > subpartition_extended_name()
( allocate_extent_clause()
| deallocate_unused_clause()
| shrink_clause()
| ( ( < LOB > LOB_item() | < VARRAY > varray() ) (modify_LOB_parameters()) )+
| [ < REBUILD > ] < UNUSABLE > < LOCAL > < INDEXES > 
| ( < ADD > | < SQL_DROP> ) < SQL_VALUES> ( literal() (< SQL_COMMA_CHAR > literal())+ )
| indexing_clause()
)
}
void move_table_partition() : 
{}
{

< MOVE > partition_extended_name()
   [ < MAPPING> < SQL_TABLE>]
   [ table_partition_description() ]
   [ update_index_clauses() ]
   [ parallel_clause() ]
   [ allow_disallow_clustering() ]
   [ < ONLINE > ]
}
void allow_disallow_clustering() : 
{}
{

( < ALLOW > | < DISALLOW > ) < CLUSTERING >
}
void move_table_subpartition() : 
{}
{

< MOVE > subpartition_extended_name() [ indexing_clause() ]
     [ partitioning_storage_clause() ] [ update_index_clauses() ]
     [ parallel_clause() ] [ allow_disallow_clustering() ] [ < ONLINE > ]
}
void add_table_partition() : 
{}
{

< ADD > (
< PARTITION > [ partition() ] add_range_partition_clause()
  (
    < SQL_COMMA_CHAR > < PARTITION > [ partition() ] add_range_partition_clause() )*
| < PARTITION > [ partition() ] add_list_partition_clause()
  (
    < SQL_COMMA_CHAR > < PARTITION > [ partition() ] add_list_partition_clause() )*
| < PARTITION > [ partition() ] add_system_partition_clause()
  (
    < SQL_COMMA_CHAR > < PARTITION > [ partition() ] add_system_partition_clause() )*
  [ < BEFORE > ( partition_name() | partition_number() ) ]
| < PARTITION > [ partition() ] add_hash_partition_clause()
) [ dependent_tables_clause() ]
}


void add_list_partition_clause() : 
{}
{

list_values_clause()
[ table_partition_description() ]
[ <SQL_LPARENCHAR> ( range_subpartition_desc() ( < SQL_COMMA_CHAR > range_subpartition_desc())*
    | list_subpartition_desc()  ( < SQL_COMMA_CHAR > list_subpartition_desc())*
    | individual_hash_subparts() ( < SQL_COMMA_CHAR > individual_hash_subparts() )* 
    )
  <SQL_RPARENCHAR> | hash_subparts_by_quantity() ]
[ update_index_clauses() ]
}

void add_range_partition_clause() : 
{}
{
list_values_clause()
range_values_clause()
[ table_partition_description() ]
[ <SQL_LPARENCHAR> ( range_subpartition_desc() (< SQL_COMMA_CHAR > range_subpartition_desc())+
    | list_subpartition_desc() (< SQL_COMMA_CHAR > list_subpartition_desc())+
    | individual_hash_subparts() (< SQL_COMMA_CHAR > individual_hash_subparts())+
    )
  <SQL_RPARENCHAR> | hash_subparts_by_quantity() ]
[ update_index_clauses() ]
}
void add_hash_partition_clause() : 
{}
{

partitioning_storage_clause()
[ update_index_clauses() ]
[ parallel_clause() ]
[ indexing_clause() ]
}




void add_system_partition_clause() : 
{}
{
 table_partition_description() |  update_index_clauses() 
}
void add_range_subpartition() : 
{}
{

< ADD > range_subpartition_desc() (< SQL_COMMA_CHAR > range_subpartition_desc() )+
[ dependent_tables_clause() ] [ update_index_clauses() ]
}
void add_hash_subpartition() : 
{}
{

< ADD > individual_hash_subparts()
   [ dependent_tables_clause() ]
   [ update_index_clauses() ]
   [ parallel_clause() ]
}
void add_list_subpartition() : 
{}
{

< ADD > list_subpartition_desc() (< SQL_COMMA_CHAR > list_subpartition_desc() )+
[ dependent_tables_clause() ] [ update_index_clauses() ]
}
void dependent_tables_clause() : 
{}
{

< DEPENDENT> < TABLES><SQL_LPARENCHAR> table() <SQL_LPARENCHAR> partition_spec() ( < SQL_COMMA_CHAR > partition_spec() )+ <SQL_RPARENCHAR>
          [ < SQL_COMMA_CHAR > table() <SQL_LPARENCHAR> partition_spec() ( < SQL_COMMA_CHAR > partition_spec() )+ <SQL_RPARENCHAR> ]
         <SQL_RPARENCHAR>
}
void coalesce_table_partition() : 
{}
{

< SQL_ORA_COALESCE> < PARTITION>[ update_index_clauses() ]
  [ parallel_clause() ]
  [ allow_disallow_clustering() ]
}
void coalesce_table_subpartition() : 
{}
{

< SQL_ORA_COALESCE> < SUBPARTITION>subpartition()
  [update_index_clauses()]
  [parallel_clause()]
  [allow_disallow_clustering()]
}
void drop_table_partition() : 
{}
{

< SQL_DROP> partition_extended_names()
  [ update_index_clauses() [ parallel_clause() ] ]
}
void drop_table_subpartition() : 
{}
{

< SQL_DROP> subpartition_extended_names()
  [ update_index_clauses() [ parallel_clause() ] ]
}
void rename_partition_subpart() : 
{}
{

< RENAME > ( partition_extended_name()
       | subpartition_extended_name()
       ) < TO > new_name()
}
void truncate_partition_subpart() : 
{}
{

< SQL_TRUNCATE> ( partition_extended_names() | subpartition_extended_names() )
   [ ( < SQL_DROP> [ < SQL_ALL> ] | < REUSE > ) < STORAGE > ]
   [ update_index_clauses() [ parallel_clause() ] ] [ < CASCADE > ]
}
void partition_extended_names() : 
{}
{

( < PARTITION > | < PARTITIONS > )
partition() | ( < FOR > ( partition_key_value() (< SQL_COMMA_CHAR > partition_key_value() )+ ) )
  (< SQL_COMMA_CHAR > partition() | ( < FOR > ( partition_key_value() (< SQL_COMMA_CHAR > partition_key_value() )+ ) ) )+
}
void subpartition_extended_names() : 
{}
{

( < SUBPARTITION > | < SUBPARTITIONS > )
subpartition() | ( < FOR > ( subpartition_key_value() (< SQL_COMMA_CHAR > subpartition_key_value() )+ ) )
  (< SQL_COMMA_CHAR > subpartition() | ( < FOR > ( subpartition_key_value() (< SQL_COMMA_CHAR > subpartition_key_value() )+ ) ) )+
}
void split_table_partition() : 
{}
{

< SPLIT > partition_extended_name()
  ( < AT > (literal() (< SQL_COMMA_CHAR > literal())+ )
    [ < SQL_INTO> ( range_partition_desc()< SQL_COMMA_CHAR > range_partition_desc() ) ]
  | < SQL_VALUES> ( literal() (< SQL_COMMA_CHAR > literal())+ )
    [ < SQL_INTO> ( list_partition_desc()< SQL_COMMA_CHAR > list_partition_desc() ) ]
  | < SQL_INTO> ( ( range_partition_desc() (< SQL_COMMA_CHAR > range_partition_desc() )+
           | list_partition_desc() (< SQL_COMMA_CHAR > list_partition_desc() )+ )
         < SQL_COMMA_CHAR > partition_spec() )
  ) [ split_nested_table_part() ]
    [ dependent_tables_clause() ]
    [ update_index_clauses() ]
    [ parallel_clause() ]
    [ allow_disallow_clustering() ]
}
void split_nested_table_part() : 
{}
{

< NESTED > < SQL_TABLE> < column > < SQL_INTO> 
  ( < PARTITION > partition() [segment_attributes_clause()]< SQL_COMMA_CHAR >
    < PARTITION > partition() [segment_attributes_clause()] [split_nested_table_part()]
  ) [ split_nested_table_part() ]
}
void split_table_subpartition() : 
{}
{

< SPLIT > subpartition_extended_name()
  ( < AT > ( literal() (< SQL_COMMA_CHAR > literal())+ )
    [ < SQL_INTO> (range_subpartition_desc()< SQL_COMMA_CHAR > range_subpartition_desc()) ]
  | < SQL_VALUES> (( literal() | < SQL_NULL>  (< SQL_COMMA_CHAR > literal() | < SQL_NULL> )+))
    [ < SQL_INTO> (list_subpartition_desc()< SQL_COMMA_CHAR > list_subpartition_desc()) ]
  | < SQL_INTO> ( ( range_subpartition_desc() (< SQL_COMMA_CHAR > range_subpartition_desc() )+
           | list_subpartition_desc() (< SQL_COMMA_CHAR > list_subpartition_desc() )+ )
         < SQL_COMMA_CHAR > subpartition_spec() )
  ) [ dependent_tables_clause() ]
    [ update_index_clauses() ]
    [ parallel_clause() ]
    [ allow_disallow_clustering() ]
}
void subpartition_spec() : 
{}
{

< SUBPARTITION > [ subpartition() ] [ partitioning_storage_clause() ]
}
void merge_table_partitions() : 
{}
{
< MERGE> < PARTITIONS> partition_or_key_value()
   ( < SQL_COMMA_CHAR > partition_or_key_value() (< SQL_COMMA_CHAR > partition_or_key_value() )*
   | < TO > partition_or_key_value() )
   [ < SQL_INTO> partition_spec() ]
   [ dependent_tables_clause() ]
   [ update_index_clauses() ]
   [ parallel_clause() ]
   [ allow_disallow_clustering() ]
}
void partition_or_key_value() : 
{}
{

partition()
|
< FOR > ( partition_key_value() (< SQL_COMMA_CHAR > partition_key_value() )+ )
}
void merge_table_subpartitions() : 
{}
{

< MERGE> < SUBPARTITIONS>subpartition_or_key_value()
   ( < SQL_COMMA_CHAR > subpartition_or_key_value() (< SQL_COMMA_CHAR > subpartition_or_key_value() )+
   | < TO > subpartition_or_key_value() )
   [ < SQL_INTO> ( range_subpartition_desc() 
          | list_subpartition_desc()
          )
   ]
   [ dependent_tables_clause() ]
   [ update_index_clauses() ]
   [ parallel_clause() ]
   [ allow_disallow_clustering() ]
}
void subpartition_or_key_value() : 
{}
{

subpartition()
|
< FOR > ( subpartition_key_value() (< SQL_COMMA_CHAR > subpartition_key_value() )+ )
}
void exchange_partition_subpart() : 
{}
{

< EXCHANGE > ( partition_extended_name()
         | subpartition_extended_name()
         )
   < SQL_WITH> < SQL_TABLE>[ schema()< SQL_PERIOD_CHAR > ] table()
   [ ( < INCLUDING > | < EXCLUDING > ) < INDEXES > ]
   [ ( < SQL_WITH> | < WITHOUT > ) < VALIDATION > ]
   [ exceptions_clause() ]
   [ update_index_clauses() [ parallel_clause() ] ]
   [ < CASCADE > ]
}

void range_values_clause() : 
{}
{

< SQL_VALUES> < LESS > < THAN > 
  (( literal() | < MAXVALUE > )
     (< SQL_COMMA_CHAR > ( literal() | < MAXVALUE > ) )+
  )
}
void list_values_clause() : 
{}
{

< SQL_VALUES> (( literal() | < SQL_NULL> )
        (< SQL_COMMA_CHAR > ( literal() | < SQL_NULL> ))+
       | < SQL_DEFAULT >
       )
}
void table_partition_description() : 
{}
{
 (
 deferred_segment_creation() |
 indexing_clause() | 
 segment_attributes_clause() |
 table_compression() | prefix_compression() |
 inmemory_clause() |
 < OVERFLOW > [ segment_attributes_clause() ] |
 ( LOB_storage_clause()
  | varray_col_properties()
  | nested_table_col_properties()
  )+
 )+
}
void range_partition_desc() : 
{}
{

< PARTITION > [partition()]
range_values_clause()
table_partition_description()
[ ( ( range_subpartition_desc() (< SQL_COMMA_CHAR > range_subpartition_desc())+
    | list_subpartition_desc() (< SQL_COMMA_CHAR > list_subpartition_desc())+
    | individual_hash_subparts() (< SQL_COMMA_CHAR > individual_hash_subparts())+
    )
  ) | hash_subparts_by_quantity() ]
}
void list_partition_desc() : 
{}
{

< PARTITION > [partition()]
list_values_clause()
table_partition_description()
  [ ( range_subpartition_desc() (< SQL_COMMA_CHAR > range_subpartition_desc())+
      | list_subpartition_desc()< SQL_COMMA_CHAR > (< SQL_COMMA_CHAR > list_subpartition_desc())+
      | individual_hash_subparts() (< SQL_COMMA_CHAR > individual_hash_subparts())+
    )
    | hash_subparts_by_quantity()
  ]
}
void range_subpartition_desc() : 
{}
{

< SUBPARTITION > [subpartition()] range_values_clause()
  [indexing_clause()] [partitioning_storage_clause()]
}
void list_subpartition_desc() : 
{}
{

< SUBPARTITION > [subpartition()]
  list_values_clause()
  [indexing_clause()] [partitioning_storage_clause()]
}
void individual_hash_subparts() : 
{}
{

< SUBPARTITION > [subpartition()] [indexing_clause()] [partitioning_storage_clause()]
}
void hash_subparts_by_quantity() : 
{}
{

< SUBPARTITIONS > integer() [< STORE> < SQL_IN>( tablespace() (< SQL_COMMA_CHAR > tablespace())+ )]
}
void partitioning_storage_clause() : 
{}
{

 ( < TABLESPACE > tablespace()
  | < OVERFLOW > [< TABLESPACE > tablespace()]
  | table_compression()
  | index_compression()
  | inmemory_clause()
  | LOB_partitioning_storage()
  | < VARRAY > varray_item() < STORE > < SQL_AS>  [ < SECUREFILE >  | <  BASICFILE > ] < LOB > LOB_segname()
  )+

}
 
void partition_attributes() : 
{}
{

[ ( physical_attributes_clause()
  | logging_clause()
  | allocate_extent_clause()
  | deallocate_unused_clause()
  | shrink_clause()
  )+
]
[ < OVERFLOW >
  ( physical_attributes_clause()
  | logging_clause()
  | allocate_extent_clause()
  | deallocate_unused_clause()
  )+
]
[ table_compression() ]
[ inmemory_clause() ]
[ ( ( < LOB > LOB_item() | < VARRAY > varray() ) (modify_LOB_parameters()) )+]
}
void partition_spec() : 
{}
{

< PARTITION > [ partition() ] [ table_partition_description() ]
}
void update_index_clauses() : 
{}
{

( update_global_index_clause()
| update_all_indexes_clause()
)
}
void update_global_index_clause() : 
{}
{

( < SQL_UPDATE> | < INVALIDATE > ) < GLOBAL> < INDEXES>}
void update_all_indexes_clause() : 
{}
{
< SQL_UPDATE> < INDEXES>[ <SQL_LPARENCHAR> index() <SQL_LPARENCHAR> update_index_partition()
            | update_index_subpartition()
            <SQL_RPARENCHAR>
       (< SQL_COMMA_CHAR > (index() <SQL_LPARENCHAR> update_index_partition()
                 | update_index_subpartition()
                 <SQL_RPARENCHAR>
          )
       )+
     <SQL_RPARENCHAR>
     ]
}
void update_index_partition() : 
{}
{

index_partition_description() [ index_subpartition_clause() ]
( < SQL_COMMA_CHAR > index_partition_description() [ index_subpartition_clause() ] )*
}
void update_index_subpartition() : 
{}
{

< SUBPARTITION > [ subpartition() ] [ < TABLESPACE > tablespace() ]
( < SQL_COMMA_CHAR > < SUBPARTITION > [ subpartition() ] [ < TABLESPACE > tablespace() ] )*
}
 
void index_subpartition_clause() : 
{}
{

( < STORE> < SQL_IN>(tablespace()(< SQL_COMMA_CHAR > tablespace() )+)
| (< SUBPARTITION >
      [ subpartition() ][ < TABLESPACE > tablespace() ] [ index_compression() ] [ < USABLE > | < UNUSABLE > ]
   (
     < SQL_COMMA_CHAR > < SUBPARTITION >
         [ subpartition() ][ < TABLESPACE > tablespace() ] [ index_compression() ] [ < USABLE > | < UNUSABLE > ]
 )*
  )
)
}

void move_table_clause() : 
{}
{

< MOVE > [ < ONLINE > ]
   [ segment_attributes_clause() ]
   [ table_compression() ]
   [ index_org_table_clause() ]
   [ ( LOB_storage_clause() | varray_col_properties() )+ ]
   [ parallel_clause() ]
   [ allow_disallow_clustering() ]
}
void modify_opaque_type() : 
{}
{

< MODIFY > < OPAQUE > < TYPE >  anydata_column()
< STORE > ( type_name() (< SQL_COMMA_CHAR > type_name() )+ ) < UNPACKED >
}
void enable_disable_clause() : 
{}
{

( < ENABLE > | < DISABLE > )
[ < VALIDATE > | < NOVALIDATE > ]
( < UNIQUE > (column() (< SQL_COMMA_CHAR > column() )+)
| < SQL_PRIMARY> < SQL_KEY>| < CONSTRAINT > constraint_name()
)
[ using_index_clause() ]
[ exceptions_clause() ]
[ < CASCADE > ]
[ ( < KEEP > | < SQL_DROP> ) < SQL_INDEX> ]
}
 
 
 
void alter_tablespace() : 
{}
{

< ALTER> < TABLESPACE>tablespace()
  ( < SQL_DEFAULT > [ table_compression() ] [ inmemory_clause() ] [ storage_clause() ]
  | < MINIMUM> < EXTENT>size_clause()
  | < RESIZE > size_clause()
  | < SQL_ORA_COALESCE>
  | < SHRINK > < SPACE > < KEEP >  size_clause()
  | < RENAME> < TO>new_tablespace_name()
  | ( < SQL_BEGIN> | < SQL_END> ) < BACKUP >
  | datafile_tempfile_clauses()
  | tablespace_logging_clauses()
  | tablespace_group_clause()
  | tablespace_state_clauses()
  | autoextend_clause()
  | flashback_mode_clause()
  | tablespace_retention_clause()
  ) 
}
void datafile_tempfile_clauses() : 
{}
{

( < ADD > ( < DATAFILE > | < TEMPFILE > )
   [ file_specification() (< SQL_COMMA_CHAR > file_specification() )+ ]
| < SQL_DROP> (< DATAFILE > | < TEMPFILE > ) ( < APOSTROPHE >filename()< APOSTROPHE > | file_number() )
| < SHRINK> < TEMPFILE>( < APOSTROPHE >filename()< APOSTROPHE > | file_number() ) [< KEEP > size_clause()]
| < RENAME > < DATAFILE > < APOSTROPHE >filename()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > )+
    < TO > < APOSTROPHE >filename()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >filename()< APOSTROPHE > )+
| ( < DATAFILE > | < TEMPFILE > ) ( < ONLINE > | < OFFLINE > )
)
}
void tablespace_logging_clauses() : 
{}
{

( logging_clause()
| [ < NO > ] < FORCE > < LOGGING >
)
}
void tablespace_group_clause() : 
{}
{

< TABLESPACE> < SQL_GROUP>( tablespace_group_name() | < APOSTROPHE >< APOSTROPHE > )
}
void tablespace_state_clauses() : 
{}
{

( ( < ONLINE >
  | < OFFLINE > [ < NORMAL > | < TEMPORARY > | < IMMEDIATE > ]
  )
  | < READ > ( < ONLY > | < WRITE > )
  | ( < PERMANENT > | < TEMPORARY > )
)
}



void tablespace_retention_clause() : 
{}
{

< RETENTION > ( < GUARANTEE > | < NOGUARANTEE > )
}
void alter_trigger() : 
{}
{

< ALTER> < TRIGGER>[ schema()< SQL_PERIOD_CHAR > ] trigger_name()
  ( trigger_compile_clause()
  | ( < ENABLE > | < DISABLE > )
  | < RENAME> < TO>new_name()
  | ( < EDITIONABLE > | < NONEDITIONABLE > )
  ) 
}
void alter_type() : 
{}
{

< ALTER> < TYPE>[ schema()< SQL_PERIOD_CHAR > ] type_name()
( alter_type_clause() | ( < EDITIONABLE > | < NONEDITIONABLE > ) )
}
void alter_user() : 
{}
{

< ALTER> < SQL_ORA_USER>( user()
    ( < IDENTIFIED >
      ( < SQL_BY> password() [ < SQL_REPLACE> old_password() ]
      | < EXTERNALLY > [ < SQL_AS> < APOSTROPHE >certificate_DN()< APOSTROPHE > | < SQL_AS> < APOSTROPHE >kerberos_principal_name()< APOSTROPHE > ]
      | < GLOBALLY > [ < SQL_AS> < APOSTROPHE >[directory_DN()]< APOSTROPHE > ]
      )
    | < SQL_DEFAULT> < TABLESPACE>tablespace()
    | < TEMPORARY> < TABLESPACE>( tablespace() | tablespace_group_name() )
    | ( < QUOTA > ( size_clause()
              | < UNLIMITED >
              ) < SQL_ON> tablespace()
      )+
    | < PROFILE > profile()
    | < SQL_DEFAULT> < ROLE>( role() (< SQL_COMMA_CHAR > role() )+
                   | < SQL_ALL> [ < EXCEPT > role() (< SQL_COMMA_CHAR > role() )+ ]
                   | < NONE >
                   )
    | < PASSWORD> < EXPIRE>| < ACCOUNT > ( < LOCK > | < UNLOCK > )
    | < ENABLE> < EDITIONS>[ < FOR > object_type() (< SQL_COMMA_CHAR > object_type() )+ ] [ < FORCE > ]
    | < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> )
    | container_data_clause()
    )+
  | user() (< SQL_COMMA_CHAR > user() )+ proxy_clause()
  ) 
}
void proxy_clause() : 
{}
{

(< GRANT > < CONNECT > < THROUGH >  ( < ENTERPRISE> < USERS>| db_user_proxy() db_user_proxy_clauses() )
| < REVOKE > < CONNECT > < THROUGH >  ( < ENTERPRISE> < USERS>| db_user_proxy() ))
}
void db_user_proxy_clauses() : 
{}
{

[ < SQL_WITH>
  ( < ROLE > ( role_name() (< SQL_COMMA_CHAR > role_name())+
         | < SQL_ALL> < EXCEPT > role_name() (< SQL_COMMA_CHAR > role_name())+
         )
  | < NO > < ROLES >
  )
]
[ < AUTHENTICATION> < REQUIRED>]
}
void container_data_clause() : 
{}
{

(
< SQL_SET> < CONTAINER_DATA><ESQL_EQ> ( < SQL_ALL> | < SQL_DEFAULT > | ( container_name() (< SQL_COMMA_CHAR > container_name() )+ ) )
|
< ADD> < CONTAINER_DATA><ESQL_EQ> ( container_name() (< SQL_COMMA_CHAR > container_name() )+ )
|
< REMOVE> < CONTAINER_DATA><ESQL_EQ> ( container_name() (< SQL_COMMA_CHAR > container_name() )+ )
)
[ < FOR > [ schema()< SQL_PERIOD_CHAR > ] container_data_object() ]
}
void alter_view() : 
{}
{

< ALTER> < VIEW>[ schema()< SQL_PERIOD_CHAR > ] view()
  ( < ADD > out_of_line_constraint()
  | < MODIFY> < CONSTRAINT>constraint()
      ( < RELY > | < NORELY > )
  | < SQL_DROP> ( < CONSTRAINT > constraint()
         | < SQL_PRIMARY> < SQL_KEY>| < UNIQUE > (column() (< SQL_COMMA_CHAR > column() )+)
         )
  | < COMPILE >
  | ( < READ> < ONLY>| < READ> < WRITE>)
  | ( < EDITIONABLE > | < NONEDITIONABLE > )
  ) 
}
void analyze() : 
{}
{

< ANALYZE >
  ( ( < SQL_TABLE> [ schema()< SQL_PERIOD_CHAR > ] table()
    | < SQL_INDEX> [ schema()< SQL_PERIOD_CHAR > ] index()
    ) [ partition_extension_clause() ]
  | < CLUSTER > [ schema()< SQL_PERIOD_CHAR > ] cluster()
  )
  ( validation_clauses()
  | < LIST > < CHAINED > < ROWS >  [ into_clause() ]
  | < SQL_DELETE> [ < SYSTEM > ] < STATISTICS >
  ) 
}
 
void validation_clauses() : 
{}
{

( < VALIDATE > < SQL_ORA_REF> < SQL_UPDATE>  [ < SQL_SET> < DANGLING > < TO > < SQL_NULL>  ]
| < VALIDATE> < STRUCTURE>[ < CASCADE > ( < FAST > | < COMPLETE > ( < OFFLINE > | < ONLINE > ) [ into_clause() ] ) ]
)
}
void into_clause() : 
{}
{

< SQL_INTO> [ schema()< SQL_PERIOD_CHAR > ] table()
}
void associate_statistics() : 
{}
{

< ASSOCIATE > < STATISTICS > < SQL_WITH> 
  ( column_association() | function_association() )
  [ storage_table_clause() ] 
}
void column_association() : 
{}
{

< COLUMNS > [ schema()< SQL_PERIOD_CHAR > ]table()< SQL_PERIOD_CHAR >column()
          (
            < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]table()< SQL_PERIOD_CHAR >column() )
   using_statistics_type()
}
void function_association() : 
{}
{

( < FUNCTIONS >
     [ schema()< SQL_PERIOD_CHAR > ]function() (< SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]function() )*
| < PACKAGES >
     [ schema()< SQL_PERIOD_CHAR > ]sql_package() (< SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]sql_package() )*
| < TYPES >
     [ schema()< SQL_PERIOD_CHAR > ]type() (< SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]type() )*
| < INDEXES >
     [ schema()< SQL_PERIOD_CHAR > ]index() (< SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]index() )*
| < INDEXTYPES >
     [ schema()< SQL_PERIOD_CHAR > ]indextype() (< SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]indextype() )*
)
( using_statistics_type()
| ( default_cost_clause() [< SQL_COMMA_CHAR > default_selectivity_clause() ]
  | default_selectivity_clause() [< SQL_COMMA_CHAR > default_cost_clause() ]
  )
)
}
void using_statistics_type() : 
{}
{

< SQL_USING> ( [ schema()< SQL_PERIOD_CHAR > ] statistics_type() | < SQL_NULL> )
}
void default_cost_clause() : 
{}
{

< SQL_DEFAULT> < COST>(cpu_cost()< SQL_COMMA_CHAR > io_cost()< SQL_COMMA_CHAR > network_cost())
}
void default_selectivity_clause() : 
{}
{

< SQL_DEFAULT> < SELECTIVITY>default_selectivity()
}
 
void audit() : 
{}
{

< AUDIT >
  ( audit_operation_clause() [ auditing_by_clause() | < SQL_IN> < SESSION > < CURRENT >  ]
  | audit_schema_object_clause()
  | < NETWORK >
  | < DIRECT_PATH> < LOAD>[ auditing_by_clause() ]
  ) [ < SQL_BY> ( < SESSION > | < ACCESS > ) ]
    [ < WHENEVER > [ < SQL_NOT > ] < SUCCESSFUL > ]
    [ < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> ) ]

}
void audit_operation_clause() : 
{}
{

( ( sql_statement_shortcut()
  | < SQL_ALL>
  | < SQL_ALL> < STATEMENTS>) [< SQL_COMMA_CHAR > ( sql_statement_shortcut()
       | < SQL_ALL>
       )
    ]
| ( system_privilege()
  | < SQL_ALL> < PRIVILEGES>) [< SQL_COMMA_CHAR > ( system_privilege()
       | < SQL_ALL> < PRIVILEGES>)
    ]
)
}
void auditing_by_clause() : 
{}
{

< SQL_BY> user() (< SQL_COMMA_CHAR > user() )+
}
void audit_schema_object_clause() : 
{}
{

( sql_operation() [< SQL_COMMA_CHAR > object_option()]
| < SQL_ALL>
) auditing_on_clause()
}
void auditing_on_clause() : 
{}
{

< SQL_ON> ( [ schema()< SQL_PERIOD_CHAR > ] object()
   | < DIRECTORY > directory_name()
   | < MINING> < MODEL>[ schema()< SQL_PERIOD_CHAR > ] model()
   | < SQL > < TRANSLATION > < PROFILE >  [ schema()< SQL_PERIOD_CHAR > ] profile()
   | < SQL_DEFAULT >
   )
}
void unified_audit() : 
{}
{

< AUDIT >
  ( < POLICY > policy()
    [ ( < SQL_BY> user() (< SQL_COMMA_CHAR > user())+ ) | ( < EXCEPT > user() (< SQL_COMMA_CHAR > user())+ ) ]
    [ < WHENEVER > [ < SQL_NOT > ] < SUCCESSFUL > ]
  )
  |
  ( < CONTEXT > < NAMESPACE > namespace() < ATTRIBUTES > attribute() (< SQL_COMMA_CHAR > attribute() )+
      (< SQL_COMMA_CHAR > < CONTEXT > < NAMESPACE > namespace() < ATTRIBUTES > attribute() (< SQL_COMMA_CHAR > attribute() )+ )+
    [ < SQL_BY> user() (< SQL_COMMA_CHAR > user())+ ]
  ) 
}
void call() : 
{}
{

< CALL >
  ( routine_clause()
  | object_access_expression()
  )
  [ < SQL_INTO> ":" host_variable()
    [ [ < INDICATOR > ] ":" indicator_variable() ] ] 
}
void routine_clause() : 
{}
{

[ schema()< SQL_PERIOD_CHAR > ] [ type()< SQL_PERIOD_CHAR > | sql_package()< SQL_PERIOD_CHAR > ]
( function() | procedure() | method() )
[ "@"dblink_name() ]
<SQL_LPARENCHAR> [ argument() (< SQL_COMMA_CHAR > argument() )+ ] <SQL_RPARENCHAR>
}
 
void comment() : 
{}
{

< COMMENT> < SQL_ON>( < AUDIT> < POLICY>policy()
  | < COLUMN > [ schema()< SQL_PERIOD_CHAR > ]
      ( table()< SQL_PERIOD_CHAR > | view()< SQL_PERIOD_CHAR > | materialized_view()< SQL_PERIOD_CHAR > ) column()
  | < EDITION > edition_name()
  | < INDEXTYPE > [ schema()< SQL_PERIOD_CHAR > ] indextype()
  | < MATERIALIZED> < VIEW>materialized_view()
  | < MINING> < MODEL>[ schema()< SQL_PERIOD_CHAR > ] model()
  | < OPERATOR > [ schema()< SQL_PERIOD_CHAR > ] operator()
  | < SQL_TABLE> [ schema()< SQL_PERIOD_CHAR > ] ( table() | view() )
  )
  < SQL_IS > string() 
}
void commit() : 
{}
{
< COMMIT > [ < WORK > ]
  [ ( < COMMENT > string()  | < WRITE > [ < WAIT > | < NOWAIT > ] [ < IMMEDIATE > | < BATCH > ] )+
  | < FORCE > ( string() [< SQL_COMMA_CHAR > integer() ]
          | < CORRUPT_XID > string()
          | < CORRUPT_XID_ALL >
          )
  ] 
}
void create_audit_policy() : 
{}
{

< SQL_CREATE> < AUDIT > < POLICY >  policy()
  [ privilege_audit_clause() ] [ action_audit_clause() ] [ role_audit_clause() ]
  [ < SQL_WHEN > < APOSTROPHE >audit_condition()< APOSTROPHE > < EVALUATE> < PER>( < STATEMENT > | < SESSION > | < INSTANCE > ) ]
  [ < CONTAINER > <ESQL_EQ> ( < SQL_ALL> | < CURRENT > ) ] 
}
 
 
void create_cluster() : 
{}
{

< SQL_CREATE> < CLUSTER>[ schema()< SQL_PERIOD_CHAR > ] cluster()
  <SQL_LPARENCHAR> column() datatype() [ < SORT > ]
    (
      < SQL_COMMA_CHAR > column() datatype() [ < SORT > ] )*
  <SQL_RPARENCHAR>
  [ ( physical_attributes_clause()
    | < SIZE > size_clause()
    | < TABLESPACE > tablespace()
    | ( < SQL_INDEX>
      | [ < SINGLE> < SQL_TABLE>]
        < HASHKEYS > integer() [ < HASH> < SQL_IS>expr() ]
      )
    )+
  ]
  [ parallel_clause() ]
  [ < NOROWDEPENDENCIES > | < ROWDEPENDENCIES > ]
  [ < CACHE > | < NOCACHE > ] [ cluster_range_partitions() ] 
}


void cluster_range_partitions() : 
{}
{

< PARTITION > < SQL_BY> < RANGE > <SQL_LPARENCHAR> column()(< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR>
<SQL_LPARENCHAR> < PARTITION > [ partition() ]
    range_values_clause() table_partition_description()
      (
        < SQL_COMMA_CHAR > < PARTITION > [ partition() ]
        range_values_clause() table_partition_description()
    )*
<SQL_RPARENCHAR>
}
void create_context() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>] < CONTEXT > namespace()
  < SQL_USING> [ schema()< SQL_PERIOD_CHAR > ] sql_package()
  [ < INITIALIZED > ( < EXTERNALLY > | < GLOBALLY > )
  | < ACCESSED> < GLOBALLY>] 
}
void create_controlfile() : 
{}
{

< SQL_CREATE> < CONTROLFILE>[ < REUSE > ] [ < SQL_SET> ] < DATABASE > database()
  [ logfile_clause() ]
  ( < RESETLOGS > | < NORESETLOGS > )
  [ < DATAFILE > file_specification()
             (< SQL_COMMA_CHAR > file_specification() )+ ]
  ( < MAXLOGFILES > integer()
  | < MAXLOGMEMBERS > integer()
  | < MAXLOGHISTORY > integer()
  | < MAXDATAFILES > integer()
  | < MAXINSTANCES > integer()
  | ( < ARCHIVELOG > | < NOARCHIVELOG > )
  | < FORCE > < LOGGING >
  )+
  [ character_set_clause() ] 
}
void logfile_clause() : 
{}
{

< LOGFILE >
[ < SQL_GROUP> integer() ] file_specification()
  ( < SQL_COMMA_CHAR > [ < SQL_GROUP> integer() ] file_specification() )*
}
void character_set_clause() : 
{}
{

< CHARACTER> < SQL_SET>character_set()
}
void create_database() : 
{}
{

< SQL_CREATE> < DATABASE>[ database() ]
  ( < SQL_ORA_USER> < SYS > < IDENTIFIED > < SQL_BY>  password()
  | < SQL_ORA_USER> < SYSTEM > < IDENTIFIED > < SQL_BY>  password()
  | < CONTROLFILE> < REUSE>| < MAXDATAFILES > integer()
  | < MAXINSTANCES > integer()
  | < CHARACTER> < SQL_SET>charset()
  | < NATIONAL > < CHARACTER > < SQL_SET>  charset()
  | < SQL_SET> < SQL_DEFAULT>( < BIGFILE > | < SMALLFILE > ) < TABLESPACE >
  | database_logging_clauses()
  | tablespace_clauses()
  | set_time_zone_clause()
  | [ < BIGFILE > | < SMALLFILE > ] < USER_DATA > < TABLESPACE > tablespace_name()
      < DATAFILE > datafile_tempfile_spec() (< SQL_COMMA_CHAR > datafile_tempfile_spec() )+
  | enable_pluggable_database()
  )+ 
}
void database_logging_clauses() : 
{}
{

( < LOGFILE >
    [ < SQL_GROUP> integer() ] file_specification()
      (
        < SQL_COMMA_CHAR > [ < SQL_GROUP> integer() ] file_specification() )*
| < MAXLOGFILES > integer()
| < MAXLOGMEMBERS > integer()
| < MAXLOGHISTORY > integer()
| ( < ARCHIVELOG > | < NOARCHIVELOG > )
| < FORCE > < LOGGING >
)
}
void tablespace_clauses() : 
{}
{

( < EXTENT > < MANAGEMENT > < LOCAL >
| < DATAFILE > file_specification() (< SQL_COMMA_CHAR > file_specification() )+
| < SYSAUX> < DATAFILE>file_specification() (< SQL_COMMA_CHAR > file_specification() )+
| default_tablespace()
| default_temp_tablespace()
| undo_tablespace()
)
}
void default_tablespace() : 
{}
{

< SQL_DEFAULT> < TABLESPACE>tablespace()
[ < DATAFILE > datafile_tempfile_spec() ]
[ extent_management_clause() ]
}
void default_temp_tablespace() : 
{}
{

[ < BIGFILE > | < SMALLFILE > ]
< SQL_DEFAULT > < TEMPORARY > < TABLESPACE >  tablespace()
  [ < TEMPFILE > file_specification() (< SQL_COMMA_CHAR > file_specification() )+]
  [ extent_management_clause() ]
}
void extent_management_clause() : 
{}
{

< EXTENT > < MANAGEMENT > < LOCAL > 
  [ < AUTOALLOCATE >
  | < UNIFORM > [ < SIZE > size_clause() ]
  ]
}
void undo_tablespace() : 
{}
{

[ < BIGFILE > | < SMALLFILE > ]
< UNDO> < TABLESPACE>tablespace()
  [ < TABLESPACE > file_specification() (< SQL_COMMA_CHAR > file_specification() )+]
}
 
void enable_pluggable_database() : 
{}
{

< ENABLE > < PLUGGABLE > < DATABASE > 
  [ < SEED >
  [ file_name_convert() ]
  [ < SYSTEM > tablespace_datafile_clauses() ]
  [ < SYSAUX > tablespace_datafile_clauses() ]
  ]
}
void file_name_convert() : 
{}
{

< FILE_NAME_CONVERT > <ESQL_EQ>
  ( ( < APOSTROPHE >filename_pattern()< APOSTROPHE >< SQL_COMMA_CHAR > < APOSTROPHE >replacement_filename_pattern()< APOSTROPHE >
      (< SQL_COMMA_CHAR > < APOSTROPHE >filename_pattern()< APOSTROPHE >< SQL_COMMA_CHAR > < APOSTROPHE >replacement_filename_pattern()< APOSTROPHE > )+ )
    |
    < NONE >
  )
}
void tablespace_datafile_clauses() : 
{}
{

< DATAFILES > ( < SIZE > size_clause() | autoextend_clause() )+
}
void create_database_link() : 
{}
{

< SQL_CREATE> [ < SHARED > ] [ < PUBLIC > ] < DATABASE> < LINK>dblink()
  (
     < CONNECT> < TO>( < CURRENT_USER >
    | user() < IDENTIFIED> < SQL_BY>password() [ dblink_authentication() ]
    )
  | dblink_authentication()
)*
  [ < SQL_USING> connect_string() ] 
}

void create_dimension() : 
{}
{

< SQL_CREATE> < DIMENSION> [ schema()< SQL_PERIOD_CHAR > ] dimension()
  ( level_clause() )+
  ( hierarchy_clause()
  | attribute_clause()
  | extended_attribute_clause()
  )+

}
 


void create_directory() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>] < DIRECTORY > directory()
  < SQL_AS> < APOSTROPHE >path_name()< APOSTROPHE > 
}
void create_diskgroup() : 
{}
{

< SQL_CREATE> < DISKGROUP>diskgroup_name()
  [ ( < HIGH > | < NORMAL > | < EXTERNAL > ) < REDUNDANCY > ]
  ( [ < QUORUM > | < REGULAR > ][  < FAILGROUP > failgroup_name() ]
  < DISK > qualified_disk_clause() (< SQL_COMMA_CHAR > qualified_disk_clause())+
  )+
  [ < ATTRIBUTE > ( < APOSTROPHE >attribute_name()< APOSTROPHE > <ESQL_EQ> < APOSTROPHE >attribute_value()< APOSTROPHE > )+ ]

}
 
void create_edition() : 
{}
{

< SQL_CREATE> < EDITION>edition()
  [ < SQL_AS> < CHILD > < OF >  parent_edition() ]

}
void create_flashback_archive() : 
{}
{

< SQL_CREATE> < FLASHBACK > < ARCHIVE > < SQL_DEFAULT >  flashback_archive()
  < TABLESPACE > tablespace()
  [flashback_archive_quota()]
  [ [< NO >] < OPTIMIZE> < DATA>]
  flashback_archive_retention()

}


void create_function() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>]
[ < EDITIONABLE > | < NONEDITIONABLE > ]
< FUNCTION > plsql_function_source()
}
void create_index() : 
{}
{

< SQL_CREATE> [ < UNIQUE > | < BITMAP > ] < SQL_INDEX> [ schema()< SQL_PERIOD_CHAR > ] index()
  < SQL_ON> ( cluster_index_clause()
     | table_index_clause()
     | bitmap_join_index_clause()
     )
[ < USABLE > | < UNUSABLE > ] 
}
void cluster_index_clause() : 
{}
{

< CLUSTER > [ schema()< SQL_PERIOD_CHAR > ] cluster() index_attributes()
}
void table_index_clause() : 
{}
{

[ schema()< SQL_PERIOD_CHAR > ] table() [ t_alias() ]
<SQL_LPARENCHAR> index_expr() [ < SQL_ASC> | < SQL_DESC> ]
  (
    < SQL_COMMA_CHAR > index_expr() [ < SQL_ASC> | < SQL_DESC> ] )*
<SQL_RPARENCHAR>
  [ index_properties() ]
}
void bitmap_join_index_clause() : 
{}
{

[ schema()< SQL_PERIOD_CHAR >]table()
   <SQL_LPARENCHAR> [ [ schema()< SQL_PERIOD_CHAR > ]table()< SQL_PERIOD_CHAR > | t_alias()< SQL_PERIOD_CHAR > ]column()
     [ < SQL_ASC> | < SQL_DESC>  ]
       (
         < SQL_COMMA_CHAR > [ [ schema()< SQL_PERIOD_CHAR > ]table()< SQL_PERIOD_CHAR > | t_alias()< SQL_PERIOD_CHAR > ]column()
          [ < SQL_ASC> | < SQL_DESC> ]
     )*
   <SQL_RPARENCHAR>
   < SQL_FROM> [ schema()< SQL_PERIOD_CHAR > ]table() [ t_alias() ]
          (
            < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]table() [ t_alias() ]
      )*
   < SQL_WHERE> condition()
      [ local_partitioned_index() ] index_attributes()
}
void index_expr() : 
{}
{

( column() | column_expression() )
}
 
 



 
void domain_index_clause() : 
{}
{

indextype()
   [ local_domain_index_clause() ]
   [ parallel_clause() ]
   [ < PARAMETERS > <SQL_LPARENCHAR> < APOSTROPHE >ODCI_parameters()< APOSTROPHE > <SQL_RPARENCHAR> ]
}
void local_domain_index_clause() : 
{}
{

< LOCAL >
  [ <SQL_LPARENCHAR> < PARTITION > partition() [ < PARAMETERS > <SQL_LPARENCHAR> < APOSTROPHE >ODCI_parameters()< APOSTROPHE > <SQL_RPARENCHAR> ]
      (
        < SQL_COMMA_CHAR >  < PARTITION > partition() [ < PARAMETERS > (< APOSTROPHE >ODCI_parameters()< APOSTROPHE >) ])*
    <SQL_LPARENCHAR>
  ]
}
void xmlindex_clause() : 
{}
{

[< XDB >< SQL_PERIOD_CHAR >] < XMLINDEX > [ local_xmlindex_clause() ]
                [ parallel_clause() ]
  [ XMLIndex_parameters_clause() ]
}
void local_xmlindex_clause() : 
{}
{
< LOCAL >
  [ <SQL_LPARENCHAR> < PARTITION > partition() [ XMLIndex_parameters_clause() ]
      (
        < SQL_COMMA_CHAR > < PARTITION > partition() [ XMLIndex_parameters_clause() ] )*
    <SQL_RPARENCHAR>
  ]
}
void global_partitioned_index() : 
{}
{

< GLOBAL > < PARTITION > < SQL_BY> 
   ( < RANGE > <SQL_LPARENCHAR> column_list() <SQL_RPARENCHAR> <SQL_LPARENCHAR> index_partitioning_clause() <SQL_RPARENCHAR>
   | < HASH > (column_list()) ( individual_hash_partitions() | hash_partitions_by_quantity() )
   )
}
void individual_hash_partitions() : 
{}
{

< PARTITION > [partition()] [indexing_clause()] [ partitioning_storage_clause() ] 
  ( < SQL_COMMA_CHAR > < PARTITION > [partition()] [indexing_clause()] [partitioning_storage_clause()] )*
}
 
 
void hash_partitions_by_quantity() : 
{}
{

< PARTITIONS > hash_partition_quantity()
[ < STORE> < SQL_IN> <SQL_LPARENCHAR> tablespace() (< SQL_COMMA_CHAR > tablespace() )+ <SQL_RPARENCHAR> ]
[ table_compression() | index_compression() ]
[ < OVERFLOW > < STORE > < SQL_IN>  <SQL_LPARENCHAR> tablespace() (< SQL_COMMA_CHAR > tablespace() )+ <SQL_RPARENCHAR> ]
}
void index_partitioning_clause() : 
{}
{

< PARTITION > [ partition() ]
   < SQL_VALUES> < LESS > < THAN >  <SQL_LPARENCHAR> literal()(< SQL_COMMA_CHAR > literal())+ <SQL_RPARENCHAR>
   [ segment_attributes_clause() ]
}

void local_partitioned_index() : 
{}
{

< LOCAL >
[ on_range_partitioned_table()
| on_list_partitioned_table()
| on_hash_partitioned_table()
| on_comp_partitioned_table()
]
}
void on_range_partitioned_table() : 
{}
{

<SQL_PERIOD_CHAR> < PARTITION >
    [ partition() ]
    [ ( segment_attributes_clause()
      | index_compression()
      )+
    ] [ < USABLE > | < UNUSABLE > ]
      (
        < SQL_COMMA_CHAR > < PARTITION >
          [ partition() ]
          [ ( segment_attributes_clause()
            | index_compression()
            )+
          ] [ < USABLE > | < UNUSABLE > ]
   )*
<SQL_RPARENCHAR>
}
void on_list_partitioned_table() : 
{}
{

 <SQL_LPARENCHAR> < PARTITION >
    [ partition() ]
    [ ( segment_attributes_clause()
      | index_compression()
      )+
    ] [ < USABLE > | < UNUSABLE > ]
      (
        < SQL_COMMA_CHAR > < PARTITION >
           [ partition() ]
           [ ( segment_attributes_clause()
             | index_compression()
             )+
           ] [ < USABLE > | < UNUSABLE > ]
    )*
 <SQL_RPARENCHAR>
}
 
void on_hash_partitioned_table() : 
{}
{

( < STORE> < SQL_IN>(tablespace()(< SQL_COMMA_CHAR > tablespace() )+)
| (< PARTITION > [ partition() ] [ < TABLESPACE > tablespace() ]
    [ index_compression() ] [ < USABLE > | < UNUSABLE > ]
  (
    < SQL_COMMA_CHAR > < PARTITION > [ partition() ] [ < TABLESPACE > tablespace() ]
    [ index_compression() ] [ < USABLE > | < UNUSABLE > ])*
  )
)
}
void on_comp_partitioned_table() : 
{}
{

[ < STORE> < SQL_IN> <SQL_LPARENCHAR> tablespace() ( < SQL_COMMA_CHAR > tablespace() )+ <SQL_RPARENCHAR> ]
<SQL_LPARENCHAR> < PARTITION >
    [ partition() ]
    [ ( segment_attributes_clause()
      | index_compression()
      )+
    ] [ < USABLE > | < UNUSABLE > ] [ index_subpartition_clause() ]
      (
        < SQL_COMMA_CHAR > < PARTITION >
           [ partition() ]
           [ ( segment_attributes_clause()
             | index_compression()
             )+
           ] [ < USABLE > | < UNUSABLE > ] [ index_subpartition_clause() ]
     )*
<SQL_RPARENCHAR>
}
 

void create_indextype() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>] < INDEXTYPE > [ schema()< SQL_PERIOD_CHAR > ] indextype()
  < FOR > [ schema()< SQL_PERIOD_CHAR > ] operator() <SQL_LPARENCHAR> paramater_type() (< SQL_COMMA_CHAR > paramater_type() )+ <SQL_RPARENCHAR>
        (
          < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ] operator() (paramater_type() (< SQL_COMMA_CHAR > paramater_type() )+)
      )*
  using_type_clause()
  [< SQL_WITH> < LOCAL > <  RANGE  > < PARTITION >  ]
  [ storage_table_clause() ]

}
 

 
void create_java() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>] [ < SQL_AND> ( < RESOLVE > | < COMPILE > ) ] [ < NOFORCE > ]
  < JAVA > ( ( < SOURCE > | < RESOURCE > ) < NAMED > [ schema()< SQL_PERIOD_CHAR > ] primary_name()
       | < CLASS > [ < SCHEMA > schema() ]
       )
  [ invoker_rights_clause() ]
  [ < RESOLVER > <SQL_LPARENCHAR> (match_string() [< SQL_COMMA_CHAR >] ( schema_name() | <SQL_MINUSCHAR> ))+ <SQL_RPARENCHAR>  ]
  ( < SQL_USING> ( < BFILE > (directory_object_name()< SQL_COMMA_CHAR > server_file_name())
          | ( < CLOB > | < BLOB > | < BFILE > ) subquery()
          | < APOSTROPHE >key_for_BLOB()< APOSTROPHE >
          )
  | < SQL_AS> source_char()
  ) 
}
 
void create_library() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>]
[ < EDITIONABLE > | < NONEDITIONABLE > ]
< LIBRARY > plsql_library_source()
}
void create_materialized_view() : 
{}
{

< SQL_CREATE> < MATERIALIZED > < VIEW >  [ schema()< SQL_PERIOD_CHAR > ] materialized_view()
  [ < OF > [ schema()< SQL_PERIOD_CHAR > ] object_type() ]
  [ <SQL_LPARENCHAR>
      ( scoped_table_ref_constraint()
      | column_alias() [ < ENCRYPT > [encryption_spec()] ]
      )
      ( 
        < SQL_COMMA_CHAR > ( scoped_table_ref_constraint()
         | column_alias() [< ENCRYPT > [encryption_spec()] ]
         )
      )*
    <SQL_RPARENCHAR>
  ]
  ( < SQL_ON> < PREBUILT > < SQL_TABLE> 
    [ ( < SQL_WITH> | < WITHOUT > ) < REDUCED> < PRECISION>]
  | physical_properties() materialized_view_props()
  )
  [ < SQL_USING> < SQL_INDEX>( physical_attributes_clause()
    | < TABLESPACE > tablespace()
    )+
  | < SQL_USING> < NO > < SQL_INDEX> 
  ]
  [ create_mv_refresh() ]
  [ < FOR> < SQL_UPDATE>]
  [ evaluation_edition_clause() ]
  [ query_rewrite_clause() ]
< SQL_AS> subquery() 
}
 
 
void materialized_view_props() : 
{}
{

[ column_properties() ]
[ table_partitioning_clauses() ]
[ < CACHE > | < NOCACHE > ]
[ parallel_clause() ]
[ build_clause() ]
}


 
 
void create_mv_refresh() : 
{}
{

( < REFRESH >
  ( ( < FAST > | < COMPLETE > | < FORCE > )
  | ( < SQL_ON> < DEMAND>| < SQL_ON> < COMMIT>)
  | ( < START> < SQL_WITH>date() |
      < NEXT > date() 
    )+
  | < SQL_WITH> ( < SQL_PRIMARY> < SQL_KEY>| < ROWID > )
  | < SQL_USING>
     ( < SQL_DEFAULT > [ < MASTER > | < LOCAL > ] < ROLLBACK> < SEGMENT>| [ < MASTER > | < LOCAL > ] < ROLLBACK> < SEGMENT>rollback_segment()
     )+
  | < SQL_USING>
     ( < ENFORCED > | < TRUSTED > ) < CONSTRAINTS >
  )+
| < NEVER> < REFRESH>)
}

 


 
void inmemory_table_clause() : 
{}
{

< INMEMORY > [ inmemory_parameters() ] [ inmemory_column_clause() ]
| < NO> < INMEMORY>}
 
 
 



 
 
 
 
 
 
 
 
 

void build_clause() : 
{}
{

< BUILD > ( < IMMEDIATE > | < DEFERRED > )
}

void query_rewrite_clause() : 
{}
{

( < ENABLE > | < DISABLE > ) < QUERY> < REWRITE>[ unusable_editions_clause() ]
}
 
void create_materialized_vw_log() : 
{}
{

< SQL_CREATE> < MATERIALIZED > < VIEW > < SQL_ORA_LOG> < SQL_ON>  [ schema()< SQL_PERIOD_CHAR > ] table()
  ( physical_attributes_clause()
  | < TABLESPACE > tablespace()
  | logging_clause()
  | ( < CACHE > | < NOCACHE > )
  )+
  [ parallel_clause() ]
  [ table_partitioning_clauses() ]
  [ < SQL_WITH> [ ( < OBJECT> < ID>| < SQL_PRIMARY> < SQL_KEY>| < ROWID >
         | < SEQUENCE >
         | < COMMIT> < SCN>)
           ( ( < SQL_COMMA_CHAR > < OBJECT> < ID>| < SQL_COMMA_CHAR > < SQL_PRIMARY> < SQL_KEY>| < SQL_COMMA_CHAR > < ROWID >
             | < SQL_COMMA_CHAR > < SEQUENCE >
             | < SQL_COMMA_CHAR > < COMMIT> < SCN>)
           )+ ]
    <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR>
    [ new_values_clause() ]
  ] [ mv_log_purge_clause() ] [ for_refresh_clause() ]

}



 
 

void create_materialized_zonemap() : 
{}
{

( create_zonemap_on_table() | create_zonemap_as_subquery() ) 
}
void create_zonemap_on_table() : 
{}
{

< SQL_CREATE> < MATERIALIZED > < ZONEMAP > 
  [ schema()< SQL_PERIOD_CHAR > ] zonemap_name()
  [ zonemap_attributes() ]
  [ zonemap_refresh_clause() ]
  [ ( < ENABLE > | < DISABLE > ) < PRUNING > ]
  < SQL_ON> [ schema()< SQL_PERIOD_CHAR > ] ( table() | materialized_view() ) <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column())+ <SQL_RPARENCHAR>
}
void create_zonemap_as_subquery() : 
{}
{

< SQL_CREATE> < MATERIALIZED > < ZONEMAP > 
  [ schema()< SQL_PERIOD_CHAR > ] zonemap_name()
  [ <SQL_LPARENCHAR> column_alias() (< SQL_COMMA_CHAR > column_alias() )+ <SQL_RPARENCHAR> ]
  [ zonemap_attributes() ]
  [ zonemap_refresh_clause() ]
  [ ( < ENABLE > | < DISABLE > ) < PRUNING > ]
  < SQL_AS> query_block()
}
void zonemap_attributes() : 
{}
{

( < TABLESPACE > tablespace()
| < SCALE > integer()
| < PCTFREE > integer()
| < PCTUSED > integer()
| ( < CACHE > | < NOCACHE > )
)+
}
 
void create_operator() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>] < OPERATOR >
   [ schema()< SQL_PERIOD_CHAR > ] operator() binding_clause() 
}
void binding_clause() : 
{}
{

< BINDING >
   <SQL_LPARENCHAR> parameter_type() (< SQL_COMMA_CHAR > parameter_type() )+ <SQL_RPARENCHAR>
   < RETURN > return_type()
   [ implementation_clause() ]
   using_function_clause()
    (
      < SQL_COMMA_CHAR > (parameter_type() (< SQL_COMMA_CHAR > parameter_type() )+)
       < RETURN > return_type()
       [ implementation_clause() ]
       using_function_clause()
  )*
}
 

 
void create_outline() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>]
   [ < PUBLIC > | < PRIVATE > ] < OUTLINE > [ outline() ]
   [ < SQL_FROM> [ < PUBLIC > | < PRIVATE > ] source_outline() ]
   [ < FOR> < CATEGORY>category() ]
   [ < SQL_ON> statement() ] 
}
void create_sql_package() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>]
[ < EDITIONABLE > | < NONEDITIONABLE > ]
< PACKAGE > plsql_package_source()
}
void create_package_body() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>]
[ < EDITIONABLE > | < NONEDITIONABLE > ]
< PACKAGE> < BODY>plsql_package_body_source()
}
void create_pfile() : 
{}
{

< SQL_CREATE> < PFILE>[<ESQL_EQ> < APOSTROPHE >pfile_name()< APOSTROPHE > ]
   < SQL_FROM> ( < SPFILE > [<ESQL_EQ> < APOSTROPHE >spfile_name()< APOSTROPHE >]
        | < MEMORY >
        ) 
}
void create_pluggable_database() : 
{}
{

< SQL_CREATE> < PLUGGABLE > < DATABASE >  pdb_name()
  ( create_pdb_from_seed() | create_pdb_clone() | create_pdb_from_xml() ) 
}
void create_pdb_from_seed() : 
{}
{

< ADMIN> < SQL_ORA_USER>admin_user_name() < IDENTIFIED> < SQL_BY>password()
  [ pdb_dba_roles() ]
  [ default_tablespace() ]
  [ file_name_convert() ]
  [ pdb_storage_clause() ]
  [ path_prefix_clause() ]
  [ tempfile_reuse_clause() ]
  [ user_tablespaces_clause() ]
  [ standbys_clause() ]
  [ logging_clause() ]
  [ create_file_dest_clause() ]
}
void pdb_dba_roles() : 
{}
{

< ROLES > <ESQL_EQ> <SQL_LPARENCHAR> role() (< SQL_COMMA_CHAR > role() )+ <SQL_RPARENCHAR>
}


 
void path_prefix_clause() : 
{}
{

< PATH_PREFIX > <ESQL_EQ> ( < APOSTROPHE >path_name()< APOSTROPHE > | < NONE > )
}
void tempfile_reuse_clause() : 
{}
{

< TEMPFILE> < REUSE>}
void user_tablespaces_clause() : 
{}
{

< USER_TABLESPACES > <ESQL_EQ>
  ( ( < APOSTROPHE >tablespace()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >tablespace()< APOSTROPHE > )+ )
  | < NONE >
  | < SQL_ALL> [ < EXCEPT > ( < APOSTROPHE >tablespace()< APOSTROPHE > (< SQL_COMMA_CHAR > < APOSTROPHE >tablespace()< APOSTROPHE > )+ ) ]
  )
}
void standbys_clause() : 
{}
{

< STANDBYS > <ESQL_EQ> ( < NONE > | < SQL_ALL> )
}

void create_file_dest_clause() : 
{}
{

< CREATE_FILE_DEST > <ESQL_EQ> ( < NONE > | < APOSTROPHE >directory_path_name()< APOSTROPHE > | diskgroup_name() )
}
void create_pdb_clone() : 
{}
{

< SQL_FROM>  <SQL_LPARENCHAR> src_pdb_name() [ "@" dblink() ] <SQL_RPARENCHAR> | <SQL_LPARENCHAR> <NON$CDB> "@" dblink() <SQL_RPARENCHAR>
  [ pdb_storage_clause() ]
  [ file_name_convert() ]
  [ path_prefix_clause() ]
  [ tempfile_reuse_clause() ]
  [ < SNAPSHOT> < COPY>]
  [ user_tablespaces_clause() ]
  [ standbys_clause() ]
  [ logging_clause() ]
  [ create_file_dest_clause() ]
  [ < NO> < DATA>]
}
void create_pdb_from_xml() : 
{}
{

[ < SQL_AS> < CLONE>] < SQL_USING> filename() [ source_file_name_convert() ]
  [ <SQL_LPARENCHAR> [ < COPY > | < MOVE > ] file_name_convert() <SQL_RPARENCHAR> | < NOCOPY > ]
  [ pdb_storage_clause() ]
  [ path_prefix_clause() ]
  [ tempfile_reuse_clause() ]
  [ user_tablespaces_clause() ]
  [ standbys_clause() ]
  [ logging_clause() ]
  [ create_file_dest_clause() ]
}
void source_file_name_convert() : 
{}
{

< SOURCE_FILE_NAME_CONVERT > <ESQL_EQ>
  ( ( < APOSTROPHE >filename_pattern()< APOSTROPHE >< SQL_COMMA_CHAR > < APOSTROPHE >replacement_filename_pattern()< APOSTROPHE >
      (< SQL_COMMA_CHAR > < APOSTROPHE >filename_pattern()< APOSTROPHE >< SQL_COMMA_CHAR > < APOSTROPHE >replacement_filename_pattern()< APOSTROPHE > )+ )
    |
    < NONE >
  )
}
void create_procedure() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>]
[ < EDITIONABLE > | < NONEDITIONABLE > ]
< PROCEDURE > plsql_procedure_source()
}
void create_profile() : 
{}
{

< SQL_CREATE> < PROFILE>profile()
  < SQL_LIMIT> ( resource_parameters()
        | password_parameters()
        )+
  [ < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> ) ] 
}
 
 
void create_restore_point() : 
{}
{

< SQL_CREATE> < RESTORE > < POINT >  restore_point()
   [ < SQL_AS><OF > ( <  TIMESTAMP >  | <  SCN > ) expr() ]
   [ < PRESERVE >
   | < GUARANTEE > < FLASHBACK > < DATABASE > 
   ]
}
void create_role() : 
{}
{

< SQL_CREATE> < ROLE>role()
   [ < SQL_NOT> < IDENTIFIED>| < IDENTIFIED > ( < SQL_BY> password()
                | < SQL_USING> [ schema()< SQL_PERIOD_CHAR > ] sql_package()
                | < EXTERNALLY >
                | < GLOBALLY >
                )
   ] [ < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> ) ] 
}
void create_rollback_segment() : 
{}
{

< SQL_CREATE> [ < PUBLIC > ] < ROLLBACK> < SEGMENT> rollback_segment()
  [ ( < TABLESPACE > tablespace() | storage_clause() )+ ]
}
void create_schema() : 
{}
{

< SQL_CREATE> < SCHEMA > < AUTHORIZATION >  schema()
   ( create_table_statement()
   | create_view_statement()
   | grant_statement()
   )+

}
void create_sequence() : 
{}
{

< SQL_CREATE> < SEQUENCE>[ schema()< SQL_PERIOD_CHAR > ] sequence()
  ( ( < INCREMENT> < SQL_BY>| < START> < SQL_WITH>) integer()
  | ( < MAXVALUE > integer() | < NOMAXVALUE > )
  | ( < MINVALUE > integer() | < NOMINVALUE > )
  | ( < CYCLE > | < NOCYCLE > )
  | ( < CACHE > integer() | < NOCACHE > )
  | ( < SQL_ORDER> | < NOORDER > )
  | ( < KEEP > | < NOKEEP > )
  | ( < SESSION > | < GLOBAL > )
  )+

}
void create_spfile() : 
{}
{

< SQL_CREATE> < SPFILE>[<ESQL_EQ> < APOSTROPHE >spfile_name()< APOSTROPHE > ]
  < SQL_FROM> ( < PFILE > [<ESQL_EQ> < APOSTROPHE >pfile_name()< APOSTROPHE > ]
       | < MEMORY >
       ) 
}
void create_synonym() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE> ] [ < EDITIONABLE > | < NONEDITIONABLE > ]
   [ < PUBLIC > ] < SYNONYM >
   [ schema()< SQL_PERIOD_CHAR > ] synonym()
   < FOR > [ schema()< SQL_PERIOD_CHAR > ] object() [ "@" dblink() ] 
}
void create_table() : 
{}
{

< SQL_CREATE> [ < GLOBAL> < TEMPORARY>] < SQL_TABLE> [ schema()< SQL_PERIOD_CHAR > ] table()
  ( relational_table() | object_table() | xmltype_table() ) 
}
void relational_table() : 
{}
{

[ <SQL_LPARENCHAR> relational_properties() <SQL_RPARENCHAR> ]
[ < SQL_ON> < COMMIT>( < SQL_DELETE> | < PRESERVE > ) < ROWS > ]
[ physical_properties() ]
[ table_properties() ]
}
void object_table() : 
{}
{

< OF >
   [ schema()< SQL_PERIOD_CHAR > ] object_type()
   [ object_table_substitution() ]
   [ <SQL_LPARENCHAR> object_properties() <SQL_RPARENCHAR> ]
   [ < SQL_ON> < COMMIT>( < SQL_DELETE> | < PRESERVE > ) < ROWS > ]
   [ OID_clause() ]
   [ OID_index_clause() ]
   [ physical_properties() ]
   [ table_properties() ]
}
void xmltype_table() : 
{}
{

< OF> < XMLTYPE>[ <SQL_LPARENCHAR> oject_properties() <SQL_RPARENCHAR>  ]
  [ < XMLTYPE > XMLType_storage() ]
  [ XMLSchema_spec() ]
  [ xmltype_virtual_columns() ]
  [ < SQL_ON> < COMMIT>( < SQL_DELETE> | < PRESERVE > ) < ROWS > ]
  [ OID_clause() ]
  [ OID_index_clause() ]
  [ physical_properties() ]
  [ table_properties() ]
}
void relational_properties() : 
{}
{

( column_definition()
| virtual_column_definition()
| period_definition()
| ( out_of_line_constraint() | out_of_line_ref_constraint() )
| supplemental_logging_props()
)
  (< SQL_COMMA_CHAR > ( column_definition()
     | virtual_column_definition()
     | period_definition()
     | ( out_of_line_constraint() | out_of_line_ref_constraint() )
     | supplemental_logging_props()
     )
  )+
}

 
 
 

 
 


void object_table_substitution() : 
{}
{

[ < SQL_NOT > ] < SUBSTITUTABLE > < AT > < SQL_ALL> < LEVELS > 
}
 
void oid_clause() : 
{}
{

< OBJECT > < IDENTIFIER > < SQL_IS > 
( < SYSTEM> < GENERATED>| < SQL_PRIMARY> < SQL_KEY>)
}
void oid_index_clause() : 
{}
{

< OIDINDEX > [ index() ]
<SQL_LPARENCHAR>( physical_attributes_clause()
 | < TABLESPACE > tablespace()
 )+
<SQL_RPARENCHAR>
}
 
void table_properties() : 
{}
{

[ column_properties() ]
[ indexing_clause() ]
[ table_partitioning_clauses() ]
[ attribute_clustering_clause() ]
[ < CACHE > | < NOCACHE > ]
[ < RESULT_CACHE >  <SQL_LPARENCHAR> < MODE > (< SQL_DEFAULT > |  <  FORCE > ) <SQL_RPARENCHAR> ] 
[ parallel_clause() ]
[ < ROWDEPENDENCIES > | < NOROWDEPENDENCIES > ]
( enable_disable_clause() )+
[ row_movement_clause() ]
[ flashback_archive_clause() ]
[ < ROW> < ARCHIVAL>]
[ < SQL_AS> subquery() ]
}

 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
void xmltype_virtual_columns() : 
{}
{

< VIRTUAL> < COLUMNS> <SQL_LPARENCHAR> column() < SQL_AS> <SQL_LPARENCHAR> expr() <SQL_RPARENCHAR> (< SQL_COMMA_CHAR > column() < SQL_AS> (expr()) )+ <SQL_RPARENCHAR>
}
 



 
 

 
 
 

void external_table_clause() : 
{}
{

<SQL_LPARENCHAR> [ < TYPE > access_driver_type() ] external_data_properties() <SQL_RPARENCHAR>
[ < REJECT> < SQL_LIMIT>( integer() | < UNLIMITED > ) ]
}

 
void table_partitioning_clauses() : 
{}
{

( range_partitions()
| list_partitions()
| hash_partitions()
| composite_range_partitions()
| composite_list_partitions()
| composite_hash_partitions()
| reference_partitioning()
| system_partitioning()
)
}
void range_partitions() : 
{}
{

< PARTITION > < SQL_BY> < RANGE > <SQL_LPARENCHAR> column()(< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR>
  [ < INTERVAL > <SQL_LPARENCHAR> expr() <SQL_RPARENCHAR> [ < STORE> < SQL_IN> <SQL_LPARENCHAR> tablespace() (< SQL_COMMA_CHAR > tablespace())+ <SQL_RPARENCHAR> ]]
<SQL_LPARENCHAR> < PARTITION > [ partition() ]
    range_values_clause() table_partition_description()
      (
        < SQL_COMMA_CHAR > < PARTITION > [ partition() ]
        range_values_clause() table_partition_description()
    )*
<SQL_RPARENCHAR>
}
void hash_partitions() : 
{}
{

< PARTITION > < SQL_BY> < HASH >  <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR>
( individual_hash_partitions()
| hash_partitions_by_quantity()
)
}
 

void list_partitions() : 
{}
{

< PARTITION > < SQL_BY> < LIST >  <SQL_LPARENCHAR> column() <SQL_RPARENCHAR>
<SQL_LPARENCHAR> < PARTITION > [ partition() ]
    list_values_clause() table_partition_description()
  (
    < SQL_COMMA_CHAR > < PARTITION > [ partition() ]
        list_values_clause() table_partition_description()
)*
<SQL_RPARENCHAR>
}
void composite_range_partitions() : 
{}
{

< PARTITION > < SQL_BY> < RANGE >  <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column())+  <SQL_RPARENCHAR>
  [ < INTERVAL > <SQL_LPARENCHAR> expr() <SQL_RPARENCHAR> [ < STORE> < SQL_IN> <SQL_LPARENCHAR> tablespace() (< SQL_COMMA_CHAR > tablespace())+ <SQL_RPARENCHAR>  ]]
  ( subpartition_by_range()
  | subpartition_by_list()
  | subpartition_by_hash()
  )
<SQL_LPARENCHAR> range_partition_desc() (< SQL_COMMA_CHAR > range_partition_desc() )+ <SQL_RPARENCHAR>
}
void composite_hash_partitions() : 
{}
{

< PARTITION > < SQL_BY> < HASH >  <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR>
  ( subpartition_by_range()
  | subpartition_by_list()
  | subpartition_by_hash()
  )
  ( individual_hash_partitions()
  | hash_partitions_by_quantity()
  )
}
void composite_list_partitions() : 
{}
{

< PARTITION > < SQL_BY> < LIST >  <SQL_LPARENCHAR> column() <SQL_RPARENCHAR>
  ( subpartition_by_range()
  | subpartition_by_list()
  | subpartition_by_hash()
  )
<SQL_LPARENCHAR> list_partition_desc() (< SQL_COMMA_CHAR > list_partition_desc())+ <SQL_RPARENCHAR>
}
void reference_partitioning() : 
{}
{

< PARTITION > < SQL_BY> < REFERENCE >  <SQL_LPARENCHAR>  constraint() <SQL_RPARENCHAR> 
  [ <SQL_LPARENCHAR>  ( reference_partition_desc())+  <SQL_RPARENCHAR> ]
}
void reference_partition_desc() : 
{}
{

< PARTITION > [partition()] [table_partition_description()] 
}
void system_partitioning() : 
{}
{
< PARTITION > < SQL_BY> < SYSTEM >
[ < PARTITIONS > integer() | reference_partition_desc() ( < SQL_COMMA_CHAR > reference_partition_desc() )* ]
}
 
 
void subpartition_template() : 
{}
{

< SUBPARTITION> < TEMPLATE>
  (   <SQL_LPARENCHAR> range_subpartition_desc() ( < SQL_COMMA_CHAR > range_subpartition_desc() )+ <SQL_RPARENCHAR>
    | <SQL_LPARENCHAR> list_subpartition_desc() (< SQL_COMMA_CHAR > list_subpartition_desc())+ <SQL_RPARENCHAR>
    | < SQL_LPARENCHAR > individual_hash_subparts() (< SQL_COMMA_CHAR > individual_hash_subparts() )+ <SQL_RPARENCHAR>
    | <SQL_LPARENCHAR> <SQL_RPARENCHAR>
    | hash_subpartition_quantity()
 )
}
void subpartition_by_range() : 
{}
{

< SUBPARTITION > < SQL_BY> < RANGE >  <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column())+ <SQL_RPARENCHAR> [subpartition_template()]
}
void subpartition_by_list() : 
{}
{

< SUBPARTITION > < SQL_BY> < LIST >  <SQL_LPARENCHAR> column() <SQL_RPARENCHAR> [ subpartition_template() ]
}
void subpartition_by_hash() : 
{}
{

< SUBPARTITION > < SQL_BY> < HASH >  <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR>
   [ < SUBPARTITIONS > integer()
        [ < STORE> < SQL_IN> <SQL_LPARENCHAR> tablespace() (< SQL_COMMA_CHAR > tablespace() )+ <SQL_RPARENCHAR> ]
   | subpartition_template()
   ]
}
 
void create_tablespace() : 
{}
{

< SQL_CREATE>
   [ < BIGFILE > | < SMALLFILE > ]
   ( permanent_tablespace_clause()
   | temporary_tablespace_clause()
   | undo_tablespace_clause()
   ) 
}
void permanent_tablespace_clause() : 
{}
{

< TABLESPACE > tablespace()
  [ < DATAFILE > file_specification() (< SQL_COMMA_CHAR > file_specification() )+ ]
( < MINIMUM> < EXTENT>size_clause()
| < BLOCKSIZE > integer() [ < K > ]
| logging_clause()
| < FORCE > < LOGGING >
| < ENCRYPTION > tablespace_encryption_spec()
| < SQL_DEFAULT > [ table_compression() ] [ inmemory_clause() ] [ storage_clause() ]
| ( < ONLINE > | < OFFLINE > )
| extent_management_clause()
| segment_management_clause()
| flashback_mode_clause()
)+
}

void tablespace_encryption_spec() : 
{}
{

[ < SQL_USING> < APOSTROPHE >encrypt_algorithm()< APOSTROPHE > ]
}
 
 
 
 



void segment_management_clause() : 
{}
{

< SEGMENT > < SPACE > < MANAGEMENT >  ( < AUTO > | < MANUAL > )
}

void temporary_tablespace_clause() : 
{}
{

< TEMPORARY> < TABLESPACE>tablespace()
  [ < TEMPFILE > file_specification() (< SQL_COMMA_CHAR > file_specification() )+ ]
  [ tablespace_group_clause() ]
  [ extent_management_clause() ]
}
 
void undo_tablespace_clause() : 
{}
{

< UNDO> < TABLESPACE>tablespace()
  [ < DATAFILE > file_specification() (< SQL_COMMA_CHAR > file_specification() )+ ]
  [ extent_management_clause() ]
  [ tablespace_retention_clause() ]
}
 
void create_trigger() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>]
[ < EDITIONABLE > | < NONEDITIONABLE > ]
< TRIGGER > plsql_trigger_source()
}
void create_type() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>]
[ < EDITIONABLE > | < NONEDITIONABLE > ]
< TYPE > plsql_type_source()
}
void create_type_body() : 
{}
{

< SQL_CREATE> [ < SQL_OR> < SQL_REPLACE>]
[ < EDITIONABLE > | < NONEDITIONABLE > ]
< TYPE> < BODY>plsql_type_body_source()
}
void create_user() : 
{}
{

< SQL_CREATE> < SQL_ORA_USER>user()
   < IDENTIFIED > ( < SQL_BY> password()
              | < EXTERNALLY > [ < SQL_AS> < APOSTROPHE >certificate_DN()< APOSTROPHE >  |  < SQL_AS> < APOSTROPHE >kerberos_principal_name()< APOSTROPHE > ]
              | < GLOBALLY > [ < SQL_AS> < APOSTROPHE >[ directory_DN() ]< APOSTROPHE > ]
              )
   [ < SQL_DEFAULT> < TABLESPACE>tablespace()
   | < TEMPORARY> < TABLESPACE>( tablespace() | tablespace_group_name() )
   | ( < QUOTA > ( size_clause() | < UNLIMITED > ) < SQL_ON> tablespace() )+
   | < PROFILE > profile()
   | < PASSWORD> < EXPIRE>| < ACCOUNT > ( < LOCK > | < UNLOCK > )
     ( < SQL_DEFAULT> < TABLESPACE>tablespace()
     | < TEMPORARY> < TABLESPACE>( tablespace() | tablespace_group_name() )
     | ( < QUOTA > ( size_clause() | < UNLIMITED > ) < SQL_ON> tablespace() )+
     | < PROFILE > profile()
     | < PASSWORD> < EXPIRE>| < ACCOUNT > ( < LOCK > | < UNLOCK > )
     | < ENABLE> < EDITIONS>| < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> )
     )+
  ] 
}
void create_view() : 
{}
{

< SQL_CREATE> [< SQL_OR> < SQL_REPLACE>]
  [[< NO >] < FORCE >]
  [ < EDITIONING > | < EDITIONABLE > [ < EDITIONING > ] | < NONEDITIONABLE > ]
  < VIEW > [schema()< SQL_PERIOD_CHAR >] view()
   [ <SQL_LPARENCHAR> ( alias() [ < VISIBLE > | < INVISIBLE > ] [ (  inline_constraint() )+ ] | out_of_line_constraint()
       )
         [< SQL_COMMA_CHAR > ( alias() [ < VISIBLE > | < INVISIBLE > ] [ ( inline_constraint() )+]
            | out_of_line_constraint()
     )
  ]
     <SQL_RPARENCHAR>
   | object_view_clause()
   | XMLType_view_clause()
   ]
   [ < BEQUEATH > ( < CURRENT_USER > | < DEFINER > ) ]
   < SQL_AS> subquery() [ subquery_restriction_clause() ] 
}
void object_view_clause() : 
{}
{

< OF > [ schema()< SQL_PERIOD_CHAR > ] type_name()
( < SQL_WITH> < OBJECT > < IDENTIFIER > 
  ( < SQL_DEFAULT > | ( attribute() (< SQL_COMMA_CHAR > attribute() )+ ) )
| < UNDER > [ schema()< SQL_PERIOD_CHAR > ] superview()
)
[ <SQL_LPARENCHAR> ( out_of_line_constraint()
    | attribute() ( inline_constraint() )+
    )  (< SQL_COMMA_CHAR > ( out_of_line_constraint()
          | attribute() ( inline_constraint() )+
          )
       )+
  <SQL_RPARENCHAR>
]
}
void xmltype_view_clause() : 
{}
{

< OF> < XMLTYPE>[ XMLSchema_spec() ]
< SQL_WITH> < OBJECT > < IDENTIFIER > 
  ( < SQL_DEFAULT > | ( expr() (< SQL_COMMA_CHAR > expr() )+) )
}
 
void subquery_restriction_clause() : 
{}
{
< SQL_WITH> ( < READ> < ONLY>| < CHECK> < OPTION>) [ < CONSTRAINT > constraint() ]
}
void delete() : 
{}
{

< SQL_DELETE> [ hint() ]
   [ < SQL_FROM> ]
   ( dml_table_expression_clause()
   | < ONLY > (dml_table_expression_clause())
   ) [ t_alias() ]
     [ where_clause() ]
     [ returning_clause() ]
     [error_logging_clause()]
}
void dml_table_expression_clause() : 
{}
{

( [ schema()< SQL_PERIOD_CHAR > ]
  ( table()
    [ partition_extension_clause()
    | "@" dblink()
    ]
  | ( view() | materialized_view() ) [ "@" dblink() ]
  )
| ( subquery() [ subquery_restriction_clause() ] )
| table_collection_expression()
)
}
 
 
void table_collection_expression() : 
{}
{

< SQL_TABLE> <SQL_LPARENCHAR> collection_expression() <SQL_RPARENCHAR> [ <SQL_LPARENCHAR> <SQL_PLUSCHAR> <SQL_RPARENCHAR> ]
}
void where_clause() : 
{}
{

< SQL_WHERE> condition()
}
void returning_clause() : 
{}
{

( < RETURN > | < RETURNING > ) expr() (< SQL_COMMA_CHAR > expr() )+
< SQL_INTO> data_item() (< SQL_COMMA_CHAR > data_item() )+
}
void error_logging_clause() : 
{}
{

< SQL_ORA_LOG> < ERRORS>[ < SQL_INTO> [schema()< SQL_PERIOD_CHAR >] table() ]
  [ <SQL_LPARENCHAR> simple_expression() <SQL_RPARENCHAR> ]
  [ < REJECT> < SQL_LIMIT>( integer() | < UNLIMITED > ) ]
}
void disassociate_statistics() : 
{}
{

< DISASSOCIATE> < STATISTICS>< SQL_FROM>
   ( < COLUMNS > [ schema()< SQL_PERIOD_CHAR > ]table()< SQL_PERIOD_CHAR >column()
               (
                 < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]table()< SQL_PERIOD_CHAR >column() )*
   | < FUNCTIONS > [ schema()< SQL_PERIOD_CHAR > ]function()
                 (
                   < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]function() )*
   | < PACKAGES > [ schema()< SQL_PERIOD_CHAR > ]sql_package()
                (
                  < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]sql_package() )*
   | < TYPES > [ schema()< SQL_PERIOD_CHAR > ]type()
             (
               < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]type() )*
   | < INDEXES > [ schema()< SQL_PERIOD_CHAR > ]index()
               (
                 < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]index() )*
   | < INDEXTYPES > [ schema()< SQL_PERIOD_CHAR > ]indextype()
                  (
                    < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ]indextype() )*
   )
   [ < FORCE > ] 
}
void drop_audit_policy() : 
{}
{

< SQL_DROP> < AUDIT > < POLICY >  policy() 
}
void drop_cluster() : 
{}
{

< SQL_DROP> < CLUSTER>[ schema()< SQL_PERIOD_CHAR > ] cluster()
   [ < INCLUDING> < TABLES>[ < CASCADE> < CONSTRAINTS>] ] 
}
void drop_context() : 
{}
{

< SQL_DROP> < CONTEXT>namespace() 
}
void drop_database() : 
{}
{

< SQL_DROP> < DATABASE>
}
void drop_database_link() : 
{}
{

< SQL_DROP> [ < PUBLIC > ] < DATABASE> < LINK>dblink() 
}
void drop_dimension() : 
{}
{

< SQL_DROP> < DIMENSION>[ schema()< SQL_PERIOD_CHAR > ] dimension() 
}
void drop_directory() : 
{}
{

< SQL_DROP> < DIRECTORY>directory_name() 
}
void drop_diskgroup() : 
{}
{

< SQL_DROP> < DISKGROUP>diskgroup_name()
   [ < FORCE > < INCLUDING > < CONTENTS > 
   | ( < INCLUDING > | < EXCLUDING > ) < CONTENTS >
   ]
}
void drop_edition() : 
{}
{

< SQL_DROP> < EDITION>edition() [< CASCADE >]
}
void drop_flashback_archive() : 
{}
{

< SQL_DROP> < FLASHBACK > < ARCHIVE >  flashback_archive()
}
void drop_function() : 
{}
{

< SQL_DROP> < FUNCTION>[ schema()< SQL_PERIOD_CHAR > ] function_name() 
}
void drop_index() : 
{}
{

< SQL_DROP> < SQL_INDEX>[ schema()< SQL_PERIOD_CHAR > ] index() [ < ONLINE > ] [ < FORCE > ] 
}
void drop_indextype() : 
{}
{

< SQL_DROP> < INDEXTYPE>[ schema()< SQL_PERIOD_CHAR > ] indextype() [ < FORCE > ] 
}
void drop_java() : 
{}
{

< SQL_DROP> < JAVA>( < SOURCE > | < CLASS > | < RESOURCE > )
  [ schema()< SQL_PERIOD_CHAR > ] object_name() 
}
void drop_library() : 
{}
{

< SQL_DROP> < LIBRARY>library_name() 
}
void drop_materialized_view() : 
{}
{

< SQL_DROP> < MATERIALIZED > < VIEW >  [ schema()< SQL_PERIOD_CHAR > ] materialized_view()
   [ < PRESERVE> < SQL_TABLE>] 
}
void drop_materialized_view_log() : 
{}
{

< SQL_DROP> < MATERIALIZED > < VIEW > < SQL_ORA_LOG> < SQL_ON>  [ schema()< SQL_PERIOD_CHAR > ] table() 
}
void drop_materialized_zonemap() : 
{}
{

< SQL_DROP> < MATERIALIZED > < ZONEMAP >  [ schema()< SQL_PERIOD_CHAR > ] zonemap_name() 
}
void drop_operator() : 
{}
{

< SQL_DROP> < OPERATOR>[ schema()< SQL_PERIOD_CHAR > ] operator() [ < FORCE > ] 
}
void drop_outline() : 
{}
{

< SQL_DROP> < OUTLINE>outline() 
}
void drop_sql_package() : 
{}
{

< SQL_DROP> < PACKAGE>[ < BODY > ] [ schema()< SQL_PERIOD_CHAR > ] sql_package() 
}
void drop_pluggable_database() : 
{}
{

< SQL_DROP> < PLUGGABLE > < DATABASE >  pdb_name()
  [ ( < KEEP > | < INCLUDING > ) < DATAFILES > ] 
}
void drop_procedure() : 
{}
{

< SQL_DROP> < PROCEDURE>[ schema()< SQL_PERIOD_CHAR > ] procedure() 
}
void drop_profile() : 
{}
{

< SQL_DROP> < PROFILE>profile() [ < CASCADE > ] 
}
void drop_restore_point() : 
{}
{

< SQL_DROP> < RESTORE > < POINT >  restore_point() 
}
void drop_role() : 
{}
{

< SQL_DROP> < ROLE>role() 
}
void drop_rollback_segment() : 
{}
{

< SQL_DROP> < ROLLBACK > < SEGMENT >  rollback_segment() 
}
void drop_sequence() : 
{}
{

< SQL_DROP> < SEQUENCE>[ schema()< SQL_PERIOD_CHAR > ] sequence_name() 
}
void drop_synonym() : 
{}
{

< SQL_DROP> [< PUBLIC >] < SYNONYM > [ schema()< SQL_PERIOD_CHAR > ] synonym() [< FORCE >] 
}
void drop_table() : 
{}
{

< SQL_DROP> < SQL_TABLE>[ schema()< SQL_PERIOD_CHAR > ] table()
  [ < CASCADE> < CONSTRAINTS>] [ < PURGE > ] 
}
void drop_tablespace() : 
{}
{

< SQL_DROP> < TABLESPACE>tablespace() 
   [ < INCLUDING> < CONTENTS>[ (< SQL_AND> | < KEEP >) < DATAFILES > ]
     [ < CASCADE> < CONSTRAINTS>]
   ] 
}
void drop_trigger() : 
{}
{

< SQL_DROP> < TRIGGER>[ schema()< SQL_PERIOD_CHAR > ] trigger() 
}
void drop_type() : 
{}
{

< SQL_DROP> < TYPE>[ schema()< SQL_PERIOD_CHAR > ] type_name() [ < FORCE > | < VALIDATE > ] 
}
void drop_type_body() : 
{}
{

< SQL_DROP> < TYPE > < BODY >  [ schema()< SQL_PERIOD_CHAR > ] type_name() 
}
void drop_user() : 
{}
{

< SQL_DROP> < SQL_ORA_USER>user() [ < CASCADE > ] 
}
void drop_view() : 
{}
{

< SQL_DROP> < VIEW>[ schema()< SQL_PERIOD_CHAR > ] view() [ < CASCADE> < CONSTRAINTS>] 
}
void explain_plan() : 
{}
{

< EXPLAIN> < PLAN>[ < SQL_SET> < STATEMENT_ID><ESQL_EQ> string() ]
   [ < SQL_INTO> [ schema()< SQL_PERIOD_CHAR > ] table() [ "@" dblink() ] ]
< FOR > statement() 
}
void flashback_database() : 
{}
{

< FLASHBACK > [ < STANDBY > ] < DATABASE > [ database() ]
   ( < TO > ( ( < SCN > | < TIMESTAMP > ) expr() | < RESTORE> < POINT>restore_point() )
   | < TO> < BEFORE>( < SCN > | < TIMESTAMP >) expr() | < RESETLOGS > 
   ) 
}
void flashback_table() : 
{}
{

< FLASHBACK> < SQL_TABLE>[ schema()< SQL_PERIOD_CHAR > ] table()
     (
       < SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ] table() )*
   < TO > ( ( ( < SCN > | < TIMESTAMP > ) expr()
        | < RESTORE> < POINT>restore_point()
        ) [ ( < ENABLE > | < DISABLE > ) < TRIGGERS > ]
      | < BEFORE> < SQL_DROP>[ < RENAME> < TO>table() ]
      ) 
}
void grant() : 
{}
{

< GRANT >
  ( ( grant_system_privileges() | grant_object_privileges() )
    [ < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> ) ] 
  | grant_roles_to_programs()
)
}
void grant_system_privileges() : 
{}
{

( system_privilege() | role() | < SQL_ALL> < PRIVILEGES>)
  (< SQL_COMMA_CHAR > ( system_privilege() | role() | < SQL_ALL> < PRIVILEGES>) )+
< TO > ( grantee_clause() | grantee_identified_by() ) [ < SQL_WITH> ( < ADMIN > | < DELEGATE > ) < OPTION > ]
}
void grantee_clause() : 
{}
{

( user() | role() | < PUBLIC > )
  (< SQL_COMMA_CHAR > ( user() | role() | < PUBLIC > ) )+
}
void grantee_identified_by() : 
{}
{

user() (< SQL_COMMA_CHAR > user() )+ < IDENTIFIED> < SQL_BY>password() (< SQL_COMMA_CHAR > password() )+
}
void grant_object_privileges() : 
{}
{
( object_privilege() | < SQL_ALL> [ < PRIVILEGES > ] )
  [ <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR> ]
    (
      < SQL_COMMA_CHAR > ( object_privilege() | < SQL_ALL> [ < PRIVILEGES > ] )
       [ <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR>  ]
  )*
on_object_clause()
< TO > grantee_clause()
  [ < SQL_WITH> < HIERARCHY > < OPTION >  ]
  [ < SQL_WITH> < GRANT > < OPTION >  ]
}
void on_object_clause() : 
{}
{

< SQL_ON > ( [ schema()< SQL_PERIOD_CHAR > ] object() 
   | < SQL_ORA_USER> user() (< SQL_COMMA_CHAR > user())+
   | < DIRECTORY > directory_name()
   | < EDITION > edition_name()
   | < MINING> < MODEL>[ schema()< SQL_PERIOD_CHAR > ] mining_model_name()
   | < JAVA > ( < SOURCE > | < RESOURCE > ) [ schema()< SQL_PERIOD_CHAR > ] object()
   | < SQL > < TRANSLATION > < PROFILE >  [ schema()< SQL_PERIOD_CHAR > ] profile()
   )
}
void grant_roles_to_programs() : 
{}
{

role() (< SQL_COMMA_CHAR > role() )+ < TO > program_unit() (< SQL_COMMA_CHAR > program_unit() )+
}
void program_unit() : 
{}
{

( < FUNCTION > [ schema()< SQL_PERIOD_CHAR > ] function_name()
|
< PROCEDURE > [ schema()< SQL_PERIOD_CHAR > ] procedure_name()
|
< PACKAGE > [ schema()< SQL_PERIOD_CHAR > ] package_name() )
}
void insert() : 
{}
{

< SQL_INSERT> [ hint() ]
   ( single_table_insert() | multi_table_insert() ) 
}
void single_table_insert() : 
{}
{

insert_into_clause()
( values_clause() [ returning_clause() ]
| subquery() 
) [ error_logging_clause() ]
}
void insert_into_clause() : 
{}
{

< SQL_INTO> dml_table_expression_clause() [ t_alias() ]
[ <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR> ]
}
void values_clause() : 
{}
{

< SQL_VALUES> <SQL_LPARENCHAR> ( expr() | < SQL_DEFAULT > )
          ( < SQL_COMMA_CHAR > ( expr() | < SQL_DEFAULT > ) )+
       <SQL_RPARENCHAR>
}
 
void multi_table_insert() : 
{}
{

( < SQL_ALL>
  ( insert_into_clause() [ values_clause() ] [error_logging_clause()] )+
| conditional_insert_clause()
) subquery()
}
void conditional_insert_clause() : 
{}
{

[ < SQL_ALL> | < SQL_ORA_FIRST> ]
< SQL_WHEN > condition()
< SQL_THEN> insert_into_clause()
  [ values_clause() ]
  [ error_logging_clause() ]
  (
     insert_into_clause() [ values_clause() ] [ error_logging_clause() ] )*
(
   < SQL_WHEN > condition()
  < SQL_THEN> insert_into_clause()
    [ values_clause() ]
    [ error_logging_clause() ]
    (
       insert_into_clause() [ values_clause() ] [ error_logging_clause() ] )*
)*
[ < SQL_ELSE> insert_into_clause()
  [ values_clause() ]
  [ error_logging_clause() ]
   (
      insert_into_clause() [ values_clause() ] [ error_logging_clause() ] )*
]
}

 
 
 


void lock_table() : 
{}
{

< LOCK> < SQL_TABLE>[ schema()< SQL_PERIOD_CHAR > ] ( table() | view() )
   [ partition_extension_clause()
   | "@" dblink()
   ] (< SQL_COMMA_CHAR > [ schema()< SQL_PERIOD_CHAR > ] ( table() | view() )
      [ partition_extension_clause()
      | "@" dblink()
      ]
   )*
   < SQL_IN> lockmode() < MODE >
   [ < NOWAIT >  
   | < WAIT > integer()
   ] 
}
 
void merge() : 
{}
{

< MERGE > [ hint() ]
   < SQL_INTO> [ schema()< SQL_PERIOD_CHAR > ] ( table() | view() ) [ t_alias() ]
   < SQL_USING> ( [ schema()< SQL_PERIOD_CHAR > ] ( table() | view() )
         | subquery() 
         ) [ t_alias() ]
   < SQL_ON> <SQL_LPARENCHAR> condition() <SQL_RPARENCHAR>
   [ merge_update_clause() ]
   [ merge_insert_clause() ]
   [ error_logging_clause() ] 
}
void merge_update_clause() : 
{}
{

< SQL_WHEN > < MATCHED > < SQL_THEN> 
< SQL_UPDATE> < SQL_SET>column() <ESQL_EQ> ( expr() | < SQL_DEFAULT > )
           (< SQL_COMMA_CHAR > column() <ESQL_EQ> ( expr() | < SQL_DEFAULT > ) )+
[ where_clause() ]
[ < SQL_DELETE> where_clause() ]
}
void merge_insert_clause() : 
{}
{

< SQL_WHEN > < SQL_NOT > < MATCHED > < SQL_THEN> 
< SQL_INSERT> [ <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR>  ]
< SQL_VALUES> <SQL_LPARENCHAR> ( expr() | < SQL_DEFAULT > )
          (< SQL_COMMA_CHAR > ( expr() | < SQL_DEFAULT > ) )+
       <SQL_RPARENCHAR>
[ where_clause() ]
}
 

void noaudit() : 
{}
{

< NOAUDIT > 
   ( audit_operation_clause() [ auditing_by_clause() ]
   | audit_schema_object_clause()
   | < NETWORK >
   | < DIRECT_PATH> < LOAD>[ auditing_by_clause() ]
   )
   [ < WHENEVER > [ < SQL_NOT > ] < SUCCESSFUL > ]
   [ < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> ) ] 
}



void unified_noaudit() : 
{}
{

< NOAUDIT >
  ( < POLICY > policy()
  | < CONTEXT > < NAMESPACE > namespace() < ATTRIBUTES > attribute() (< SQL_COMMA_CHAR > attribute() )+
    (< SQL_COMMA_CHAR > < CONTEXT > < NAMESPACE > namespace() < ATTRIBUTES > attribute() (< SQL_COMMA_CHAR > attribute() )+ )+
  )
  [ < SQL_BY> user() (< SQL_COMMA_CHAR > user())+ ] 
}
void purge() : 
{}
{

< PURGE > ( ( < SQL_TABLE> table() | < SQL_INDEX> index() )
      | ( < RECYCLEBIN > | < DBA_RECYCLEBIN > )
      | < TABLESPACE > tablespace() [ < SQL_ORA_USER> username() ]
      ) 
}
void rename() : 
{}
{

< RENAME > old_name() < TO > new_name() 
}
void revoke() : 
{}
{

< REVOKE >
(   ( revoke_system_privileges() | revoke_object_privileges() )
    [ < CONTAINER > <ESQL_EQ> ( < CURRENT > | < SQL_ALL> ) ] 
  | revoke_roles_from_programs()
) 
}
void revoke_system_privileges() : 
{}
{

( system_privilege() | role() | < SQL_ALL> < PRIVILEGES>)
  (< SQL_COMMA_CHAR > ( system_privilege() | role() | < SQL_ALL> < PRIVILEGES>) )+
< SQL_FROM> revokee_clause()
}
void revoke_object_privileges() : 
{}
{

( object_privilege() | < SQL_ALL> [ < PRIVILEGES > ] )
  (
    < SQL_COMMA_CHAR > ( object_privilege() | < SQL_ALL> [ < PRIVILEGES > ] ) )*
on_object_clause()
< SQL_FROM> revokee_clause()
[ < CASCADE> < CONSTRAINTS>| < FORCE > ]
}
void revokee_clause() : 
{}
{

( user() | role() | < PUBLIC > )
  (< SQL_COMMA_CHAR > ( user() | role() | < PUBLIC > ) )+
}
 
void revoke_roles_from_programs() : 
{}
{

( role() (< SQL_COMMA_CHAR > role() )+ | < SQL_ALL> ) < SQL_FROM> program_unit() (< SQL_COMMA_CHAR > program_unit() )+
}
 
void rollback() : 
{}
{

< ROLLBACK > [ < WORK > ]
   [ < TO > [ < SAVEPOINT > ] savepoint()
   | < FORCE > string()
   ] 
}
void savepoint() : 
{}
{

< SAVEPOINT > savepoint() 
}
 
 
 
void with_clause() : 
{}
{

< SQL_WITH> [ plsql_declarations() ] [ subquery_factoring_clause() ]
}
void plsql_declarations() : 
{}
{

( function_declaration() | procedure_declaration() )+
}
void subquery_factoring_clause() : 
{}
{
( [ < SQL_COMMA_CHAR > ] query_name() [ <SQL_LPARENCHAR> ( [ < SQL_COMMA_CHAR >  ] ( <SQL_IDENTIFIER> |  c_alias() ) )+ <SQL_RPARENCHAR> ]  < SQL_AS> <SQL_LPARENCHAR> subquery() <SQL_RPARENCHAR> [search_clause()] [cycle_clause()] )+

}
void search_clause() : 
{}
{
 < SEARCH > ( < SQL_ORA_DEPTH>  | < BREADTH > )  < SQL_ORA_FIRST> < SQL_BY>
            (
              [ < SQL_COMMA_CHAR > ]  c_alias() [ < SQL_ASC> | < SQL_DESC> ] [ < NULLS> < SQL_ORA_FIRST>| < NULLS> < SQL_ORA_LAST>]
            )+
        < SQL_SET> ordering_column()

}
void cycle_clause() : 
{}
{

< CYCLE > ( [ < SQL_COMMA_CHAR > ]  c_alias() )+
    < SQL_SET> cycle_mark_c_alias() < TO > cycle_value()
    < SQL_DEFAULT > no_cycle_value()

}
void select_list() : 
{}
{

( [t_alias() < SQL_PERIOD_CHAR > ] <SQL_ASTERISKCHAR>
| (
    [ < SQL_COMMA_CHAR > ]
	(  query_name() <SQL_PERIOD_CHAR > <SQL_ASTERISKCHAR>
	   | [ schema()< SQL_PERIOD_CHAR > ] ( table() | view() | materialized_view() ) <SQL_PERIOD_CHAR > <SQL_ASTERISKCHAR>
	   | expr() [ [ < SQL_AS> ] c_alias() ]
    )
  )+
)
}
void table_reference() : 
{}
{

(  ( < ONLY > <SQL_LPARENCHAR> query_table_expression() <SQL_RPARENCHAR> | query_table_expression() )
  [ flashback_query_clause() ]
  [ pivot_clause() | unpivot_clause() | row_pattern_clause() ] 
| containers_clause()
)
[ t_alias() ]
}
void flashback_query_clause() : 
{}
{
( < VERSIONS>  ( < SQL_BETWEEN>( < SCN > | < TIMESTAMP > ) |  < PERIOD > < FOR >  valid_time_column() < SQL_BETWEEN> ) ( expr() | < MINVALUE > ) < SQL_AND> ( expr() | < MAXVALUE > ) 
| < SQL_AS> < OF>  ( ( < SCN > | < TIMESTAMP > ) expr() |   < PERIOD > < FOR >  valid_time_column() expr()) 
)
}
void query_table_expression() : 
{}
{

( query_name()
| [ schema()< SQL_PERIOD_CHAR > ]
  ( table() [ partition_extension_clause() | "@" dblink() ] | ( view() | materialized_view() ) [ "@" dblink() ] ) [sample_clause()]
| [ < LATERAL > ] <SQL_LPARENCHAR> subquery() [ subquery_restriction_clause() ] <SQL_RPARENCHAR>
| table_collection_expression()
)
}
void pivot_clause() : 
{}
{

 < PIVOT > [ < XML > ]
  <SQL_LPARENCHAR>  ( [ < SQL_COMMA_CHAR > ] aggregate_function() ( expr() ) [[< SQL_AS>] alias() ] ) +
    pivot_for_clause()
    pivot_in_clause()
  <SQL_RPARENCHAR>
}
void pivot_for_clause() : 
{}
{
< FOR >  [ <SQL_LPARENCHAR> ] ( [ < SQL_COMMA_CHAR > ] column() )+ [ <SQL_RPARENCHAR> ]
}
void pivot_in_clause() : 
{}
{

< SQL_IN> <SQL_LPARENCHAR> ( [<SQL_LPARENCHAR>]  ( [ < SQL_COMMA_CHAR > ]  expr() )+ [ <SQL_RPARENCHAR> ]  [ [ < SQL_AS>] alias()] )+
     | subquery()
     | ( [ < SQL_COMMA_CHAR >  ] < SQL_ANY>)+
   <SQL_RPARENCHAR>
}
void unpivot_clause() : 
{}
{
< UNPIVOT > [ (< INCLUDE > | < EXCLUDE >) < NULLS > ]
<SQL_LPARENCHAR>  [<SQL_LPARENCHAR>] ( [ < SQL_COMMA_CHAR >  ]column() )+ [ <SQL_RPARENCHAR> ] 
  pivot_for_clause()
  unpivot_in_clause()
<SQL_RPARENCHAR>
}
void unpivot_in_clause() : 
{}
{
< SQL_IN>
<SQL_LPARENCHAR>  ( [ < SQL_COMMA_CHAR > ]  ( <SQL_LPARENCHAR> ( [ < SQL_COMMA_CHAR >  ]column() )+  <SQL_RPARENCHAR> |   column() )  
          [  < SQL_AS>   ( <SQL_LPARENCHAR>  ( [ < SQL_COMMA_CHAR >  ] literal() )+   <SQL_RPARENCHAR>   | literal()  )  ]
      )+
<SQL_RPARENCHAR>
}
void sample_clause() : 
{}
{

< SAMPLE > [ < BLOCK > ]
       <SQL_LPARENCHAR> sample_percent() <SQL_RPARENCHAR>
       [ < SEED > <SQL_LPARENCHAR> seed_value() <SQL_RPARENCHAR> ]
}
 
 
 
void containers_clause() : 
{}
{

< CONTAINERS > <SQL_LPARENCHAR> [schema()< SQL_PERIOD_CHAR >] ( table() | view() ) <SQL_RPARENCHAR>
}
void join_clause() : 
{}
{

table_reference()
  ( inner_cross_join_clause() | outer_join_clause() | cross_outer_apply_clause() )+
}
void inner_cross_join_clause() : 
{}
{

( [ < SQL_INNER> ] < SQL_JOIN> table_reference()
    ( < SQL_ON> condition()
    | < SQL_USING> (column() (< SQL_COMMA_CHAR > column() )+)
    )
| ( < CROSS >
  | < SQL_NATURAL> [ < SQL_INNER> ]
  )
  < SQL_JOIN> table_reference()
)
}
void outer_join_clause() : 
{}
{

[ query_partition_clause() ] [ < SQL_NATURAL> ]
outer_join_type() < SQL_JOIN> table_reference()
  [ query_partition_clause() ]
  [ < SQL_ON> condition()
  | < SQL_USING> <SQL_LPARENCHAR> column() (< SQL_COMMA_CHAR > column() )+ <SQL_RPARENCHAR>
  ]
}

void outer_join_type() : 
{}
{

( < SQL_FULL> | < SQL_LEFT> | < SQL_RIGHT> ) [ < SQL_OUTER> ]
}
void cross_outer_apply_clause() : 
{}
{

( < CROSS > | < SQL_OUTER> ) < APPLY > ( table_reference() | collection_expression() )
}
 

void group_by_clause() : 
{}
{

< SQL_GROUP> < SQL_BY>
  ( expr()
   | rollup_cube_clause()
   | grouping_sets_clause()
   )
   (< SQL_COMMA_CHAR >
	   ( expr()
	    | rollup_cube_clause()
	    | grouping_sets_clause()
	    )
   )+
   [ < SQL_HAVING> condition() ]
}
void rollup_cube_clause() : 
{}
{

( < ROLLUP > | < CUBE > ) <SQL_LPARENCHAR> grouping_expression_list() <SQL_RPARENCHAR>
}
void grouping_sets_clause() : 
{}
{

< SQL_ORA_GROUPING> < SETS> <SQL_LPARENCHAR> ( rollup_cube_clause() | grouping_expression_list() ) <SQL_RPARENCHAR>
}
void grouping_expression_list() : 
{}
{

expression_list() (< SQL_COMMA_CHAR > expression_list() )+
}

void model_clause() : 
{}
{
< MODEL >
   [ cell_reference_options() ]
   [ return_rows_clause() ]
   ( reference_model() )*
   main_model()
}
void cell_reference_options() : 
{}
{
( < IGNORE > | < KEEP > ) < NAV > |  < UNIQUE > ( < DIMENSION > | < SINGLE> < REFERENCE>) 
}
void return_rows_clause() : 
{}
{

< RETURN > ( < UPDATED > | < SQL_ALL> ) < ROWS >
}
void reference_model() : 
{}
{

< REFERENCE > reference_spreadsheet_name()
< SQL_ON> <SQL_LPARENCHAR> subquery() <SQL_RPARENCHAR>
spreadsheet_column_clauses()
  [ cell_reference_options() ]
}
void main_model() : 
{}
{
[ < MAIN > main_model_name() ]
model_column_clauses()
[ cell_reference_options() ]
model_rules_clause()
}
void model_column_clauses() : 
{}
{
[ < PARTITION> < SQL_BY> <SQL_LPARENCHAR> expr() [ c_alias() ] (< SQL_COMMA_CHAR > expr() [c_alias()] )* <SQL_RPARENCHAR>  ]
< DIMENSION> < SQL_BY> <SQL_LPARENCHAR> expr() [c_alias()] (< SQL_COMMA_CHAR > expr() [c_alias()] )* <SQL_RPARENCHAR>
< MEASURES > <SQL_LPARENCHAR> expr() [c_alias()] (< SQL_COMMA_CHAR > expr() [c_alias()] )* <SQL_RPARENCHAR>
}
void model_column() : 
{}
{

expr() [ [ < SQL_AS> ] c_alias() ]
}
void model_rules_clause() : 
{}
{

[ < RULES >
  [ ( < SQL_UPDATE> | < UPSERT > [ < SQL_ALL> ] ) ]
  [ ( < AUTOMATIC > | < SEQUENTIAL > ) < SQL_ORDER> ]
  [ model_iterate_clause() ]
]
<SQL_LPARENCHAR> [ ( < SQL_UPDATE> | < UPSERT > [ < SQL_ALL> ] ) ]
cell_assignment() [ order_by_clause() ] <ESQL_EQ> expr()
  (
    < SQL_COMMA_CHAR >  [ ( < SQL_UPDATE> | < UPSERT > [ < SQL_ALL> ] ) ]
    cell_assignment() [ order_by_clause() ] <ESQL_EQ> expr()
)*
<SQL_RPARENCHAR>
}
void model_iterate_clause() : 
{}
{
< ITERATE > <SQL_LPARENCHAR> number() <SQL_RPARENCHAR> [ < UNTIL > <SQL_LPARENCHAR> condition() <SQL_RPARENCHAR> ]
}
void cell_assignment() : 
{}
{

measure_column() < LEFT_ > ( ( condition()
                   | expr()
                   | single_column_for_loop()
                   )
                     (< SQL_COMMA_CHAR > ( condition()
                        | expr()
                        | single_column_for_loop()
                        )
                     )+
                 | multi_column_for_loop()
                 )
               < RIGHT_ >
}

void single_column_for_loop() : 
{}
{

< FOR > dimension_column()
  ( < SQL_IN> ( ( literal() (< SQL_COMMA_CHAR > literal() )+
         | subquery()
         )
       )
  | [ < SQL_LIKE > pattern() ] < SQL_FROM> literal() < TO > literal()
      ( < INCREMENT > | < DECREMENT > ) literal()
  )
}
void multi_column_for_loop() : 
{}
{

< FOR > <SQL_LPARENCHAR> dimension_column()
      (< SQL_COMMA_CHAR > dimension_column() )+ <SQL_RPARENCHAR>
< SQL_IN> <SQL_LPARENCHAR> ( (literal() (< SQL_COMMA_CHAR > literal() )+)
       ( (literal() (< SQL_COMMA_CHAR > literal() )+) )+
     | subquery()
     )
   <SQL_RPARENCHAR>
}
 
void row_limiting_clause() : 
{}
{
(
 < SQL_OFFSET> offset() ( < ROW > | < ROWS > )
| 
 < FETCH > ( < SQL_ORA_FIRST> | < NEXT > ) [ ( rowcount() | percent() < PERCENT > ) ]
    ( < ROW > | < ROWS > ) ( < ONLY > | < SQL_WITH> < TIES>)
)+     
}
void for_update_clause() : 
{}
{

< FOR> < SQL_UPDATE>[ < OF > [ [ schema()< SQL_PERIOD_CHAR > ] ( table() | view() ) < SQL_PERIOD_CHAR > ] column()
         (
           < SQL_COMMA_CHAR > [ [ schema()< SQL_PERIOD_CHAR > ] ( table() | view() ) < SQL_PERIOD_CHAR > ] column()
       )*
  ]
  [ ( < NOWAIT > | < WAIT > integer() 
    | < SQL_SKIP> < LOCKED>)
  ]
}
void row_pattern_clause() : 
{}
{

< MATCH_RECOGNIZE > <SQL_LBRACKET>
  [ row_pattern_partition_by() ]
  [ row_pattern_order_by() ]
  [ row_pattern_measures() ]
  [ row_pattern_rows_per_match() ]
  [ row_pattern_skip_to() ]
  < PATTERN > <SQL_LPARENCHAR> row_pattern() <SQL_RPARENCHAR>
  [ row_pattern_subset_clause() ]
  < DEFINE > row_pattern_definition_list()
  <SQL_RBRACKET>
}
void row_pattern_partition_by() : 
{}
{

< PARTITION> < SQL_BY>column() (< SQL_COMMA_CHAR > column() )+
}
void row_pattern_order_by() : 
{}
{

< SQL_ORDER> < SQL_BY>column() (< SQL_COMMA_CHAR > column() )+
}
void row_pattern_measures() : 
{}
{

< MEASURES > row_pattern_measure_column() (< SQL_COMMA_CHAR > row_pattern_measure_column() )+
}
void row_pattern_measure_column() : 
{}
{

expr() < SQL_AS> c_alias()
}
void row_pattern_rows_per_match() : 
{}
{

< ONE > < ROW > < PER > < MATCH > 
| < SQL_ALL> < ROWS > < PER > < MATCH > 
}
void row_pattern_skip_to() : 
{}
{

< AFTER> < MATCH>(
  < SQL_SKIP > < TO > < NEXT > < ROW > 
  | < SQL_SKIP > < PAST > < SQL_ORA_LAST> < ROW > 
  | < SQL_SKIP > < TO > < SQL_ORA_FIRST>  variable_name()
  | < SQL_SKIP > < TO > < SQL_ORA_LAST>  variable_name()
  | < SQL_SKIP> < TO>variable_name()
  )
}
void row_pattern() : 
{}
{
 row_pattern_term() [ <SQL_ORCHAR> row_pattern()  ]
}
void row_pattern_term() : 
{}
{
  row_pattern_factor() [ row_pattern_term() ] 
}
void row_pattern_factor() : 
{}
{
row_pattern_primary() [ row_pattern_quantifier() ]
}
void row_pattern_primary() : 
{}
{
variable_name()
| "$"
| "^"
| <SQL_LPARENCHAR> [ row_pattern() ] <SQL_RPARENCHAR>
| < SQL_LBRACKET > <SQL_MINUSCHAR> row_pattern() <SQL_MINUSCHAR> <SQL_RBRACKET>
| row_pattern_permute()
}
void row_pattern_permute() : 
{}
{

< PERMUTE > <SQL_LPARENCHAR> row_pattern() (< SQL_COMMA_CHAR > row_pattern() )+ <SQL_RPARENCHAR>
}
void row_pattern_quantifier() : 
{}
{

<SQL_ASTERISKCHAR> [ <SQL_QUESTIONCHAR> ]
| <SQL_PLUSCHAR> [ <SQL_QUESTIONCHAR> ]
| <SQL_QUESTIONCHAR> [ <SQL_QUESTIONCHAR> ]
| <SQL_LBRACKET> [ unsigned_integer() ] < SQL_COMMA_CHAR > [ unsigned_integer() ] <SQL_RBRACKET> [ <SQL_QUESTIONCHAR> ]
| <SQL_LBRACKET> unsigned_integer() <SQL_RBRACKET>

}
void row_pattern_subset_clause() : 
{}
{

< SUBSET > row_pattern_subset_item() (< SQL_COMMA_CHAR > row_pattern_subset_item() )+
}
void row_pattern_subset_item() : 
{}
{

variable_name() <ESQL_EQ> <SQL_LPARENCHAR> variable_name() [< SQL_COMMA_CHAR > variable_name() ] <SQL_RPARENCHAR>
}
void row_pattern_definition_list() : 
{}
{

row_pattern_definition() (< SQL_COMMA_CHAR > row_pattern_definition() )+
}
void row_pattern_definition() : 
{}
{

variable_name() < SQL_AS> condition()
}
void row_pattern_rec_func() : 
{}
{

row_pattern_classifier_func()
| row_pattern_match_num_func()
| row_pattern_navigation_func()
| row_pattern_aggregate_func()
}
void row_pattern_classifier_func() : 
{}
{

< CLASSIFIER ><SQL_LPARENCHAR> <SQL_RPARENCHAR>
}
void row_pattern_match_num_func() : 
{}
{

< MATCH_NUMBER ><SQL_LPARENCHAR> <SQL_RPARENCHAR>
}
void row_pattern_navigation_func() : 
{}
{

row_pattern_nav_logical()
| row_pattern_nav_physical()
| row_pattern_nav_compound()
}
void row_pattern_nav_logical() : 
{}
{

[ < RUNNING > | < FINAL > ] ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> ) <SQL_LPARENCHAR> expr() [< SQL_COMMA_CHAR > offset() ] <SQL_RPARENCHAR>
}
void row_pattern_nav_physical() : 
{}
{

( < PREV > | < NEXT > ) <SQL_LPARENCHAR> expr() [< SQL_COMMA_CHAR > offset() ] <SQL_RPARENCHAR>
}
void row_pattern_nav_compound() : 
{}
{

( < PREV > | < NEXT > )
<SQL_LPARENCHAR> [ < RUNNING > | < FINAL > ] ( < SQL_ORA_FIRST> | < SQL_ORA_LAST> )
<SQL_LPARENCHAR> expr() [< SQL_COMMA_CHAR > offset() ] <SQL_RPARENCHAR> [< SQL_COMMA_CHAR > offset()]
<SQL_RPARENCHAR>
}
void row_pattern_aggregate_func() : 
{}
{

[ < RUNNING > | < FINAL > ] aggregate_function()
}
void set_constraints() : 
{}
{

< SQL_SET> ( < CONSTRAINT > | < CONSTRAINTS > )
    ( constraint() (< SQL_COMMA_CHAR > constraint() )+
    | < SQL_ALL>
    )
    ( < IMMEDIATE > | < DEFERRED > ) 
}
void set_role() : 
{}
{

< SQL_SET> < ROLE>( role() [ < IDENTIFIED> < SQL_BY>password() ]
     (
       < SQL_COMMA_CHAR > role() [ < IDENTIFIED> < SQL_BY>password() ] )*
   | < SQL_ALL> [ < EXCEPT > role() (< SQL_COMMA_CHAR > role() )+ ]
   | < NONE >
   ) 
}
void set_transaction() : 
{}
{

< SQL_SET> < TRANSACTION>( ( < READ > ( < ONLY > | < WRITE > )
     | < ISOLATION> < LEVEL>( < SERIALIZABLE > | < READ> < COMMITTED>)
     | < USE > < ROLLBACK > < SEGMENT >  rollback_segment()
     ) [ < NAME > string() ]
   | < NAME > string()
   ) 
}
void truncate_cluster() : 
{}
{

< SQL_TRUNCATE> < CLUSTER>[schema()< SQL_PERIOD_CHAR >] cluster()
  [ (< SQL_DROP> | <  REUSE >) < STORAGE > ] 
}
void truncate_table() : 
{}
{

< SQL_TRUNCATE> < SQL_TABLE>[schema()< SQL_PERIOD_CHAR >] table()
  [ (< PRESERVE >| <  PURGE >) < MATERIALIZED > < VIEW > < SQL_ORA_LOG>  ]
  [ (< SQL_DROP> [ < SQL_ALL> ] | < REUSE >) < STORAGE > ] [ < CASCADE > ] 
}
void update() : 
{}
{

< SQL_UPDATE> [ hint() ]
   ( dml_table_expression_clause()
   | < ONLY > (dml_table_expression_clause())
   ) [ t_alias() ]
   update_set_clause()
   [ where_clause() ]
   [ returning_clause() ]
   [error_logging_clause()] 
}

 
 
 
void update_set_clause() : 
{}
{

< SQL_SET>
( ( (column() (< SQL_COMMA_CHAR > column() )+) <ESQL_EQ> (subquery())
  | column() <ESQL_EQ> ( expr() | (subquery()) | < SQL_DEFAULT > )
  )
     (< SQL_COMMA_CHAR > ( (column() (< SQL_COMMA_CHAR > column())+) <ESQL_EQ> (subquery())
        | column() <ESQL_EQ> ( expr() | (subquery()) | < SQL_DEFAULT > )
        )
     )+
| < SQL_ORA_VALUE> (t_alias()) <ESQL_EQ> ( expr() | (subquery()) )
)
}
 
 


 

void query_partition_clause() : 
{}
{

< PARTITION> < SQL_BY>( expr()(< SQL_COMMA_CHAR > expr() )+
  | ( expr()(< SQL_COMMA_CHAR > expr() )+ )
  )
}
void alter_java() : 
{}
{

< ALTER> < JAVA>( < SOURCE > | < CLASS > ) [ schema()< SQL_PERIOD_CHAR > ]object_name() 
  [ < RESOLVER > 
      <SQL_LPARENCHAR>  ( <SQL_LPARENCHAR> match_string() [< SQL_COMMA_CHAR > ] ( schema_name() | <SQL_MINUSCHAR> ) <SQL_RPARENCHAR> )+ <SQL_RPARENCHAR>
  ]
  ( ( < COMPILE > | < RESOLVE > )
  | invoker_rights_clause()
  ) 
}



/*TEMP*/

void e() :
{}
{
"e_" /*TODO*/
}
void E() :
{}
{
"E_" /*TODO*/
}
void f() :
{}
{
"f_" /*TODO*/
}
void F() :
{}
{
"F_" /*TODO*/
}
void d() :
{}
{
"d_" /*TODO*/
}
void D() :
{}
{
"D_" /*TODO*/
}
void expr1() :
{}
{
"expr1" /*TODO*/
}
void expr2() :
{}
{
"expr2" /*TODO*/
}
void leading_field_precision() :
{}
{
"leading_field_precision" /*TODO*/
}
void fractional_second_precision() :
{}
{
"fractional_second_precision" /*TODO*/
}
void table_alias() :
{}
{
"table_alias" /*TODO*/
}
void JSON_column() :
{}
{
"JSON_column" /*TODO*/
}
void JSON_object_key() :
{}
{
"JSON_object_key" /*TODO*/
}
void measure_column() :
{}
{
"measure_column" /*TODO*/
}

void aggregate_function() :
{}
{
(
approx_count_distinct()
|avg()
|collect()
|corr()
|correlation()
|count()
|covar_pop()
|covar_samp()
|cume_dist()
|dense_rank()
|group_id()
|grouping()
|grouping_id()
|last()
|listagg()
|max()
|median()
|min()
|percent_rank()
|percentile_cont()
|percentile_disc()
|rank()
|linear_regr()
|stats_binomial_test()
|stats_crosstab()
|stats_f_test()
|stats_ks_test()
|stats_mode()
|stats_mw_test()
|stats_one_way_anova()
|stats_t_test()
|stats_wsr_test()
|stddev()
|stddev_pop()
|stddev_samp()
|sum()
|sys_op_zone_id()
|sys_xmlagg()
|var_pop()
|var_samp()
|variance()
|xmlagg()
)
[first()]
[last()]
}
void object_table_alias() :
{}
{
"object_table_alias" /*TODO*/
}
void attribute() :
{}
{
"attribute" /*TODO*/
}
void method() :
{}
{
"method" /*TODO*/
}
void argument() :
{}
{
"argument" /*TODO*/
}
void host_variable() :
{}
{
"host_variable" /*TODO*/
}
void indicator_variable() :
{}
{
"indicator_variable" /*TODO*/
}
void type_name() :
{}
{
"type_name" /*TODO*/
}
void comparison_condition() :
{}
{
"comparison_condition" /*TODO*/
}
void logical_condition() :
{}
{
 < SQL_NOT > | < SQL_AND > | < SQL_OR > 
}
void model_condition() :
{}
{
	is_any_condition()
}
void multiset_condition() :
{}
{
"multiset_condition" /*TODO*/
}
void pattern_matching_condition() :
{}
{
"pattern_matching_condition" /*TODO*/
}
void range_condition() :
{}
{
"range_condition" /*TODO*/
}
void XML_condition() :
{}
{
"XML_condition" /*TODO*/
}
void JSON_condition() :
{}
{
"JSON_condition" /*TODO*/
}
void dimension_column() :
{}
{
"dimension_column" /*TODO*/
}
void cell_reference() :
{}
{
"cell_reference" /*TODO*/
}
void nested_table() :
{}
{
"nested_table" /*TODO*/
}
void char1() :
{}
{
"char1" /*TODO*/
}
void char2() :
{}
{
"char2" /*TODO*/
}
void esc_char() :
{}
{
"esc_char" /*TODO*/
}
void source_char() :
{}
{
"source_char" /*TODO*/
}
void pattern() :
{}
{
"pattern" /*TODO*/
}
void match_param() :
{}
{
"match_param" /*TODO*/
}
void path_string() :
{}
{
"path_string" /*TODO*/
}
void correlation_integer() :
{}
{
"correlation_integer" /*TODO*/
}
void levels() :
{}
{
"levels" /*TODO*/
}
void JSON_path_expression() :
{}
{
"JSON_path_expression" /*TODO*/
}
void JSON_exists_on_error_clause() :
{}
{
"JSON_exists_on_error_clause" /*TODO*/
}
void simple_name() :
{}
{
"simple_name" /*TODO*/
}
void complex_name() :
{}
{
"complex_name" /*TODO*/
}
void expr3() :
{}
{
"expr3" /*TODO*/
}
void type() :
{}
{
"type" /*TODO*/
}
void object_reference_function() :
{}
{
(deref()
| make_ref()
| ref()
| reftohex()
| value()
)
}
void model_function() :
{}
{
cv()
| iteration_number()
| presentnnv()
| presentv()
| previous()
}
void OLAP_function() :
{}
{
cube_table()
}
void data_cartridge_function() :
{}
{
dataobj_to_partition()
}
void numeric_function() :
{}
{
(abs()
| acos()
| asin()
| atan()
| atan2()
| bitand()
| ceil()
| cos()
| cosh()
| exp()
| floor()
| ln()
| log()
| mod()
| nanvl()
| power()
| remainder()
| row_number()
| sign()
| sin()
| sinh()
| sqrt()
| tan()
| tanh()
| trunc_number()
| width_bucket()
)
}
void character_function() :
{}
{
(
/*Returning Character*/  
chr()
| concat()
| initcap()
| lower()
| lpad()
| ltrim()
| nchr()
| nls_initcap()
| nls_lower()
| nls_upper()
| nlssort()
| regexp_replace()
| regexp_substr()
| replace()
| rpad()
| rtrim()
| soundex()
| substr()
| translate()
| translate_using()
| trim()
| upper()
/*Returning Number*/
| ascii()
| instr()
| length()
| regexp_count()
| regexp_instr()
/*NLS Character Functions*/
| nls_charset_decl_len()
| nls_charset_id()
| nls_charset_name())
}
void datetime_function() :
{}
{
add_months()
| current_date()
| current_timestamp()
| dbtimezone()
| extract_datetime()
| from_tz()
| last_day()
| localtimestamp()
| months_between()
| new_time()
| next_day()
| numtodsinterval()
| numtoyminterval()
| ora_dst_affected()
| ora_dst_convert()
| ora_dst_error()
| round_date()
| sessiontimezone()
| sys_extract_utc()
| sysdate()
| systimestamp()
| to_char_date()
| to_dsinterval()
| to_timestamp()
| to_timestamp_tz()
| to_yminterval()
| trunc_date()
| tz_offset()
}
void comparison_function() :
{}
{
( greatest() | least() )
}
void conversion_function() :
{}
{
(
asciistr()
| bin_to_num()
| cast()
| chartorowid()
| compose()
| convert()
| decompose()
| hextoraw()
| numtodsinterval()
| numtoyminterval()
| rawtohex()
| rawtonhex()
| rowidtochar()
| rowidtonchar()
| scn_to_timestamp()
| timestamp_to_scn()
| to_binary_double()
| to_binary_float()
| to_blob()
| to_char_char()
| to_char_date()
| to_char_number()
| to_clob()
| to_date()
| to_dsinterval()
| to_lob()
| to_multi_byte()
| to_nchar_char()
| to_nchar_date()
| to_nchar_number()
| to_nclob()
| to_number()
| to_single_byte()
| to_timestamp()
| to_timestamp_tz()
| to_yminterval()
| treat()
| unistr()  )
}
void large_object_function() :
{}
{
( bfilename() | empty_lob() )
}
void collection_function() :
{}
{
(
cardinality()
| collect()
| powermultiset()
| powermultiset_by_cardnlty()
| set())
}
void hierarchical_function() :
{}
{
  sys_connect_by_path()
}
void data_mining_function() :
{}
{
(
  cluster_details()
| cluster_distance()
| cluster_id()
| cluster_probability()
| cluster_set()
| feature_details()
| feature_id()
| feature_set()
| feature_value()
| prediction()
| prediction_bounds()
| prediction_cost()
| prediction_details()
| prediction_probability()
| prediction_set())
}
void XML_function() :
{}
{
(
appendchildxml()
| deletexml()
| depth()
| existsnode()
| extract_xml()
| extractvalue()
| insertchildxml()
| insertchildxmlafter()
| insertchildxmlbefore()
| insertxmlafter()
| insertxmlbefore()
| path()
| sys_dburigen()
| sys_xmlagg()
| sys_xmlgen()
| updatexml()
| xmlagg()
| xmlcast()
| xmlcdata()
| xmlcolattval()
| xmlcomment()
| xmlconcat()
| xmldiff()
| xmlelement()
| xmlexists()
| xmlforest()
| xmlisvalid()
| xmlparse()
| xmlpatch()
| xmlpi()
| xmlquery()
| xmlroot()
| xmlsequence()
| xmlserialize()
| xmltable()
| xmltransform()
)
}
void JSON_function() :
{}
{
(
json_query()
| json_table()
| json_value())
}
void encoding_decoding_function() :
{}
{
(
decode()
| dump()
| ora_hash()
| standard_hash()
| vsize())
}
void NULL_related_function() :
{}
{
(coalesce()
| lnnvl()
| nanvl()
| nullif()
| nvl()
| nvl2()
)
}
void environment_id_function() :
{}
{
(con_dbid_to_id()
| con_guid_to_id()
| con_name_to_id()
| con_uid_to_id()
| ora_invoking_user()
| ora_invoking_userid()
| sys_context()
| sys_guid()
| sys_typeid()
| uid()
| user()
| userenv()
)
}
void arguments() :
{}
{
"arguments" /*TODO*/
}
void position() :
{}
{
"position" /*TODO*/
}
void c_alias() :
{}
{
( < SQL_QUOTED_IDENTIFIER >  |  <SQL_CHAR_LITERAL > | <SQL_IDENTIFIER>)
}
void value_expr() :
{}
{
"value_expr" /*TODO*/
}
void n() :
{}
{
"n" /*TODO*/
}
void date() :
{}
{
"date" /*TODO*/
}
void XMLType_instance() :
{}
{
"XMLType_instance" /*TODO*/
}
void XPath_string() :
{}
{
"XPath_string" /*TODO*/
}
void namespace_string() :
{}
{
"namespace_string" /*TODO*/
}


void n1() :
{}
{
"n1" /*TODO*/
}
void n2() :
{}
{
"n2" /*TODO*/
}
void directory() :
{}
{
"directory" /*TODO*/
}
void filename() :
{}
{
"filename" /*TODO*/
}
void model() :
{}
{
"model" /*TODO*/
}
void topN() :
{}
{
"topN" /*TODO*/
}
void DESC() :
{}
{
<SQL_DESC> /*TODO*/
}
void ASC() :
{}
{
<SQL_ASC> /*TODO*/
}
void ABS() :
{}
{
<SQL_ORA_ABS> /*TODO*/
}
void INTO() :
{}
{
<SQL_INTO> /*TODO*/
}
void OVER() :
{}
{
<SQL_ORA_OVER> /*TODO*/
}
void alias() :
{}
{
"alias" /*TODO*/
}
void cutoff() :
{}
{
"cutoff" /*TODO*/
}
void container_dbid() :
{}
{
"container_dbid" /*TODO*/
}
void container_guid() :
{}
{
"container_guid" /*TODO*/
}
void container_name() :
{}
{
"container_name" /*TODO*/
}
void container_uid() :
{}
{
"container_uid" /*TODO*/
}
void dest_char_set() :
{}
{
"dest_char_set" /*TODO*/
}
void source_char_set() :
{}
{
"source_char_set" /*TODO*/
}
void cube() :
{}
{
"cube" /*TODO*/
}
void dimension() :
{}
{
"dimension" /*TODO*/
}
void hierarchy() :
{}
{
"hierarchy" /*TODO*/
}
void partition_id() :
{}
{
"partition_id" /*TODO*/
}
void search() :
{}
{
"search" /*TODO*/
}
void result() :
{}
{
"result" /*TODO*/
}
void return_fmt() :
{}
{
"return_fmt" /*TODO*/
}
void start_position() :
{}
{
"start_position" /*TODO*/
}
void NULLS() :
{}
{
<NULLS> /*TODO*/
}
void timestamp_value() :
{}
{
"timestamp_value" /*TODO*/
}
void time_zone_value() :
{}
{
"time_zone_value" /*TODO*/
}
void child_expr() :
{}
{
"child_expr" /*TODO*/
}
void substring() :
{}
{
"substring" /*TODO*/
}
void occurrence() :
{}
{
"occurrence" /*TODO*/
}
void JSON_query_returning_clause() :
{}
{
"JSON_query_returning_clause" /*TODO*/
}
void JSON_query_wrapper_clause() :
{}
{
"JSON_query_wrapper_clause" /*TODO*/
}
void JSON_query_on_error_clause() :
{}
{
"JSON_query_on_error_clause" /*TODO*/
}
void JSON_query_return_type() :
{}
{
"JSON_query_return_type" /*TODO*/
}
void JSON_table_on_error_clause() :
{}
{
"JSON_table_on_error_clause" /*TODO*/
}
void JSON_columns_clause() :
{}
{
"JSON_columns_clause" /*TODO*/
}
void literal() :
{}
{
	<SQL_CHAR_LITERAL >
}
void JSON_column_definition() :
{}
{
"JSON_column_definition" /*TODO*/
}
void JSON_exists_column() :
{}
{
"JSON_exists_column" /*TODO*/
}
void JSON_query_column() :
{}
{
"JSON_query_column" /*TODO*/
}
void JSON_value_column() :
{}
{
"JSON_value_column" /*TODO*/
}
void JSON_nested_path() :
{}
{
"JSON_nested_path" /*TODO*/
}
void column_name() :
{}
{
"column_name" /*TODO*/
}
void JSON_value_return_type() :
{}
{
"JSON_value_return_type" /*TODO*/
}
void JSON_value_on_error_clause() :
{}
{
"JSON_value_on_error_clause" /*TODO*/
}
void JSON_value_returning_clause() :
{}
{
"JSON_value_returning_clause" /*TODO*/
}
void offset() :
{}
{
"offset" /*TODO*/
}
void sql_default() :
{}
{
"sql_default" /*TODO*/
}
void measure_expr() :
{}
{
"measure_expr" /*TODO*/
}
void delimiter() :
{}
{
"delimiter" /*TODO*/
}
void timestamp_precision() :
{}
{
"timestamp_precision" /*TODO*/
}
void key() :
{}
{
"key" /*TODO*/
}
void date1() :
{}
{
"date1" /*TODO*/
}
void date2() :
{}
{
"date2" /*TODO*/
}
void timezone1() :
{}
{
"timezone1" /*TODO*/
}
void timezone2() :
{}
{
"timezone2" /*TODO*/
}
void byte_count() :
{}
{
"byte_count" /*TODO*/
}
void char_set_id() :
{}
{
"char_set_id" /*TODO*/
}
void nlsparam() :
{}
{
<SQL_IDENTIFIER>
}
void interval_unit() :
{}
{
"interval_unit" /*TODO*/
}
void datetime_expr() :
{}
{
"datetime_expr" /*TODO*/
}
void max_bucket() :
{}
{
"max_bucket" /*TODO*/
}
void seed_value() :
{}
{
"seed_value" /*TODO*/
}
void OF() :
{}
{
<OF> /*TODO*/
}
void ANOMALY() :
{}
{
"ANOMALY" /*TODO*/
}
void FOR() :
{}
{
<FOR> /*TODO*/
}
void class_value() :
{}
{
"class_value" /*TODO*/
}
void cost_value() :
{}
{
"cost_value" /*TODO*/
}
void confidence_level() :
{}
{
"confidence_level" /*TODO*/
}
void sql_class() :
{}
{
"sql_class" /*TODO*/
}
void bestN() :
{}
{
"bestN" /*TODO*/
}
void raw() :
{}
{
"raw" /*TODO*/
}
void correlation_variable() :
{}
{
"correlation_variable" /*TODO*/
}
void return_opt() :
{}
{
"return_opt" /*TODO*/
}
void subexpr() :
{}
{
"subexpr" /*TODO*/
}
void replace_string() :
{}
{
"replace_string" /*TODO*/
}
void search_string() :
{}
{
"search_string" /*TODO*/
}
void replacement_string() :
{}
{
"replacement_string" /*TODO*/
}
void fmt() :
{}
{
"fmt" /*TODO*/
}
void rowid() :
{}
{
"rowid" /*TODO*/
}
void p() :
{}
{
"p" /*TODO*/
}
void substring_length() :
{}
{
"substring_length" /*TODO*/
}
void namespace() :
{}
{
"namespace" /*TODO*/
}
void parameter() :
{}
{
"parameter" /*TODO*/
}
void text() :
{}
{
"text" /*TODO*/
}
void datetime_with_timezone() :
{}
{
"datetime_with_timezone" /*TODO*/
}
void t_alias() :
{}
{
"t_alias" /*TODO*/
}
void object_type_value() :
{}
{
"object_type_value" /*TODO*/
}
void timestamp() :
{}
{
"timestamp" /*TODO*/
}
void raw_value() :
{}
{
"raw_value" /*TODO*/
}
void nchar() :
{}
{
"nchar" /*TODO*/
}
void clob() :
{}
{
"clob" /*TODO*/
}
void nclob() :
{}
{
"nclob" /*TODO*/
}
void datetime() :
{}
{
"datetime" /*TODO*/
}
void interval() :
{}
{
"interval" /*TODO*/
}
void lob_column() :
{}
{
"lob_column" /*TODO*/
}
void days() :
{}
{
"days" /*TODO*/
}
void hours() :
{}
{
"hours" /*TODO*/
}
void minutes() :
{}
{
"minutes" /*TODO*/
}
void seconds() :
{}
{
"seconds" /*TODO*/
}
void frac_secs() :
{}
{
"frac_secs" /*TODO*/
}
void long_column() :
{}
{
"long_column" /*TODO*/
}
void years() :
{}
{
"years" /*TODO*/
}
void months() :
{}
{
"months" /*TODO*/
}
void from_string() :
{}
{
"from_string" /*TODO*/
}
void to_string() :
{}
{
"to_string" /*TODO*/
}
void trim_character() :
{}
{
"trim_character" /*TODO*/
}
void trim_source() :
{}
{
"trim_source" /*TODO*/
}
void min_value() :
{}
{
"min_value" /*TODO*/
}
void max_value() :
{}
{
"max_value" /*TODO*/
}
void num_buckets() :
{}
{
"num_buckets" /*TODO*/
}
void value_expression() :
{}
{
"value_expression" /*TODO*/
}
void datatype() :
{}
{
"datatype" /*TODO*/
}
void XMLType_document() :
{}
{
"XMLType_document" /*TODO*/
}
void identifier() :
{}
{
"identifier" /*TODO*/
}
void XML_attributes_clause() :
{}
{
"XML_attributes_clause" /*TODO*/
}
void XQuery_string() :
{}
{
"XQuery_string" /*TODO*/
}
void XML_passing_clause() :
{}
{
"XML_passing_clause" /*TODO*/
}
void EVALNAME() :
{}
{
<EVALNAME> /*TODO*/
}
void XMLSchema_URL() :
{}
{
"XMLSchema_URL" /*TODO*/
}
void element() :
{}
{
"element" /*TODO*/
}
void sys_refcursor_instance() :
{}
{
"sys_refcursor_instance" /*TODO*/
}
void xml_encoding_spec() :
{}
{
"xml_encoding_spec" /*TODO*/
}
void string_literal() :
{}
{
"string_literal" /*TODO*/
}
void XMLnamespaces_clause() :
{}
{
"XMLnamespaces_clause" /*TODO*/
}
void XMLTABLE_options() :
{}
{
"XMLTABLE_options" /*TODO*/
}
void XML_table_column() :
{}
{
"XML_table_column" /*TODO*/
}
void sql_package() :
{}
{
"sql_package" /*TODO*/
}
void user_defined_operator() :
{}
{
"user_defined_operator" /*TODO*/
}
void constraint_name() :
{}
{
"constraint_name" /*TODO*/
}
void scope_table() :
{}
{
"scope_table" /*TODO*/
}
void ref_col() :
{}
{
"ref_col" /*TODO*/
}
void ref_attr() :
{}
{
"ref_attr" /*TODO*/
}
void create_index_statement() :
{}
{
"create_index_statement" /*TODO*/
}
void XMLTable_index_clause() :
{}
{
"XMLTable_index_clause" /*TODO*/
}
void XMLIndex_clause() :
{}
{
"XMLIndex_clause" /*TODO*/
}
void tablespace() :
{}
{
"tablespace" /*TODO*/
}

void diskgroup_name() :
{}
{
"diskgroup_name" /*TODO*/
}
void db_name() :
{}
{
"db_name" /*TODO*/
}
void file_type() :
{}
{
"file_type" /*TODO*/
}
void file_type_tag() :
{}
{
"file_type_tag" /*TODO*/
}
void filenumber() :
{}
{
"filenumber" /*TODO*/
}
void incarnation_number() :
{}
{
"incarnation_number" /*TODO*/
}
void template_name() :
{}
{
"template_name" /*TODO*/
}
void alias_name() :
{}
{
"alias_name" /*TODO*/
}
void keystore_location() :
{}
{
"keystore_location" /*TODO*/
}
void keystore_password() :
{}
{
"keystore_password" /*TODO*/
}
void backup_identifier() :
{}
{
"backup_identifier" /*TODO*/
}
void old_keystore_password() :
{}
{
"old_keystore_password" /*TODO*/
}
void new_keystore_password() :
{}
{
"new_keystore_password" /*TODO*/
}
void keystore1_location() :
{}
{
"keystore1_location" /*TODO*/
}
void keystore1_password() :
{}
{
"keystore1_password" /*TODO*/
}
void keystore2_location() :
{}
{
"keystore2_location" /*TODO*/
}
void keystore2_password() :
{}
{
"keystore2_password" /*TODO*/
}
void keystore3_location() :
{}
{
"keystore3_location" /*TODO*/
}
void keystore3_password() :
{}
{
"keystore3_password" /*TODO*/
}
void tag() :
{}
{
"tag" /*TODO*/
}
void key_id() :
{}
{
"key_id" /*TODO*/
}
void secret() :
{}
{
"secret" /*TODO*/
}
void HSM_auth_string() :
{}
{
"HSM_auth_string" /*TODO*/
}
void software_keystore_password() :
{}
{
"software_keystore_password" /*TODO*/
}
void client_identifier() :
{}
{
"client_identifier" /*TODO*/
}
void policy() :
{}
{
"policy" /*TODO*/
}
void audit_condition() :
{}
{
"audit_condition" /*TODO*/
}
void system_privilege() :
{}
{
"system_privilege" /*TODO*/
}
void object_action() :
{}
{
"object_action" /*TODO*/
}
void directory_name() :
{}
{
"directory_name" /*TODO*/
}
void object_name() :
{}
{
"object_name" /*TODO*/
}
void system_action() :
{}
{
"system_action" /*TODO*/
}
void component_action() :
{}
{
"component_action" /*TODO*/
}
void role() :
{}
{
"role" /*TODO*/
}
void cluster() :
{}
{
"cluster" /*TODO*/
}
void location() :
{}
{
"location" /*TODO*/
}
void file_number() :
{}
{
"file_number" /*TODO*/
}
void instance_name() :
{}
{
"instance_name" /*TODO*/
}
void logminer_session_name() :
{}
{
"logminer_session_name" /*TODO*/
}
void target_db_name() :
{}
{
"target_db_name" /*TODO*/
}
void scn_value() :
{}
{
"scn_value" /*TODO*/
}
void edition_name() :
{}
{
"edition_name" /*TODO*/
}
void tablespace_group_name() :
{}
{
"tablespace_group_name" /*TODO*/
}
void time_zone_region() :
{}
{
"time_zone_region" /*TODO*/
}
void password() :
{}
{
"password" /*TODO*/
}
void level() :
{}
{
"level" /*TODO*/
}
void level_table() :
{}
{
"level_table" /*TODO*/
}
void level_column() :
{}
{
"level_column" /*TODO*/
}
void child_level() :
{}
{
"child_level" /*TODO*/
}
void parent_level() :
{}
{
"parent_level" /*TODO*/
}
void child_key_column() :
{}
{
"child_key_column" /*TODO*/
}
void dependent_column() :
{}
{
"dependent_column" /*TODO*/
}
void failgroup_name() :
{}
{
"failgroup_name" /*TODO*/
}
void disk_name() :
{}
{
"disk_name" /*TODO*/
}
void QUORUM() :
{}
{
<QUORUM> /*TODO*/
}
void FAILGROUP() :
{}
{
<FAILGROUP> /*TODO*/
}
void DISK() :
{}
{
<DISK> /*TODO*/
}
void path_name() :
{}
{
"path_name" /*TODO*/
}
void old_disk_name() :
{}
{
"old_disk_name" /*TODO*/
}
void new_disk_name() :
{}
{
"new_disk_name" /*TODO*/
}
void old_dir_name() :
{}
{
"old_dir_name" /*TODO*/
}
void new_dir_name() :
{}
{
"new_dir_name" /*TODO*/
}
void old_alias_name() :
{}
{
"old_alias_name" /*TODO*/
}
void new_alias_name() :
{}
{
"new_alias_name" /*TODO*/
}
void asm_volume() :
{}
{
"asm_volume" /*TODO*/
}
void mountpath_name() :
{}
{
"mountpath_name" /*TODO*/
}
void usage_name() :
{}
{
"usage_name" /*TODO*/
}
void attribute_name() :
{}
{
"attribute_name" /*TODO*/
}
void attribute_value() :
{}
{
"attribute_value" /*TODO*/
}
void usergroup() :
{}
{
"usergroup" /*TODO*/
}
void old_user() :
{}
{
"old_user" /*TODO*/
}
void new_user() :
{}
{
"new_user" /*TODO*/
}
void flashback_archive() :
{}
{
"flashback_archive" /*TODO*/
}
void tablespace_name() :
{}
{
"tablespace_name" /*TODO*/
}
void function_name() :
{}
{
"function_name" /*TODO*/
}
void function_compile_clause() :
{}
{
"function_compile_clause" /*TODO*/
}
void ODCI_parameters() :
{}
{
"ODCI_parameters" /*TODO*/
}
void new_name() :
{}
{
"new_name" /*TODO*/
}
void XMLIndex_parameters_clause() :
{}
{
"XMLIndex_parameters_clause" /*TODO*/
}
void partition_name() :
{}
{
"partition_name" /*TODO*/
}
void partition_name_old() :
{}
{
"partition_name_old" /*TODO*/
}
void indextype() :
{}
{
"indextype" /*TODO*/
}
void operator() :
{}
{
"operator" /*TODO*/
}
void parameter_types() :
{}
{
"parameter_types" /*TODO*/
}
void implementation_type() :
{}
{
"implementation_type" /*TODO*/
}

void varray_type() :
{}
{
"varray_type" /*TODO*/
}
void match_string() :
{}
{
"match_string" /*TODO*/
}
void schema_name() :
{}
{
"schema_name" /*TODO*/
}
void library_name() :
{}
{
"library_name" /*TODO*/
}
void library_compile_clause() :
{}
{
"library_compile_clause" /*TODO*/
}
void materialized_view() :
{}
{
"materialized_view" /*TODO*/
}
void LOB_storage_clause() :
{}
{
"LOB_storage_clause" /*TODO*/
}
void modify_LOB_storage_clause() :
{}
{
"modify_LOB_storage_clause" /*TODO*/
}
void LOB_item() :
{}
{
"LOB_item" /*TODO*/
}
void LOB_storage_parameters() :
{}
{
"LOB_storage_parameters" /*TODO*/
}
void LOB_segname() :
{}
{
"LOB_segname" /*TODO*/
}
void LOB_parameters() :
{}
{
"LOB_parameters" /*TODO*/
}
void storage_clauase() :
{}
{
"storage_clauase" /*TODO*/
}
void LOB_retention_clause() :
{}
{
"LOB_retention_clause" /*TODO*/
}
void LOB_deduplicate_clause() :
{}
{
"LOB_deduplicate_clause" /*TODO*/
}
void LOB_compression_clause() :
{}
{
"LOB_compression_clause" /*TODO*/
}
void modify_LOB_parameters() :
{}
{
"modify_LOB_parameters" /*TODO*/
}
void mapping_table_clause() :
{}
{
"mapping_table_clause" /*TODO*/
}
void ref_column() :
{}
{
"ref_column" /*TODO*/
}
void ref_attribute() :
{}
{
"ref_attribute" /*TODO*/
}
void scope_table_name() :
{}
{
"scope_table_name" /*TODO*/
}
void rollback_segment() :
{}
{
"rollback_segment" /*TODO*/
}
void edition() :
{}
{
"edition" /*TODO*/
}
void interval_expr() :
{}
{
"interval_expr" /*TODO*/
}
void staging_log_name() :
{}
{
"staging_log_name" /*TODO*/
}
void zonemap_name() :
{}
{
"zonemap_name" /*TODO*/
}
void parameter_type() :
{}
{
"parameter_type" /*TODO*/
}
void return_type() :
{}
{
"return_type" /*TODO*/
}
void primary_operator() :
{}
{
"primary_operator" /*TODO*/
}
void outline() :
{}
{
"outline" /*TODO*/
}
void new_outline_name() :
{}
{
"new_outline_name" /*TODO*/
}
void new_category_name() :
{}
{
"new_category_name" /*TODO*/
}
void package_name() :
{}
{
"package_name" /*TODO*/
}
void package_compile_clause() :
{}
{
"package_compile_clause" /*TODO*/
}
void pdb_name() :
{}
{
"pdb_name" /*TODO*/
}
void procedure_name() :
{}
{
"procedure_name" /*TODO*/
}
void procedure_compile_clause() :
{}
{
"procedure_compile_clause" /*TODO*/
}
void profile() :
{}
{
"profile" /*TODO*/
}
void synonym() :
{}
{
"synonym" /*TODO*/
}
void client_id() :
{}
{
"client_id" /*TODO*/
}
void integer1() :
{}
{
"integer1" /*TODO*/
}
void integer2() :
{}
{
"integer2" /*TODO*/
}
void integer3() :
{}
{
"integer3" /*TODO*/
}
void ASM_version() :
{}
{
"ASM_version" /*TODO*/
}
void wallet_password() :
{}
{
"wallet_password" /*TODO*/
}
void certificate_id() :
{}
{
"certificate_id" /*TODO*/
}
void dispatcher_name() :
{}
{
"dispatcher_name" /*TODO*/
}
void category_name() :
{}
{
"category_name" /*TODO*/
}
void sid() :
{}
{
"sid" /*TODO*/
}
void new_table_name() :
{}
{
"new_table_name" /*TODO*/
}

void ilm_policy_name() :
{}
{
"ilm_policy_name" /*TODO*/
}
void log_group() :
{}
{
"log_group" /*TODO*/
}
void equijoin_condition() :
{}
{
"equijoin_condition" /*TODO*/
}
void modify_column_clause() :
{}
{
"modify_column_clause" /*TODO*/
}
void column_expression() :
{}
{
"column_expression" /*TODO*/
}
void encrypt_algorithm() :
{}
{
"encrypt_algorithm" /*TODO*/
}
void integrity_algorithm() :
{}
{
"integrity_algorithm" /*TODO*/
}
void valid_time_column() :
{}
{
"valid_time_column" /*TODO*/
}
void start_time_column() :
{}
{
"start_time_column" /*TODO*/
}
void end_time_column() :
{}
{
"end_time_column" /*TODO*/
}
void old_name() :
{}
{
"old_name" /*TODO*/
}
void collection_item() :
{}
{
"collection_item" /*TODO*/
}
void out_of_line_REF_constraint() :
{}
{
"out_of_line_REF_constraint" /*TODO*/
}
void LOB_partition_storage() :
{}
{
"LOB_partition_storage" /*TODO*/
}
void XMLType_column_properties() :
{}
{
"XMLType_column_properties" /*TODO*/
}
void nested_item() :
{}
{
"nested_item" /*TODO*/
}
void storage_table() :
{}
{
"storage_table" /*TODO*/
}
void varray_item() :
{}
{
"varray_item" /*TODO*/
}
void LOB_partitioning_storage() :
{}
{
"LOB_partitioning_storage" /*TODO*/
}
void XMLType_storage() :
{}
{
"XMLType_storage" /*TODO*/
}
void XMLSchema_spec() :
{}
{
"XMLSchema_spec" /*TODO*/
}
void opaque_format_spec() :
{}
{
"opaque_format_spec" /*TODO*/
}
void location_specifier() :
{}
{
"location_specifier" /*TODO*/
}
void varray() :
{}
{
"varray" /*TODO*/
}
void hash_subpartition_quantity() :
{}
{
"hash_subpartition_quantity" /*TODO*/
}
void alter_mapping_table_clause() :
{}
{
"alter_mapping_table_clause" /*TODO*/
}

void partition_number() :
{}
{
"partition_number" /*TODO*/
}
void anydata_column() :
{}
{
"anydata_column" /*TODO*/
}
void new_tablespace_name() :
{}
{
"new_tablespace_name" /*TODO*/
}
void trigger_name() :
{}
{
"trigger_name" /*TODO*/
}
void trigger_compile_clause() :
{}
{
"trigger_compile_clause" /*TODO*/
}
void alter_type_clause() :
{}
{
"alter_type_clause" /*TODO*/
}
void old_password() :
{}
{
"old_password" /*TODO*/
}
void certificate_DN() :
{}
{
"certificate_DN" /*TODO*/
}
void kerberos_principal_name() :
{}
{
"kerberos_principal_name" /*TODO*/
}
void directory_DN() :
{}
{
"directory_DN" /*TODO*/
}
void object_type() :
{}
{
"object_type" /*TODO*/
}
void db_user_proxy() :
{}
{
"db_user_proxy" /*TODO*/
}
void role_name() :
{}
{
"role_name" /*TODO*/
}
void container_data_object() :
{}
{
"container_data_object" /*TODO*/
}
void statistics_type() :
{}
{
"statistics_type" /*TODO*/
}
void cpu_cost() :
{}
{
"cpu_cost" /*TODO*/
}
void io_cost() :
{}
{
"io_cost" /*TODO*/
}
void network_cost() :
{}
{
"network_cost" /*TODO*/
}
void default_selectivity() :
{}
{
"default_selectivity" /*TODO*/
}
void sql_statement_shortcut() :
{}
{
"sql_statement_shortcut" /*TODO*/
}
void sql_operation() :
{}
{
"sql_operation" /*TODO*/
}
void object_option() :
{}
{
"object_option" /*TODO*/
}
void procedure() :
{}
{
"procedure" /*TODO*/
}
void dblink_name() :
{}
{
"dblink_name" /*TODO*/
}
void character_set() :
{}
{
"character_set" /*TODO*/
}
void charset() :
{}
{
"charset" /*TODO*/
}
void filename_pattern() :
{}
{
"filename_pattern" /*TODO*/
}
void replacement_filename_pattern() :
{}
{
"replacement_filename_pattern" /*TODO*/
}
void connect_string() :
{}
{
"connect_string" /*TODO*/
}
void parent_edition() :
{}
{
"parent_edition" /*TODO*/
}
void plsql_function_source() :
{}
{
"plsql_function_source" /*TODO*/
}

void column_list() :
{}
{
"column_list" /*TODO*/
}
void hash_partition_quantity() :
{}
{
"hash_partition_quantity" /*TODO*/
}
void paramater_type() :
{}
{
"paramater_type" /*TODO*/
}
void primary_name() :
{}
{
"primary_name" /*TODO*/
}
void directory_object_name() :
{}
{
"directory_object_name" /*TODO*/
}
void server_file_name() :
{}
{
"server_file_name" /*TODO*/
}
void key_for_BLOB() :
{}
{
"key_for_BLOB" /*TODO*/
}
void plsql_library_source() :
{}
{
"plsql_library_source" /*TODO*/
}
void column_alias() :
{}
{
"column_alias" /*TODO*/
}
void source_outline() :
{}
{
"source_outline" /*TODO*/
}
void category() :
{}
{
"category" /*TODO*/
}
void statement() :
{}
{
"statement" /*TODO*/
}
void plsql_package_source() :
{}
{
"plsql_package_source" /*TODO*/
}
void plsql_package_body_source() :
{}
{
"plsql_package_body_source" /*TODO*/
}
void pfile_name() :
{}
{
"pfile_name" /*TODO*/
}
void spfile_name() :
{}
{
"spfile_name" /*TODO*/
}
void admin_user_name() :
{}
{
"admin_user_name" /*TODO*/
}
void directory_path_name() :
{}
{
"directory_path_name" /*TODO*/
}
void src_pdb_name() :
{}
{
"src_pdb_name" /*TODO*/
}
void plsql_procedure_source() :
{}
{
"plsql_procedure_source" /*TODO*/
}
void restore_point() :
{}
{
"restore_point" /*TODO*/
}
void create_table_statement() :
{}
{
"create_table_statement" /*TODO*/
}
void create_view_statement() :
{}
{
"create_view_statement" /*TODO*/
}
void grant_statement() :
{}
{
"grant_statement" /*TODO*/
}

void OID_clause() :
{}
{
"OID_clause" /*TODO*/
}
void OID_index_clause() :
{}
{
"OID_index_clause" /*TODO*/
}
void oject_properties() :
{}
{
"oject_properties" /*TODO*/
}

void access_driver_type() :
{}
{
"access_driver_type" /*TODO*/
}
void plsql_trigger_source() :
{}
{
"plsql_trigger_source" /*TODO*/
}
void plsql_type_source() :
{}
{
"plsql_type_source" /*TODO*/
}
void plsql_type_body_source() :
{}
{
"plsql_type_body_source" /*TODO*/
}
void XMLType_view_clause() :
{}
{
"XMLType_view_clause" /*TODO*/
}
void superview() :
{}
{
"superview" /*TODO*/
}

void collection_expression() :
{}
{
  (
    column() ( [ <SQL_COMMA_CHAR> ] column() )*
  | subquery()
  | function()  )
   
}
void data_item() :
{}
{
"data_item" /*TODO*/
}
void sequence_name() :
{}
{
"sequence_name" /*TODO*/
}
void trigger() :
{}
{
"trigger" /*TODO*/
}
void object_privilege() :
{}
{
"object_privilege" /*TODO*/
}

void mining_model_name() :
{}
{
"mining_model_name" /*TODO*/
}
void lockmode() :
{}
{
"lockmode" /*TODO*/
}
void username() :
{}
{
"username" /*TODO*/
}
void function_declaration() :
{}
{
"function_declaration" /*TODO*/
}
void procedure_declaration() :
{}
{
"procedure_declaration" /*TODO*/
}
void ordering_column() :
{}
{
"ordering_column" /*TODO*/
}
void cycle_mark_c_alias() :
{}
{
"cycle_mark_c_alias" /*TODO*/
}
void cycle_value() :
{}
{
"cycle_value" /*TODO*/
}
void no_cycle_value() :
{}
{
"no_cycle_value" /*TODO*/
}
void sample_percent() :
{}
{
"sample_percent" /*TODO*/
}
void reference_spreadsheet_name() :
{}
{
"reference_spreadsheet_name" /*TODO*/
}
void spreadsheet_column_clauses() :
{}
{
"spreadsheet_column_clauses" /*TODO*/
}
void main_model_name() :
{}
{
"main_model_name" /*TODO*/
}
void rowcount() :
{}
{
"rowcount" /*TODO*/
}
void percent() :
{}
{
"percent" /*TODO*/
}
void variable_name() :
{}
{
"variable_name" /*TODO*/
}
void unsigned_integer() :
{}
{
"unsigned_integer" /*TODO*/
}

void user_defined_types() :
{
}
{
  /*TODO*/
 "user"
}



void quote_delimiter() :
{
}
{
  "quote_delimiter" /*TODO*/
}

void digit() :
{}
{
	< SQL_INTEGER >
}

void chartorowid() : 
{}
{
/*TODO*/
//< SQL_ORA_CHARTOROWID>(char())
"chartorowid"
}

void ascii() : 
{}
{
  /*TODO*/
//< SQL_ORA_ASCII>(char())
"ascii"
}
void asciistr() : 
{}
{
/*TODO*/
//< SQL_ORA_ASCIISTR>(char())
"b"
}


void hh() :
{
}
{
  "comparison_expr" /*TODO*/

}

void mi() :
{
}
{
  "comparison_expr" /*TODO*/

}

void ss() :
{
}
{
  "comparison_expr" /*TODO*/

}


void time_zone_name() :
{
}
{
  "time_zone_name" /*TODO*/

}

void else_expr() :
{
}
{
  expr()

}

void comparison_expr() :
{
}
{
  expr()

}



void return_expr() :
{
}
{
  expr()

}



void index() :
{}
{
 "index" /*TODO */
}

void table() :
{
}
{
  <SQL_IDENTIFIER>
}

void column() :
{
}
{
  <SQL_IDENTIFIER>
}


void queryblock () :
{
}
{
  "query" /*TODO*/
}

void parameter_name () :
{
}
{
  "parameter_name" /*TODO*/
}

void parameter_value() :
{
}
{
  "parameter_value" /*TODO*/
}

void distribution() :
{}
{
  "distribution" /*TODO*/
}

void outer_distribution() :
{}
{
  "outer_distribution" /*TODO*/
}

void inner_distribution() :
{}
{
  "inner_distribution" /*TODO*/
}


void schema() :
{
}
{
  <SQL_IDENTIFIER>
}

void object() :
{
}
{
  "object" /*TODO*/
}


void part() :
{
}
{
  "part" /*TODO*/
}



void subpartition() :
{
}
{
  "subpartition" /*TODO*/

}

void nested_table1() :
{
}
{
  "nested_table1" /*TODO*/

}

void nested_table2() :
{
}
{
  "nested_table2" /*TODO*/

}


void function_expression() :
{
}
{
  function()

}

void scalar_subquery_expression() :
{
}
{
  <SQL_LPARENCHAR>  subquery() <SQL_RPARENCHAR>
}


void variable_expression() :
{
}
{
  "variable_expression" /*TODO*/

}

void query_name() :
{
}
{
  <SQL_IDENTIFIER>
}


void materializedview() :
{
}
{
  "materializedview" /*TODO*/

}


void sequence() :
{
}
{
  <SQL_IDENTIFIER>

}


void database() :
{
}
{
  "database" /*TODO*/
}

void domain() :
{
}
{
  "domain" /*TODO*/
}

void connection_qualifier() :
{
}
{
  "connection_qualifier" /*TODO*/
}

void partition_key_value() :
{
}
{
  "connection_qualifier" /*TODO*/
}

void subpartition_key_value() :
{
}
{
  "subpartition_key_value" /*TODO*/

}


void partition() :
{
}
{
  "partition" /*TODO*/

}

void time_expr() :
{
}
{
  "time_expr" /*TODO*/
}

void leading_precision() :
{
}
{
  "leading_precision" /*TODO*/
}

void view() :
{
}
{
  <SQL_IDENTIFIER> 
}